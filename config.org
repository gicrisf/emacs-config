#+title: Doom Emacs Configuration
#+author: Giovanni Crisalfi
#+STARTUP: overview

# TODO export name of cover images
# Manca solo questo e poi posso procedere con l'esportazione dei nuovi post
# Export metadata
# TODO elimina la possibilità di esportare il file integralmente
# Solo i paragrafi saranno esportati
# TODO decidere se sezione software o se farlo annualmente,
# mantenendo l'anno d'esportazione
#+zola_base_dir: ~/zwitterio-it/
#+zola_tags: emacs
#+zola_categories: software posts
#+zola_publishdate: 2022-08-10
#+zola_auto_set_lastmod: t
#+zola_date: [2023-04-09 dom]
#+zola_section: software/emacs-config/index.en.md

# Zola-specific divider
#+MACRO: more @@html:<!-- more -->@@

# Temporary macros for prism support
# Waiting for Zola update
# Check this issue: https://github.com/getzola/zola/issues/1787
#+MACRO: prismcss @@html:<link href="/assets/prism/prism.css" rel="stylesheet" />@@
#+MACRO: prismjs @@html:<script src="/assets/prism/prism.js"></script>@@

# Macro for backlinks in exported posts
# Hardcoded, now disabled
# #+MACRO: backlink @@html:<blockquote><p>This post was exported from <a href="https://github.com/gicrisf/emacs-config/blob/main/config.org#$1">my literate configuration for Emacs</a></p></blockquote>@@

#+MACRO: backlink @@hugo:{{ backlink(id="$1", color="yellow") }}@@

#+MACRO: italian @@html:<blockquote class="disclaimer yellow"><p>This section wasn't translated into English, yet. Since Italian is my mother language, I sometimes write in Italian and publish content as is. It may take some time before I can translate everything into English.</p></blockquote>@@

# Please, leave me a star on GitHub
#+MACRO: begforstars @@hugo:{{ begforstars(repo="https://github.com/gicrisf/emacs-config") }}@@

# Custom shortcode for citing would be awesome

Hello, and welcome to my Emacs configuration!
It's written in Org-mode and designed to be /literate/, meaning that I've documented many of the choices I made throughout the process.

{{{more}}}

* What is Emacs: a Definition Dilemma
# developed by Richard Stallman in the 1970s, known for its extensibility and productivity features.
Emacs is a highly customizable text editor. Emacs is a lisp interpreter. Emacs is a text manipulation application. Emacs, like water, adapts to any container, flows around any obstacle, erodes mountains (of data), transforms into different phases (or modes) depending on circumstances.

# Describing Emacs is not easy, because Emacs it's a moldable environment.
Describing Emacs isn't easy, because Emacs is many things, and different ones to different people.
To me, Emacs is the place where I write code, I write prose, I manage files, I read feeds, I think.
In the next sections, I will show how.

* Emacs Distributions
Being Emacs so generic and powerful, it can be difficult to approach it and learn how to work with it. 
Pre-configured Emacs distributions like Spacemacs, NANO Emacs, and Doom Emacs can break down the entry barrier.
- [[https://www.spacemacs.org/][Spacemacs]] - for total beginners and vim converts, effective emulation thanks to [[https://github.com/emacs-evil/evil][Evil]] and many auxiliary functions (unsurprisingly callable through the spacebar).
- [[https://github.com/rougier/nano-emacs][NANO Emacs]] - elegant, has minimal dependencies, closely resembles Vanilla Emacs.
- [[https://github.com/doomemacs/doomemacs][Doom Emacs]] - my current distro, perfect for ex-vimmers, integrates well with Evil, attentive package selection makes it responsive.

# La configurazione riportata in questo file può, potenzialmente, essere adattata anche ad altre distribuzioni Emacs, ma presa com'è funziona solo su Doom Emacs.
The configuration reported in this file could potentially be adapted to other Emacs distributions, but as it is, it only works for Doom Emacs.

* Lisp: the symbolic power woven into Emacs' fabric
CLOSED: [2023-04-29 sab 16:54]
:PROPERTIES:
:EXPORT_ZOLA_SECTION: software/lisp
:EXPORT_FILE_NAME: index.en.md
:EXPORT_DATE: [2023-04-29]
:EXPORT_ZOLA_TAGS: emacs lisp
:EXPORT_ZOLA_COVER_IMAGE: graph-gicrisf-08.png
:END:

In the realm of programming languages, there exists a family known as /Lisp/.
# Dicevo "functional", ma in effetti c'è CLOS, che è object oriented

{{{more}}}
{{{backlink(lisp-the-symbolic-power-woven-into-emacs-fabric)}}}

Lisps are usually associated with the functional paradigm, but they are not confined to it. Some dialects of Lisp are object-oriented, and others have a more imperative style. It depends on the purpose for which they were designed. Generally speaking, they are known for their simple syntax and powerful macro system.

Indeed, the word 'simple' may not be enough to convey what I'm trying to say. Lisp code is written as if it were made only of lists; in fact, the name itself original stood for "LISt Processor".
Lisp's monomorphism (its being being represented only by lists) often scare C-like programmers, but also gives flexibility that allows for easy prototyping and experimentation. Its versatility was illustrated by its uses in artificial intelligence (way before the advent of modern implementations of machine learning methods), theorem proving, web development and a lot of other fields.

Emacs, indeed, is an interpreter of the Lisp language, albeit a specific dialect known as *Emacs Lisp*.

# Questa è una parafrasi del mio elisp-intro
# "Lisp" is a pretty talkative name, as it comes with *a lot* of lists.
In lisp, each list has brackets designating the initial element as the operator and the rest as subordinate data for its function.
I leave below one of the simplest examples that can be conceived.

#+begin_src emacs-lisp
(= 1 2)
;; => nil
#+end_src

This function verifies the identity of the two parameters passed (=1= and =2=, respectively), therefore returning a boolean (=t= for "true", =nil= for "false").

# Non voglio dilungarmi in questa sede nella descrizione del linguaggio.
# Per un assaggio della sintassi e di qualche funzione base, piuttosto, rimando [[https://www.zwitterio.it/software/elisp-intro/][a questo post che ho scritto sul blog come breve introduzione]].
# Avoiding specifics here. To get a gist of syntax and fundamentals, check out [my post on the blog]. Note that it's more of an aggregation of handy pointers than a comprehensive guide.
I'll avoid delving into the language particulars here. Rather, I lend some links:
# - [[https://www.zwitterio.it/coding/2022/elisp-intro/][I drafted an introduction to Emacs Lisp on the blog]], though truly it amounts more to a jumbled conglomeration of personal notes, and a recapitulation of useful functions.
- For a quick tour, I recommend taking a look at this [[https://github.com/chrisdone/elisp-guide][Elisp guide]].
- For a less quick but more in-depth guide, refer to [[https://github.com/hypernumbers/learn_elisp_the_hard_way][Learn Elisp the hard way]].

Now that we have an idea of how Lisp is made, it's time to place it in the timeline.

#+begin_quote
The first LispLanguage compiler was developed by JohnMcCarthy at Dartmouth College between 1955 and 1959. This makes it the second oldest programming language in common use today (only Fortran is older, developed between 1954 and 1957). Lisp went forth and grew many many dialects: the most notable of these are AutoLisp, EmacsLisp, Interlisp, MacLisp, Scheme and Common Lisp.
[cite:@EmacsWikiCommonLisp]
#+end_quote

Emacs provides an interface to other lisps through modes like Sly and Slime, and certain Common Lisp functions can be used by default in Emacs by writing =cl-= prefix in front of them. This highlights the extensibility of Emacs, although the details cannot be addressed here due to space constraints.

{{{begforstars}}}

#+print_bibliography:

* Literate programming: the art of blending code and words
CLOSED:
:PROPERTIES:
:EXPORT_ZOLA_SECTION: software/literate-programming
:EXPORT_FILE_NAME: index.en.md
:EXPORT_DATE: [2023-04-10 lun]
:EXPORT_ZOLA_COVER_IMAGE: watercolor-literate-gicrisf.png
:END:

What is /literate programming/? Is it not just another way of describing code?

{{{more}}}
{{{backlink(literate-programming)}}}

Literate programming is a programming paradigm that emphasizes the organization of code for human understanding, rather than computer execution. It involves embedding documentation and explanatory text alongside code in a single document, allowing for clearer communication of the code's intent and functionality.

# Mia vecchia introduzione
# Il literate programming è un paradigma di programmazione ideato da Donald Knuth che prevede l'alternarsi di testo e di codice, in un modo che sono sicuro sia noto a chiunque si sia mai trovato a maneggiare un Jupiter Notebook.
# a paradigm first proposed by Donald Knuth, who demonstrated its potential by writing the TeX compiler in this way.

In short, everything is written in a single file and the editor is taught how to assemble the code at a later time. The practice of writing the source is called /weaving/, while the moment of exporting is called /tangling/.

This approach has numerous advantages, but I will mention just two of the most evident:
- First of all, the code is very readable even after a long time, but this is a result that could be achieved by commenting a source code properly in the traditional way. Certainly, it is much simpler to associate simplified code blocks or examples from the manual just before writing the code that will then be part of the exported file. In org-mode, it is also possible to combine various languages and run them on the spot with org-babel;
- Secondly, the act of writing does not necessarily have to conform to the order that the text should have for the compiler to understand it, but rather it is expected to follow the developer's reasoning.

To quote Donald Knuth, who was the first to conceive of this approach,

#+begin_quote
The WEB language allows a person to express programs in a "stream of consciousness" order. TANGLE is able to scramble everything up into the arrangement that a PASCAL compiler demands. This feature of WEB is perhaps its greatest asset; it makes a WEB-written program much more readable than the same program written purely in PASCAL, even if the latter program is well commented. And the fact that there's no need to be hung up on the question of top-down versus bottom-up, since a programmer can now view a large program as a web, to be explored in a psychologically correct order is perhaps the greatest lesson I have learned from my recent experiences. [cite:@knuthLiterateProgramming1984]
#+end_quote

To generate the compilable, it is sufficient to call the blocks in the right order with very easy-to-create and easy-to-manage macros, all within the same file. After naming a block of code with its own name, for example =patate=, using the /noweb/ syntax it is sufficient to write =<<patate>>= in another block to see it reappear in the right place.

I don't mean this is the best way to code always. Often it's better to stick to clear and concise code. But sometimes, /weaving/ a few extra characters ahead of time can make processing a lot smoother in the long run. This is especially true with infrequently modified configuration files.

By doing so, it can be easier to explain code to folks. Moreover, there is nothing to prevent writing the more self-evident parts in a classical way and extensively commenting only the small notable pieces. Literate programming extends the freedoms of intervention on the text without imposing limitations in any way, except for adding layers of abstraction that the developer must learn to manage.

The tools of literate programming can be useful to any developer, but they can also become the nucleus of a new way of conceiving programming.

#+begin_quote
Let us change our traditional attitude to the construction of programs: Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.

*The practitioner of literate programming can be regarded as an essayist*, whose main concern is with exposition and excellence of style. Such an author, with thesaurus in hand, chooses the names of variables carefully and explains what each variable means. He or she strives for a program that is comprehensible because its concepts have been introduced in an order that is best for human understanding, using a mixture of formal and informal methods that reinforce each other. [cite:@knuthLiterateProgramming1984]
#+end_quote

For those who seek a deeper dive, behold I leave some additional readings:
- [[https://www.cs.upc.edu/~eipec/pdf/p583-van_wyk.pdf][Communication of the ACM, 1987]]
- [[https://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][Literate programming in org-mode]]

{{{begforstars}}}

#+print_bibliography:

* Doom literification
# Qui spiego il metodo, poi passo all'azione
How can we make Doom Emacs's configuration /literate/?

{{{more}}}

First, we need to know how the usual configuration of Emacs works.
Traditionally, Emacs expects the configuration to be all contained in =.emacs=, so the approach is very simple and straightforward.
# TODO: eltweet import as org shortcode
# @@html:<blockquote class="twitter-tweet"><p lang="en" dir="ltr">OH: I now officially work with people younger than my .emacs file</p>&mdash; â¨ Phil CalÃ§ado (@pcalcado) <a href="https://twitter.com/pcalcado/status/871810979180556292?ref_src=twsrc%5Etfw">June 5, 2017</a></blockquote>@@

Distributions instead provide for a hierarchy of contents in different files.
Doom Emacs collects the configuration in three fundamental files:
- =config.el=;
- =init.el=;
- =packages.el=.

These are contained in a special directory in the home directory, =.doom.d=.
Other distributions have more chaotic or more layered hierarchies (e.g. Spacemacs with its layers).
In my opinion, Doom maintains a pleasant middle ground.

Instead of directly modifying these files, we can write our configuration in an =.org= file, from which we can then generate the 3 main configuration files.
# Grazie ad org-mode è possibile abbracciare il literate programming per mezzo di una libreria detta "babel".
# [[https://blog.thomasheartman.com/posts/configuring-emacs-with-org-mode-and-literate-programming][Come scrive Thomas Heartman sul suo blog]], nelle versioni più recenti di Emacs bastano poche righe di codice per incorporare in org-mode la propria configurazione, grazie ad una funzione speciale di org-babel che supporta proprio questo scopo (sempre più diffuso nella comunità di utenti).

This practice involves writing the configuration in accordance with the principles of literate programming, which we bumped into in the section above.

# As the winds of Emacs blow, one can refine the art of configuring it, much like a master observes and learns from the tricks of others.
The art of configuring Emacs (like many others) is refined by studying the tricks of others.
Notable literary configurations are [[https://gitlab.com/zzamboni/dot-doom][Zamboni's]] and [[https://git.tecosaur.net/tec/emacs-config][Tecosaur's]].

* Beware of the code! (a machine made it)
# Il nostro primo intervento consiste nell'avvisare un eventuale lettore dei nostri file che si tratta di codice generato e che, quindi, non va modificato direttamente.
# Introdurremo, quindi, il seguente commento all'inizio di ogni file di configurazione:
# Queste righe si troveranno a proprio agio, visto che già di default le prime 10-20 righe sono commenti.

Our first intervention is to inform any reader of our files that it is machine-made code and, therefore, that no one should mess with it directly.
We will, therefore, introduce the following comment at the beginning of each configuration file:

#+name: do-not-edit
#+begin_src emacs-lisp
;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; https://github.com/gicrisf/emacs-config
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)
#+end_src

These lines will feel right at home, as the first 10-20 lines are already comments by default.

* Doom's modules
Doom Emacs modules are groups of related packages and configuration settings that enable specific features in your Emacs environment. They are designed to make it easy to selectively enable or disable different pieces of functionality in a modular way. By doing this, you can keep your Emacs configuration organized and efficient so that you only load what you need for your current project or task. The modular design is efficient and keeps Doom Emacs unburdened.

** init.el
Doom's modules are managed through the =init.el= file.

#+begin_src emacs-lisp :tangle init.el :noweb no-export
;;; init.el -*- lexical-binding: t; -*-

<<do-not-edit>>

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a "Module Index" link where you'll find
;;      a comprehensive list of Doom's modules and what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).
#+end_src

As =init.el='s frontmatter says:
1. It's recommended to run =doom sync= after making changes.
2. You can access Doom's documentation by pressing the keys =SPC h d h= (or =C-h d h= for non-vim users).
3. You can view a module's documentation by placing the cursor over its name or flags and pressing =K= (or =C-c c k= for non-vim users), or browse its directory by pressing =gd= (or =C-c c d=).

Whenever Doom Emacs is launched, the following code is evaluated.

#+name: init.el
#+attr_html: :collapsed t
#+begin_src emacs-lisp :tangle init.el :noweb no-export
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :input
       <<doom-input>>

       :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

The =init.el= file is basically a list of lists; the elements are all orchestrated by the wizardry of the =doom!= macro.
The =doom!= macro expects each list provided as an argument to include the module to be installed for its corresponding section (e.g., 'input', 'completion', 'UI', etc.).
There are only two key macros required to wield Doom's power. The =doom!= macro is only the first one. The second macro, =package!=, will be discussed in the next section.
# Attaining the state of Doom requires two macros in the practice of Doom Emacs. The second one, 'package', shall be expounded upon in the following section.

** Input
#+name: doom-input
#+begin_src emacs-lisp
;;chinese
;;japanese
;;layout            ; auie,ctsrnm is the superior home row
#+end_src

** Completion
#+name: doom-completion
#+begin_src emacs-lisp
company           ; the ultimate code completion backend
;;helm              ; the *other* search engine for love and life
;;ido               ; the other *other* search engine...
;;ivy               ; a search engine for love and life
vertico
#+end_src

** UI
#+name: doom-ui
#+begin_src emacs-lisp
;;deft              ; notational velocity for Emacs
doom              ; what makes DOOM look the way it does
doom-dashboard    ; a nifty splash screen for Emacs
doom-quit         ; DOOM quit-message prompts when you quit Emacs
(emoji +unicode)  ; 🙂
hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
;;hydra
;;indent-guides     ; highlighted indent columns
;;ligatures         ; ligatures and symbols to make your code pretty again
;;minimap           ; show a map of the code on the side
modeline          ; snazzy, Atom-inspired modeline, plus API
;;nav-flash         ; blink cursor line after big motions
neotree           ; a project drawer, like NERDTree for vim
ophints           ; highlight the region an operation acts on
(popup +defaults)   ; tame sudden yet inevitable temporary windows
;;tabs              ; a tab bar for Emacs
;;treemacs          ; a project drawer, like neotree but cooler
;;unicode           ; extended unicode support for various languages
vc-gutter         ; vcs diff in the fringe
vi-tilde-fringe   ; fringe tildes to mark beyond EOB
;;window-select     ; visually switch windows
workspaces        ; tab emulation, persistence & separate workspaces
zen               ; distraction-free coding or writing
#+end_src

** Editor
#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere); come to the dark side, we have cookies
file-templates    ; auto-snippets for empty files
fold              ; (nigh) universal code folding
;;(format +onsave)  ; automated prettiness
;;god               ; run Emacs commands without modifier keys
;;lispy             ; vim for lisp, for people who don't like vim
multiple-cursors  ; editing in many places at once
;;objed             ; text object editing for the innocent
;;parinfer          ; turn lisp into python, sort of
;;rotate-text       ; cycle region at point between text candidates
snippets          ; my elves. They type so I don't have to
;;word-wrap         ; soft wrapping with language-aware indent
#+end_src

# **** Cursori multipli
About multiple cursors: just run the =g z z= sequence to spawn a new cursor on place.
# Basta usare =g z z= come shortcut sequenziale per avviare un altro cursore sul posto.

** Emacs
#+name: doom-emacs
#+begin_src emacs-lisp
dired             ; making dired pretty [functional]
electric          ; smarter, keyword-based electric-indent
;;ibuffer         ; interactive buffer management
undo              ; persistent, smarter undo for your inevitable mistakes
vc                ; version-control and Emacs, sitting in a tree
#+end_src

** Term
#+name: doom-term
#+begin_src emacs-lisp
;;eshell            ; the elisp shell that works everywhere
;;shell             ; simple shell REPL for Emacs
;;term              ; basic terminal emulator for Emacs
;; vterm               ; the best terminal emulation in Emacs
#+end_src

** Checkers
#+name: doom-checkers
#+begin_src emacs-lisp
syntax              ; tasing you for every semicolon you forget
;;(spell +flyspell) ; tasing you for misspelling mispelling
;;grammar           ; tasing grammar mistake every you make
#+end_src

** Tools
#+name: doom-tools
#+begin_src emacs-lisp
;;ansible
biblio
;;debugger          ; FIXME stepping through code, to help you add bugs
;;direnv
;;docker
;;editorconfig      ; let someone else argue about tabs vs spaces
;;ein               ; tame Jupyter notebooks with emacs
(eval +overlay)     ; run code, run (also, repls)
;;gist              ; interacting with github gists
(lookup +dictionary +docsets)              ; navigate your code and its documentation
;; lsp               ; M-x vscode
magit             ; a git porcelain for Emacs
;;make              ; run make tasks from Emacs
;;pass              ; password manager for nerds
;;pdf               ; pdf enhancements
;;prodigy           ; FIXME managing external services & code builders
;;rgb               ; creating color strings
;;taskrunner        ; taskrunner for all your projects
;;terraform         ; infrastructure as code
;;tmux              ; an API for interacting with tmux
;;upload            ; map local to remote projects via ssh/ftp
#+end_src

** OS
#+name: doom-os
#+begin_src emacs-lisp
(:if IS-MAC macos)  ; improve compatibility with macOS
;;tty               ; improve the terminal Emacs experience
#+end_src

** Lang
#+name: doom-lang
#+begin_src emacs-lisp
;;agda              ; types of types of types of types...
;;beancount         ; mind the GAAP
cc                ; C > C++ == 1
(clojure +lsp)           ; java with a lisp
common-lisp       ; if you've seen one lisp, you've seen them all
;;coq               ; proofs-as-programs
;;crystal           ; ruby at the speed of c
csharp            ; unity, .NET, and mono shenanigans
;;data              ; config/data formats
;;(dart +flutter)   ; paint ui and not much else
;;elixir            ; erlang done right
;;elm               ; care for a cup of TEA?
emacs-lisp        ; drown in parentheses
;;erlang            ; an elegant language for a more civilized age
;;ess               ; emacs speaks statistics
;;factor
;;faust             ; dsp, but you get to keep your soul
;;fsharp            ; ML stands for Microsoft's Language
;;fstar             ; (dependent) types and (monadic) effects and Z3
;;gdscript          ; the language you waited for
;;(go +lsp)         ; the hipster dialect
;;(haskell +dante)  ; a language that's lazier than I am
hy                ; readability of scheme w/ speed of python
;;idris             ; a language you can depend on
;;json              ; At least it ain't XML
;;(java +meghanada) ; the poster child for carpal tunnel syndrome
javascript        ; all(hope(abandon(ye(who(enter(here))))))
;;julia             ; a better, faster MATLAB
;;kotlin            ; a better, slicker Java(Script)
latex             ; writing papers in Emacs has never been so fun
;;lean              ; for folks with too much to prove
;;ledger            ; be audit you can be
lua               ; one-based indices? one-based indices
markdown          ; writing docs for people to ignore
;;nim               ; python + lisp at the speed of c
nix               ; I hereby declare "nix geht mehr!"
;;ocaml             ; an objective camel
(org +roam2)               ; organize your plain life in plain text
;;php               ; perl's insecure younger brother
;;plantuml          ; diagrams for confusing people more
;;purescript        ; javascript, but functional
python            ; beautiful is better than ugly
;;qt                ; the 'cutest' gui framework ever
racket            ; a DSL for DSLs
;;raku              ; the artist formerly known as perl6
;;rest              ; Emacs as a REST client
;;rst               ; ReST in peace
;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
(rust +lsp)              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala             ; java, but good
(scheme +guile)   ; a fully conniving family of lisps
;; sh                  ; she sells {ba,z,fi}sh shells on the C xor
;;sml
;;solidity          ; do you need a blockchain? No.
;;swift             ; who asked for emoji variables?
;;terra             ; Earth and Moon in alignment for performance.
;; web               ; the tubes
yaml              ; JSON, but readable
;;zig               ; C, but simpler
#+end_src

** Mail
At this moment in time, I refrain from using Emacs to manage emails.

The reasons are many, but they can be summarized as follows:
- Gmail is often supported, but I use ProtonMail nowadays.
- ProtonMail can be set up for external clients, and Emacs is certainly among them, but it requires a premium service; I currently have a free account.
- I'm not so sure Emacs is the best tool for emails. It could have been (and it should be), but the purity of emails has been shattered by letting HTML invade their simplicity. Modern web browsers are probably the optimal medium to interpret emails.

#+name: doom-email
#+begin_src emacs-lisp
;;(mu4e +gmail)
;;notmuch
;;(wanderlust +gmail)
#+end_src

** App
Emacs is my RSS reader.

#+name: doom-app
#+begin_src emacs-lisp
;;calendar
;;emms
;;everywhere        ; *leave* Emacs!? You must be joking
;;irc               ; how neckbeards socialize
(rss +org)        ; emacs as an RSS reader
;;twitter           ; twitter client https://twitter.com/vnought
#+end_src

** Config
# Questa è una literate configuration, quindi mi pare il caso di abilitare il modulo relativo.
# This is a literate configuration, so it looks reasonable to enable the corresponding module.
Enabling the "literate" module seems logical, as this is a literate configuration.

#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

* Doom's packages
After the =doom!= macro introduced earlier, we have the second essential macro, =package!=, that enables us to install some exogenous machineries from MELPA or git repositories.

# Verificare che quanto scritto sia del tutto corretto.
When the Emacs configuration is loaded, the =packages.el= file is parsed in search for =package!= macros. The macros expand into calls to =straight.el=, although with some additional functionality.
This implies that, in general, the better integrated package manager in Doom is Straight.

# Straight è uno dei package manager in Emacs. Spiegarlo a un nabbo.

#+begin_src emacs-lisp :tangle packages.el :noweb no-export
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

<<do-not-edit>>

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or
;; use 'M-x doom/reload'.


;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;(package! some-package)
#+end_src

The comments in the frontmatter explain that to install a package in Doom Emacs, you need to declare the desired packages in the =packages.el= file and then you have two options:
- You can run the =doom sync= command in the terminal. Afterward, you will need to restart Emacs for the changes to take effect,
- You can also use the =M-x doom/reload= command inside Emacs itself (=SPC h r r=).

# Ora spieghiamo come funziona la macro =package!= seguendo la descrizione fornita dai commenti originali del file.
# I pacchetti saranno installati insieme alla loro configurazione, nella parte seguente.

# TODO expand this
How does =package!= works? What an user should know about it? There are 7 cases that the are discussed in the =packages.el= comments:
- Recipe
- Files
- Disable
- Override
- Branch
- Pin
- Unpin

** Recipe
#+name: packages-recipe
#+begin_src emacs-lisp :tangle packages.el
;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/raxod502/straight.el#the-recipe-format
;(package! another-package
;  :recipe (:host github :repo "username/repo"))
#+end_src

** Files
#+name: packages-files
#+begin_src emacs-lisp :tangle packages.el
;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;(package! this-package
;  :recipe (:host github :repo "username/repo"
;           :files ("some-file.el" "src/lisp/*.el")))
#+end_src

** Disable
#+name: packages-disable
#+begin_src emacs-lisp :tangle packages.el
;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;(package! builtin-package :disable t)
#+end_src

** Override
#+name: packages-override
#+begin_src emacs-lisp :tangle packages.el
;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;(package! builtin-package :recipe (:nonrecursive t))
;(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

** Branch
#+name: packages-branch
#+begin_src emacs-lisp :tangle packages.el
;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see raxod502/straight.el#279)
;(package! builtin-package :recipe (:branch "develop"))
#+end_src

** Pin
#+name: packages-pin
#+begin_src emacs-lisp :tangle packages.el
;; Use `:pin' to specify a particular commit to install.
;(package! builtin-package :pin "1a2b3c4d5e")
#+end_src

** Unpin
#+name: packages-unpin
#+begin_src emacs-lisp :tangle packages.el
;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;(unpin! pinned-package)
;; ...or multiple packages
;(unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;(unpin! t)
#+end_src

* Private configuration
Only one of the three essential Doom files we haven't met yet.
It's called =config.el=, which presents this frontmatter.

#+begin_src emacs-lisp :tangle config.el :noweb no-export
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

<<do-not-edit>>

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!


;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
#+end_src

Comment says:
- This is the place for your private configuration.
- Some features (like GPG and email) may require personal information for identification that can be stored in this file (we'll see how to avoid storing sensitive information here).
- The user does not need to run any specific commands to update their configuration after making changes to this file. In a literate configuration perspective, this means you just have to tangle this file to see the changes in action.

* Who am I?
Hi there, I go by the name of Giovanni Crisalfi.

# Hi there, I am Giovanni Crisalfi.
# Greetings, I'm Giovanni Crisalfi, aye.
# Greetings, I, Giovanni Crisalfi, am present.
# Greetings, Giovanni Crisalfi am I.
# I'm Giovanni Crisalfi.
# I am Giovanni Crisalfi.

#+begin_src emacs-lisp :tangle config.el
;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
(setq user-full-name "gicrisf"
      user-mail-address "giovanni.crisalfi@protonmail.com")
#+end_src

# TODO See more in CV section

* Lightning Emacs: How the Daemon reduce startup times
:PROPERTIES:
:EXPORT_HUGO_SECTION: software/emacs-as-daemon
:EXPORT_FILE_NAME: index.en.md
:EXPORT_DATE: [2023-04-05 mer]
:EXPORT_ZOLA_COVER_IMAGE: lightning-gicrisf-00.png
:END:

Running Emacs as a daemon allows you to start Emacs once and then use it in multiple sessions or on different terminals without the overhead of starting up Emacs anew each time.
This translates to faster startup times and more efficient use of system resources.

{{{more}}}
{{{backlink(emacs-as-daemon)}}}

# Si tratta di una possibilità introdotta con Emacs 23.1 per ridurre i (già bassi) tempi di avvio di ogni finestra. Ottimo se, come me, utilizzate Emacs anche per modificare piccoli file di testo per cui andrebbe benissimo vim o nano.
This is a feature introduced with Emacs 23.1 to reduce the (already low) startup times of each window. It's great if, like me, you also use Emacs to edit small text files for which vim or nano would be just fine.

Launching the daemon is simple as running a simple command:

#+begin_src bash
emacs --daemon
#+end_src

# Per lanciarlo all'avvio, si può aggiungere il comando qui sopra nella sezione opportuna fornita dal DE o, meglio ancora, perdere mezzo minuto per impostare systemd (utile soprattutto per chi usa un tiling manager anziché un DE "fatto e finito").
To launch it at startup, you can add the above command in the appropriate section provided by your DE, or better yet, spend half a minute setting up systemd (especially useful for those who use a tiling manager instead of a "ready-made" DE).

#+begin_src :tangle tangled/.config/systemd/user/emacs.service
[Unit]
Description=Emacs text editor
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=/usr/bin/emacs --daemon
ExecStop=/usr/bin/emacsclient --eval "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=on-failure

[Install]
WantedBy=default.target
#+end_src

Systemd needs you to enable and start the process:

#+begin_src bash
systemctl enable --user emacs
systemctl start --user emacs
#+end_src

# Ovviamente non mi sono inventato nulla, sto solo riprendendo la [[https://www.emacswiki.org/emacs/EmacsAsDaemon][documentazione]]. L'approccio qui sopra non funziona se usate CentOS o, chiaramente, se non usate [[https://wiki.archlinux.org/title/Systemd][systemd]]. Ma, solitamente, chi non usa systemd non ha bisogno che glielo dica io, perché se l'è andata a cercare.
Obviously I'm not making anything up, I'm just referring to the [[https://www.emacswiki.org/emacs/EmacsAsDaemon][documentation]]. The approach above doesn't work if you use CentOS or, clearly, if you don't use [[https://wiki.archlinux.org/title/Systemd][systemd]]. But usually, those who don't use systemd don't need me to tell them that, because they went looking for it themselves.

# Fatto ciò, non è sufficiente avviare Emacs con il consueto comando =emacs=, perché quello continuerebbe ad avviare un'istanza per ogni finestra.
# È necessario specificare che vogliamo solo [[https://www.emacswiki.org/emacs/EmacsClient][lanciare un client]].
# After doing this, it is not enough to start Emacs with the usual command "emacs", because that would still start an instance for each window. It is necessary to specify that we only want to launch a client.

To launch Emacs as a client instead of starting a new instance for each window, specifying a special =emacsclient= command (instead of just =emacs=) is necessary.
# Al posto di =emacs=, scriveremo:

#+begin_src bash
emacsclient --create-frame --alternate-editor=""
#+end_src

# Chiaramente, scrivere di volta in volta questo comando è a dir poco noioso, quindi ci conviene aggiungere degli alias su =.bashrc= o lanciarlo con una scorciatoia da tastiera, a seconda del nostro ambiente.
Writing this command everytime is boring, so it would be best to add some aliases to =.bashrc= or launch it with a keyboard shortcut, depending on our environment.

{{{begforstars}}}

* Environment variables on Emacs
:PROPERTIES:
:EXPORT_HUGO_SECTION: software
:EXPORT_HUGO_BUNDLE: environment-variables-on-emacs
:EXPORT_FILE_NAME: index.en.md
:EXPORT_DATE: [2023-04-04 mar]
:EXPORT_ZOLA_COVER_IMAGE: envvars-purple-gicrisf.png
:END:

An environment variable is a key-value pair that is declared and stored in the operating system. They can be referenced by different programs or scripts running on the same system.
Clearly, the program must have access to the environment to use the variable: that's the whole point of *environment* variables.

{{{more}}}
{{{backlink(environment-variables-on-emacs)}}}

Traditional examples of environment variables include =PATH=, =HOME=, and =USER=.

In most linux distributions, you can launch an =echo= command like this to check your =HOME= var:

#+begin_src bash :exports value :wrap SRC
echo $HOME
#+end_src

In my case, that's the result.

#+RESULTS:
#+begin_SRC
/home/cromo
#+end_SRC

Maybe, you need a different environment variable ("env var" from now on).
How can you set it?

** The traditional approach
If you have bash as a shell, you can simply set it the traditional way:

#+begin_src bash
#~/.bashrc
export VARNAME="var string"
#+end_src

You could need the said env var *inside Emacs*, because a package requires it.
Emacs has you covered, since emacs-lisp has a function to access env vars.

#+begin_src emacs-lisp
(getenv "VARNAME")
#+end_src

I used to to export my env vars from =.bashrc= like showed above and it was fine, especially if the variables didn't require extra caution (it's the case of a token you use for running a bot, for example). In most cases, you should be fine with a similar setup.
But most cases are not "all cases" and I encountered the problematic case.
Was I surprised? Of course not, it's never so simple.

** The problem with the daemon
If you run Emacs from a Daemon, your =getenv= functions start returning =nil=.
Why's that?

To answer this question, we need to understand how processes are managed in a typical Linux system.
The following diagram represents a high-level overview of the architecture of an operating system.

#+begin_comment d2
hardware: Hardware {
  # CPU
  # Memory
  # Devices
  os: OS/Kernel space {
    user: User space {
      direction: right

      shell: Shell {
        utilities: Utilities, shared libraries
        programs: User programs

        programs -> utilities -> programs
      }
      init: systemd
      daemons: Daemons, servers, glibc, other applications

      init -> shell: starts and supervises
      init -> daemons: starts and supervises
      daemons -> shell.programs -> daemons
    }
  }
}
#+end_comment

#+Caption: This diagram shows the hardware layer (CPU, memory, and devices are implicit) and the software layer on top, which includes the OS/kernel space and the user space. The image was made with D2. Released by Giovanni Crisalfi under CC BY-NC-SA.
[[file:os-overview.png]]

Within the user space, there are various components such as the shell (which includes utilities and user programs), systemd (which starts and supervises the shell and daemons), daemons (servers and other applications), and shared libraries.

#+begin_comment d2 :file user-space-emacs-daemon-diagram.png
user: User space {
  direction: right

  shell: Shell {
    utilities: Utilities, shared libraries

    envvars: Env vars are here! {
      shape: stored_data
      style: {
        font-color: white
        font-size: 28
        fill: red
      }
    }

    programs: User programs
    programs -> utilities -> programs

    # emacsf: Emacs frame
  }
  init: systemd
  daemons: Daemons {
    emacs: Emacs daemon {
      style: {
        fill: "#41208b"
        font-color: white
        font-size: 28
        stroke: "#6045a1"
        stroke-width: 5
      }
    }
  }

  # daemons.emacs -> shell.emacsf -> daemons.emacs

  servers: Servers
  glibc: GNU C library
  apps: other applications

  init -> servers
  init -> glibc
  init -> apps
  init -> shell
  init -> daemons

  servers -> shell -> servers
  glibc -> shell -> glibc
  apps -> shell -> apps

  daemons -> shell.programs -> daemons
}
#+end_comment

#+Caption: This diagram shows the relationships between the components inside the user space (for example, how systemd supervises both the shell and daemons). The image was made with D2. Released by Giovanni Crisalfi under CC BY-NC-SA.
[[file:user-space.png]]

By focusing on the user space, we can observe that *Emacs is not running within the shell and therefore does not have access to the environment variables*. However, if Emacs is launched from the terminal emulator, the =getenv= command will work again.
# When setting up the Emacs daemon, it is launched *directly* by systemd.

So, how can you maintain the daemon while not giving up on environment variables?
As for every technical problem, there are a lot of ways to solve it.
It depends on the case what is the most appropriate solution.

** The "Emacs as OS" approach
# Questo ed i prossimi due paragrafi sono stati pubblicati per la prima volta il 2022.03.16
Xahlee solved the problem in the most emacs-y way possible: [[http://xahlee.info/emacs/emacs/emacs_env_var_paths.html][setting everything from inside Emacs]]. He must have thought "why should I ever leave Emacs?". That's the classical thought process of any emacser, so it shouldn't surprise anybody.

Emacs let you set environment variables with =setenv=.

#+begin_src emacs-lisp
(setenv "VARNAME" "var string")
#+end_src

I was searching for something different, since I have other scripts that run outside of Emacs and they need access to env vars too. I could duplicate the env vars, but I refuse: it feels hacky and it's hard to maintain.

** The Systemd approach
A member of the Arch community "[[https://bbs.archlinux.org/viewtopic.php?id=163436][found a good way to export environment variables using systemctl so that they are available to systemd spawned processes]]". This could be exactly what I was looking for, but I don't like the idea of converting the other scripts and messing with systemd, so I kept looking for a different solution.

** The diffy approach
In my quest for a balanced way to manage this problem, I found [[https://unix.stackexchange.com/a/285257][an interesting answer on unix stackexchange]] that links a [[https://gist.github.com/ffevotte/9345586][gist]] which presents a

#+begin_quote
nice piece of Emacs lisp that uses diff to compare outputs of export command before and after sourcing, and then calls setenv function accordingly.
#+end_quote

The idea is to maintain a shell file as a source and getting the environment variables from there, while diffing it with the ones that are loaded already:

#+begin_src emacs-lisp
(defun source (filename)
  "Update environment variables from a shell source file."
  (interactive "fSource file: ")

  (message "Sourcing environment from `%s'..." filename)
  (with-temp-buffer

    (shell-command (format "diff -u <(true; export) <(source %s; export)" filename) '(4))

    (let ((envvar-re "declare -x \\([^=]+\\)=\\(.*\\)$"))
      ;; Remove environment variables
      (while (search-forward-regexp (concat "^-" envvar-re) nil t)
        (let ((var (match-string 1)))
          (message "%s" (prin1-to-string `(setenv ,var nil)))
          (setenv var nil)))

      ;; Update environment variables
      (goto-char (point-min))
      (while (search-forward-regexp (concat "^+" envvar-re) nil t)
        (let ((var (match-string 1))
              (value (read (match-string 2))))
          (message "%s" (prin1-to-string `(setenv ,var ,value)))
          (setenv var value)))))
  (message "Sourcing environment from `%s'... done." filename))
#+end_src

I think it's kind of an overenginereed solution, but I like the spirit of leaving the source of variables *outside* Emacs and accessible to the shell. So, I came out with a simpler method that works for me.

# In 2022-03-16 I wrote:
# "Now I must do other things in my life, but I promise that I will update this post soon, hopefully with a reasonable and elegant solution. Better: with a working solution. A working solution would be just fine."
# Well, now I'm fucking back

** The lispy approach
# As it was rightly explored in [[https://github.com/syl20bnr/spacemacs/issues/12451][this Spacemacs' Github issue]], if you load Emacs as Daemon, it doesn't have any access to your usual environment variables.
If you keep the environment variables in a single "lisp-y" file (I mean a valid lisp list stored as simple text), it's possible to import the values both in Emacs and in Bash with a minimal effort. I present an example of such text here below:

#+begin_src lisp
'(("EXAMPLE_OF_KEY" "example-of-pwd")
  ("ANOTHER_EXAMPLE_OF_KEY" "another-example-of-pwd"))
#+end_src

# Assicuriamoci che le variabili d'ambiente siano correttamente importate.
# Nel mio caso, le variabili sono innanzitutto conservate in un piccolo file, da cui poi vengono riportate sia nella shell che qui su Emacs.
# Come possiamo importarle?

# Su Emacs, la funzione per creare una variabile d'ambiente è =setenv=, così come quella per leggere una variabile d'ambiente è =getenv=.
# Molto semplice. Allora noi prendiamo questa lista ed applichiamo =setenv= ad ogni elemento.

# Let's make sure that the environment variables are correctly imported.
Now, how can we import them in Emacs?

As we saw before, the function to create an environment variable is =setenv=, just as the function to read an environment variable is =getenv=. Very simple.
So, we take the list in the file and apply =setenv= to each element.

Since applying a function to every element in a list is what functional programmers call "mapping", we can rephrase by saying that we need to map the list.

# I made this one to watch how to remember how one should use a map function, in order to personally write the next example
# Here's an example Emacs Lisp function that maps a list of cons cells against another function:

#+begin_comment emacs-lisp
(defun mapcons (fn lst)
  "Apply FN to each element of LST, which is a list of cons cells."
  (mapcar (lambda (cons-cell)
            (cons (funcall fn (car cons-cell))
                  (funcall fn (cdr cons-cell))))
          lst))
#+end_comment

# This function takes two arguments: =fn=, which is the function that should be applied to each element of the cons cell; and =lst=, which is the list of cons cells to be mapped over. The =mapcar= function applies the anonymous lambda function provided to each element of the list, using =funcall= to call the =fn= function on both the =car= and =cdr= of each cons cell. The result is a new list of cons cells, with the original contents mapped to the result of applying =fn=.

In the next example, the previous list is called =example-list-of-api-keys=; a =mapc= function call is called on it, and every =cons-cell= in the list has its car bound as the key of the environment variable, while its cdr is bound as its value.

#+begin_src emacs-lisp
;; List of `cons-cells` to bind to shell variables.
(setq example-list-of-api-keys
      '(("EXAMPLE_OF_KEY" "example-of-pwd")
        ("ANOTHER_EXAMPLE_OF_KEY" "another-example-of-pwd")))

;; Binds the contents of the `cdr` branch of each `cons-cell`
;; in `example-list-of-api-keys` as environment variables,
;; using the `car` branch as the variable name.
(mapc (lambda (cons-cell)
        (setenv (car cons-cell) (car (cdr cons-cell))))
      example-list-of-api-keys)
#+end_src

From the example to the reality: we now need a function to retrieve the variables from the file. Since the content of the file should be a valid lisp string, we better evaluate it directly with this function.

#+begin_src emacs-lisp :tangle config.el
;; Thanks to
;; https://stackoverflow.com/a/30568768
(defun eval-file (file)
  "Execute FILE and return the result of the last expression."
  (load-file file)
  (with-temp-buffer
    (insert-file-contents file)
    (emacs-lisp-mode)
    (goto-char (point-max))
    (backward-sexp)
    (eval (sexp-at-point))))
#+end_src

# Adesso carichiamo le variabili vere e proprie.
# Now, this is how we could actually load the secret env vars in =./envvars= file.
#+begin_comment emacs-lisp
;; Set the actual env vars with the function used in the example above
(mapc (lambda (cons-cell)
        (setenv (car cons-cell) (car (cdr cons-cell)))) (eval-file "~/.envvars"))
#+end_comment

# Instead of leaving all condensed in a single =mapc=, naming the process under a single function it's useful because it's better to hooks it at Emacs' startup.
Moreover, we can decouple the file path in a proper variable, which makes everything more readable and editable in the long run.

Finally, we create:
- a variable that stores the path of the file with the env vars
- a function that executes all the needed steps
# - a hook that runs the function on startup

Then, we run it right away.

#+begin_src emacs-lisp :tangle config.el
;; This file could be placed anywhere
(setq env-vars-file-path "~/.envvars")

(defun load-env-vars ()
  (let ((env-var-list (eval-file env-vars-file-path)))
    (mapc (lambda (cons-cell)
            (setenv (car cons-cell) (car (cdr cons-cell)))) env-var-list)))

(load-env-vars)
#+end_src

# As suggested here
# https://emacs.stackexchange.com/a/15099/39328
# (add-hook 'after-init-hook #'load-env-vars)

** Back in Bash
How to print strings in a file with emacs lisp?

You can use the =write-region= function to write a string to a file in Emacs Lisp. Here's an example:

#+begin_src emacs-lisp
(with-temp-file "filename.txt"
  (insert "Hello, world!"))
#+end_src

This will create a new file called "filename.txt" in the current directory and write the string "Hello, world!" to it.

#+begin_src emacs-lisp :tangle config.el
(defun bash-load-env-vars ()
  (let* ((env-var-list (eval-file env-vars-file-path))
         (bash-strings (mapcar (lambda (cons-cell)
                                 (concat "export "
                                         (car cons-cell) "="
                                         (concat "'" (car (cdr cons-cell)) "'")))
                               env-var-list)))
    (with-temp-file "~/.bashvars"
      (mapc (lambda (exp_string)
              (insert (concat exp_string "\n"))) bash-strings))))
#+end_src

Now I can call this function from =.bashrc= or similar files to have the desired variable exported in the shell.

#+begin_src bash
# ~/.bashrc

# generate or regenerate .bashvars
emacsclient -e '(bash-load-env-vars)' > /dev/null 2>&1

# load or reload .bashvars
if [ -f ~/.bashvars ]; then
. ~/.bashvars
fi
#+end_src

Since we don't need the output of =bash-load-env-vars=, we redirect it to =/dev/null= ([[https://unix.stackexchange.com/a/459404][like shown here]]).

** Conclusions
Ultimately, the environment variables are managed by three components:
- Lisp variables are loaded into Emacs by calling the function =load-env-vars()=;
- You can sync the variables stored locally with a password manager (e.g. Bitwarden);
- Bash variables are exported from Emacs by calling the function =bash-export-env-vars()= to a local directory.

#+Caption: The diagram represents a system with three components: 'Local storage', 'Password manager' and 'Emacs'. The arrows indicate the flow of data and commands between these components. The image was made with D2. Released by Giovanni Crisalfi under CC BY-NC-SA.
[[file:conclusion.png]]

#+begin_comment d2
direction: right

Comment and explain what this d2 diagram represents:

dir: Local storage {
  lispy: Lispy vars {
    shape: stored_data
  }

  bashy: Bash vars {
    shape: stored_data
  }
}

bitwarden: Password manager {
  shape: cloud
}

emacs: Emacs {
  style: {
    fill: "#41208b"
    font-color: white
    stroke: "#6045a1"
    stroke-width: 5
  }
}

dir.lispy -> emacs: load-env-vars()
bitwarden -> dir.lispy -> bitwarden
emacs -> dir.bashy: bash-export-env-vars()
#+end_comment

Well, we made it.

To the next adventure!

{{{begforstars}}}
{{{prismcss}}}
{{{prismjs}}}

* Emacs UI
** Line numbers
#+begin_src emacs-lisp :tangle config.el
;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type t)
#+end_src

** COMMENT Maximize on startup
#+begin_src emacs-lisp :tangle config.el
;; Maximize the window upon startup
;; TODO testing this one
(setq initial-frame-alist '((top . 1) (left . 1) (width . 114) (height . 32)))
#+end_src

** COMMENT Frame transparency
Transparency in UI can add a visually interesting layer to the design of an application like Emacs.
Transparency can create depth and dimensionality, making the UI feel more immersive and interactive.
Therefore, making transparencies in UI is a cool thing to do.

# Transparency in UI can add a visually interesting layer to the design of an application or website. It can enhance the overall aesthetics by allowing elements to blend together in a subtle and harmonious way. Additionally, transparency can create depth and dimensionality, making the UI feel more immersive and interactive. Overall, transparency can help to elevate the design of a UI and make it more engaging for users.

#+begin_src emacs-lisp :tangle config.el
;; Transparency
(set-frame-parameter (selected-frame)'alpha '(99 . 100))
(add-to-list 'default-frame-alist'(alpha . (99 . 100)))
#+end_src

** Fonts
Fonts are a core element in a text editor.
Overall, the right font can greatly enhance the user experience.

# Fonts are an important element in a text editor because they affect the visual appearance of text, making it easier for users to read and understand. Different fonts have varying weights, sizes, and styles, which can be used to emphasize certain words, headings, or sections. Additionally, some fonts are designed for specific use cases, such as coding fonts that are optimized for ease of use and readability when coding.
Since I use Emacs on multiple devices, usually a laptop and a desktop computer, I need the font to conform as best as possible to the screen dimensions. Instead of hardcoding a standard size here, I retrieve it as an environment variable:

#+begin_src emacs-lisp :tangle config.el
;; Doom exposes five (optional) variables for controlling fonts in Doom. Here
;; are the three important ones:
;;
;; + `doom-font'
;; + `doom-variable-pitch-font'
;; + `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;;
;; They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
;; font string. You generally only need these two:
(setq doom-font (font-spec :family "Noto Sans Mono" :size (string-to-number (getenv "DOOM_FONT")) :weight 'semi-light)
      doom-variable-pitch-font (font-spec :family "sans" :size (string-to-number (getenv "DOOM_VARIABLE_PITCH_FONT"))))
#+end_src

# Sfortunatamente, le funzioni per aumentare o diminuire la dimensione del font sembrano mappate diversamente dalle aspettative.
Unfortunately, the functions for increasing or decreasing the font size seem to be mapped differently than expected.
When I try to increase the font size, I get "The font hasn't been resized", just like described in this [[https://www.reddit.com/r/emacs/comments/y4l1e1/cannot_resize_past_default_font_size/][Reddit thread]].
Here a simple remapping to restore the expected behaviour:

#+begin_src emacs-lisp :tangle config.el
(map!
 :n "C-=" #'doom/reset-font-size
 :n "C-+" #'text-scale-increase
 :n "C--" #'text-scale-decrease)
#+end_src

** Default theme
First of all, let's select a default theme.
# Innanzitutto, selezioniamo un tema di default.

#+begin_src emacs-lisp :tangle config.el
;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
(setq doom-theme 'doom-city-lights)
#+end_src

I'm loving City Lights right now and [[https://github.com/gicrisf/qute-city-lights][I realized a City Lights theme for qutebrowser]] too because I wanted to keep everything so uniform and polished.
There's just one single thing that makes me annoyed: when I declare a task as DONE in org-mode, not only the "DONE" keyword gets grayed out, but the title too. I should work on this detail.

# Al momento mi trovo bene con city lights: c'è solo una piccolezza che mi irrita parecchio.
# Nel momento in cui dichiaro concluso un task (con "DONE") in org-mode, il tema mi grigia non solo la keyword ma anche il titolo.
# TODO cambiare questo comportamento.

# Alcuni commenti da ricordare:
I leave those default comments here; they're pretty helpful and concise.

#+begin_src emacs-lisp :tangle config.el
;; Here are some additional functions/macros that could help you configure Doom:
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
;; This will open documentation for it, including demos of how they are used.
;;
;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
;; they are implemented.
#+end_src

** Spacemacs themes
# Sono affezionato ai temi di spacemacs. Uso specialmente quello chiaro, se ho bisogno di sovrailluminare lo schermo.
I'm emotionally attached to the Spacemacs' themes. Sometimes I make use of =spacemacs-light=, usually when the environment is brighter than usual (e.g. I'm trying to read outside on a sunny day).

#+begin_src emacs-lisp :tangle packages.el
(package! spacemacs-theme)
#+end_src

Speaking about other distro themes, I would like to make use of Nano-Emacs' colors, but by the moment it does look harder then it seems. Henrik Lissner, Doom Emacs' creator, said he would have made a specific module for this integration, but of course it's not an immediate priority, so I think I'll wait with hope.
# Mi piacerebbe molto avere a disposizione anche i colori di nano-emacs, ma per il momento sembra sia una cosa più complessa del previsto. Henrik Lissner ha detto un paio di volte che avrebbe intenzione di dedicare un intero modulo a questa integrazione, ma non sembra una priorità.

Reaching a similar result is possible with "Lambda themes" (see below).

** Lambda themes
From [[https://github.com/Lambda-Emacs/lambda-themes][the README]]:

#+begin_quote
In general the theme aims to use as few highly distinct colors as possible without crossing over into full “monochrome” territory. It also means that the themes use various devices other than foreground face color to capture meaningful differences in text. Different text weights are used throughout, as are subtle differences in background coloring. Colored headlines are largely avoided.
#+end_quote

Installing lambda themes:

#+begin_src emacs-lisp :tangle packages.el
(package! lambda-themes :recipe (:host github :repo "lambda-emacs/lambda-themes"))
#+end_src

** Catppuccin theme
#+begin_quote
[[https://github.com/catppuccin/catppuccin][Catppuccin]] is a community-driven pastel theme that aims to be the middle ground between low and high contrast themes. It consists of 4 soothing warm flavors with 26 eye-candy colors each, perfect for coding, designing, and much more!
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! catppuccin :recipe (:host github :repo "catppuccin/emacs"))
#+end_src

** Theme ciclator
# Some day I will write what this is about, but I hope the point is pretty easy to grasp for any lisp enthysiast like you probably are.
This Emacs Lisp code defines a circular list of themes (=quick-switch-themes=) and a function (=toggle-theme=) to switch between these themes with a single command. The function will enable the next theme in the list or disable all themes if the end of the list is reached. It also includes a keybinding (=SPC t t=) to quickly toggle between themes. This code could be useful for anyone who frequently switches between different color themes in Emacs.

#+begin_src emacs-lisp :tangle config.el
;; Theme switcher functions
(defvar quick-switch-themes
  (let ((themes-list (list 'lambda-dark
                           'lambda-light)))
    (nconc themes-list themes-list))
  "A circular list of themes to keep switching between.
Make sure that the currently enabled theme is at the head of this
list always.

A nil value implies no custom theme should be enabled.")

;; Thanks to narendraj9, user of emacs.stackexchange.com
;; https://emacs.stackexchange.com/questions/24088/make-a-function-to-toggle-themes
;; I just tweaked his code.
(defun toggle-theme ()
  (interactive)
  (if-let* ((next-theme (cadr quick-switch-themes)))
      (progn (when-let* ((current-theme (car quick-switch-themes)))
               (disable-theme (car quick-switch-themes)))
             (load-theme next-theme t)
             (message "Loaded theme: %s" next-theme))
    ;; Always have the dark mode-line theme
    (mapc #'disable-theme (delq 'smart-mode-line-dark custom-enabled-themes)))
  (setq quick-switch-themes (cdr quick-switch-themes)))

(map! :leader
      :desc "Quick toggle theme" "t t" #'toggle-theme)
#+end_src
** Layout
*** COMMENT Resources
Vorrei usare Perspective.
Mi sembra tipo le sessioni in qutebrowser, molto comodo.
Ci guarderò in un secondo momento, ora sto annegando per l'ansia.
https://github.com/nex3/perspective-el

* Org-mode
[[https://orgmode.org/][Org-mode]] is a major mode for Emacs that provides a powerful system for organizing and managing information.
Another vague definition, isn't it? It is certainly not a coincidence.
The truth is that org-mode is often described as a markup language, but aspires to a much higher goal.

#+begin_quote
Your life in plain text
#+end_quote

Indeed, Org-mode is an enjoyable and versatile markup language, and for this reason it is often compared with [[https://en.wikipedia.org/wiki/Markdown][Markdown]] or [[https://en.wikipedia.org/wiki/ReStructuredText][reStructuredText]], but thanks to its flexibility and extensibility, it can be employed for a wide range of tasks, from writing notes and lists to managing projects and even creating LaTeX documents.

The strength of org-mode lies in its parser. Thanks to it, Emacs is capable of turning a simple text file into living substance: internally, the parsed data is organized into a hierarchical tree structure that can be navigated and manipulated using various commands and functions provided by org-mode.
In addition to its built-in functionality, org-mode also has a vibrant ecosystem of extensions and plugins that can be used to extend its capabilities.

# recognizing and interpreting a wide variety of structured text and, so, enabling to perform operations like formatting, outlining, and export with great flexibility and precision.
# It allows users to create and organize notes, TODO lists, schedules, and documents using plain text files with a simple markup syntax.
# Org-mode is one of the most beloved major modes in Emacs and one of the best pieces of software I have ever encountered.
# Initially, org-mode may appear to be similar to other markup languages such as Markdown or reStructuredText, given its pleasant syntax. However, org-mode offers far more functionality and capabilities beyond that of a simple markup language.
# A prima vista sembra "solo l'ennesimo linguaggio di markup", come [[https://en.wikipedia.org/wiki/Markdown][Markdown]] o [[https://en.wikipedia.org/wiki/ReStructuredText][reStructuredText]], ma in realtà è molto, molto di più [fn::anche se, bisogna dirlo, se pure fosse un semplice linguaggio di markup ci sarebbe da tenerne in conto, vista la piacevole sintassi].

Just like Emacs, Org-mode needs a lot of working hours to be known and tamed for good.
We can enumerate some common uses here:
- simple notes
- /literate programming/
- planners
- zettelkasten
- scientific writing
- blogging

# Proprio come l'abissale versatilità di Emacs riesce a farsi conoscere solo grazie ad ore ed ore di utilizzo, anche Org-mode ha bisogno di tempo per essere addomesticato; in questo caso, in compenso, è più facile annoverare gli utilizzi più comuni:
# - applicazioni di /literate programming/ (un paradigma di programmazione ideato da Donald Knuth, che è alla base anche di questo documento),
# - scrittura di agende
# - scrittura di zettelkasten
# - stesura di documenti scientifici
# - mantenimento di uno o più blog

# Org-mode, o più semplicemente "Org", può anche essere impiegato per scrivere e gestire nel tempo la propria configurazione di Emacs, cioè un mucchio di codice lisp che con il tempo tende a crescere per adeguarsi quanto più possibile alle necessità dell'utente.

Now we declare in which directory we want most org files to be placed, in such way that Emacs can know where they should be searched for.
# Innanzitutto, dichiariamo in quale directory vogliamo che risiedano la maggior parte dei file org (o almeno quelli usati più di frequente), così che Emacs sappia dove cercarli.

#+begin_src emacs-lisp :tangle config.el
;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(setq org-directory "~/Dropbox/org/")
#+end_src

Now we can start configuring Org-mode.

* Org downloads
I think =org-download= is a killer feature of it, since it gives us a way to easily attach elements to the document without never leaving Emacs.
# Adesso possiamo cominciare ad estendere Org-mode. Una prima killer feature, a mio avviso, è data da =org-download=, che ci consente di appiccicare direttamente degli allegati al file org senza mai abbandonare Emacs, né il documento stesso.

#+begin_src emacs-lisp :tangle packages.el
(package! org-download)
#+end_src

[[https://github.com/doomemacs/doomemacs/issues/3830#issuecomment-679925113][Starting from 2020 August 25]], =org-download-clipboard= is bound to =SPC m a p= in org-mode.
# =org-download-clipboard= è legato a =SPC m a p= [[https://github.com/doomemacs/doomemacs/issues/3830#issuecomment-679925113][dal 25 agosto 2020]] in Doom Emacs.

Drag and drop to dired:

#+begin_src emacs-lisp :tangle config.el
(require 'org-download)
(add-hook 'dired-mode-hook 'org-download-enable)
#+end_src

* Spaced repetition
** Org drill
# Una volta usavo Anki, ora mi sono chiesto perché usare una GUI quando posso semplicemente scrivere tutto il necessario.
I occasionally use this package, but I prefer writing my text here, then exporting my cards in Anki, so I mostly do that now.

#+begin_src emacs-lisp :tangle packages.el
(package! org-drill)
#+end_src

** Anki
#+begin_quote
anki-editor – Emacs minor mode for making Anki cards with Org
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! anki-editor)
#+end_src

In order to make this work, you should install the =anki-connect= Anki plugin too.
# Bisogna ricordare di installare il plugin Anki chiamato "anki-connect", altrimenti non funziona.

** COMMENT Logseq
Qui per vedere come configurare.
https://coredumped.dev/2021/05/26/taking-org-roam-everywhere-with-logseq/

* Org Journal
Install the package.

#+begin_src emacs-lisp :tangle packages.el
(package! org-journal)
#+end_src

Configure the keybindings and some parameters.

#+begin_src emacs-lisp :tangle config.el
;; org journal
;; in ~/.doom.d/+bindings.el
;; From: https://www.rousette.org.uk/archives/doom-emacs-tweaks-org-journal-and-org-super-agenda/
(map! :leader
      (:prefix ("j" . "journal") ;; org-journal bindings
        :desc "Create new journal entry" "j" #'org-journal-new-entry
        :desc "Open previous entry" "p" #'org-journal-open-previous-entry
        :desc "Open next entry" "n" #'org-journal-open-next-entry
        :desc "Search journal" "s" #'org-journal-search-forever))

;; The built-in calendar mode mappings for org-journal
;; conflict with evil bindings
(map!
 (:map calendar-mode-map
   :n "o" #'org-journal-display-entry
   :n "p" #'org-journal-previous-entry
   :n "n" #'org-journal-next-entry
   :n "O" #'org-journal-new-date-entry))

;; Local leader (<SPC m>) bindings for org-journal in calendar-mode
;; I was running out of bindings, and these are used less frequently
;; so it is convenient to have them under the local leader prefix
(map!
 :map (calendar-mode-map)
 :localleader
 "w" #'org-journal-search-calendar-week
 "m" #'org-journal-search-calendar-month
 "y" #'org-journal-search-calendar-year)

(setq org-journal-dir "~/org/amalgam")
(setq org-journal-file-format "%Y-%m.org")
(setq org-journal-file-type 'monthly)
#+end_src

* Org on Web
** Org Web Tools
From [[https://github.com/alphapapa/org-web-tools][the README]]:

#+begin_quote
This file contains library functions and commands useful for retrieving web page content and processing it into Org-mode content.
#+end_quote

To install the package:

#+begin_src emacs-lisp :tangle packages.el
(package! org-web-tools)
#+end_src

** Org-capture
# Org capture torna comodo per appuntarsi in org-mode frammenti di pagine web.
Org capture is useful for taking notes in org-mode of fragments of web pages

# Come manipolare l'HTML, però, è qualcosa che noi dobbiamo spiegare ad =org-capture=, fornendo uno o più template.
How to manipulate HTML, however, is something that we have to explain to =org-capture=, providing one or more templates.

#+begin_src emacs-lisp :tangle config.el
;; org-capture
(setq org-capture-templates `(
	("p" "Protocol" entry (file+headline ,(concat org-directory "notes.org") "Inbox")
        "* %^{Title}\nSource: %u, %c\n #+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?")
	("L" "Protocol Link" entry (file+headline ,(concat org-directory "notes.org") "Inbox")
        "* %? [[%:link][%:description]] \nCaptured On: %U")
))
#+end_src

# Al fine di usare [[https://github.com/sprig/org-capture-extension][Org capture extension (Firefox)]], dobbiamo anche impostare l'org-protocol.
In order to use [[https://github.com/sprig/org-capture-extension][Org capture extension (Firefox)]], we must also set up org-protocol.

#+begin_quote
The gist of it is to make your system recognize emacsclient as the handler of org-protocol:// links. In addition, one needs to set up emacs to load org-protocol and to set up capture templates.
#+end_quote

# Su linux, bisogna prima registrare questo handler:
On Linux, you must first register this handler:

#+begin_src txt :tangle tangled/.local/share/applications/org-protocol.desktop
[Desktop Entry]
Name=org-protocol
Exec=emacsclient %u
Type=Application
Terminal=false
Categories=System;
MimeType=x-scheme-handler/org-protocol;
#+end_src

# A questo punto, su Gnome ed altri GTK-based Desktop Environments, è sufficiente lanciare questo comando:
At this point, on GNOME and other GTK-based desktop environments, it is sufficient to launch this command:

#+begin_src bash
$ update-desktop-database ~/.local/share/applications/
#+end_src

** COMMENT Resources
- Verb: https://github.com/federicotdn/verb (Verb is a package for Emacs which allows you to organize and send HTTP requests)

* Citations
# :PROPERTIES:
# :EXPORT_HUGO_SECTION: 2023
# :EXPORT_HUGO_BUNDLE: citations
# :EXPORT_FILE_NAME: index
# :EXPORT_DATE: [2023-04-27 gio]
# :END:

Managing citations can be cumbersome, but they matter (a lot).
Citations enable readers to trace the evolution and development of an idea or a field of study, and assess the credibility and reliability of the work.

*How can we use Emacs to cite better?*

In recent years, a lot of wonderful people have tried to answer this same question.
So, packages like =org-ref= and, consequently, =org-cite= were born.

# Da https://kristofferbalintona.me/posts/202206141852/#org-ref
#+begin_quote
[[https://github.com/jkitchin/org-ref][Org-ref]] has historically been the dominant citation system for org-mode. I elect to use org-cite instead because (i) it comes with org-mode, meaning there is one less conceptual- and configuration-layer to navigate, (ii) Moreover, org-ref uses a format that follows org conventions less closely, and (iii) I have read that is arguably more robust and future-proof. Nevertheless, some users still prefer it.
#+end_quote

Doom try to condense the essentials in the =tools::biblio= module, which I enable in the =doom!= block.

# Prima usavo org-ref, ora ho deciso di usare org-cite.
# https://blog.tecosaur.com/tmio/2021-07-31-citations.html

#+begin_comment
- doom-package:bibtex-completion if doom-module::completion ivy or doom-module::completion helm
- doom-package:parsebib if doom-module::completion ivy or doom-module::completion helm or doom-module::completion vertico
- doom-package:citar if doom-module::completion vertico
- doom-package:citar-embark if doom-module::completion vertico
- doom-package:citar-org-roam if doom-module::completion vertico and doom-module::lang org +roam2
- doom-package:helm-bibtex if doom-module::completion helm
- doom-package:ivy-bibtex if doom-module::completion ivy
#+end_comment

Is there anything specific we need to do before installing this module?

#+begin_quote
*There are no hard dependencies for this module* ["biblio", ndr], but this module can benefit from having a PDF reader and one of Doom’s doom-module::completion modules. [...]
For vertico, helm, or ivy bibtex completion you should enable doom-module::completion vertico, doom-module::completion helm, or doom-module::completion ivy respectively.
#+end_quote

# I was using ivy as a completion system, but I never made real use of its full potential. For this reason, and another one that we will discuss soon, I switched to vertigo.
I previously used ivy for autocompletion, but I didn't fully made use of its capabilities. Due to this and another reason I'll mention soon, I switched to vertigo.
# Ora uso vertico (nei moduli) perché è quello che supporta citar.
# voglio citar perché è quello che prevede un pacchetto dedicato per org-roam
# Quindi la catena causale è: org-roam -> citar -> org-cite

As Tecosaur points out [[https://blog.tecosaur.com/tmio/2021-07-31-citations.html][in this blog post]],

#+begin_quote
To get started with Org Cite, we must have some form of bibliography. This can either be a BibTeX file or a CSL-JSON file.

First we need to let Org know about this bibliography file (which must have a =.bib=, =.bibtex=, or =.json= extension), which we do either via the "#+bibliography" keyword, or the variable =org-cite-global-bibliography=.
#+end_quote

A minimal example in org-mode could be:

#+begin_src org
,#+bibliography: references.bib
[cite:@lehn_toward_2002]
,#+print_bibliography:
#+end_src

Setting the global bibliography imply tangling this line to =config.el=:

#+begin_src emacs-lisp :tangle config.el
(setq org-cite-global-bibliography '("~/Dropbox/references.bib"))
#+end_src

We could set this variable right away, but we don't, because [[https://github.com/doomemacs/doomemacs/tree/master/modules/tools/biblio#path-configuration][Doom already dispose a way]] that keep in mind the completion system too:

#+begin_quote
You must set the path variable for either doom-package:citar (if using doom-module::completion vertico) or doom-package:bibtex-completion (if using ivy or helm); this module will in turn set the var:org-cite-global-bibliography variable to the same value.
#+end_quote

# Installing =citar= would be as easy as running a simple =package!= macro, but it's not needed, as the package is already within the =biblio= module.
Here comes the second reason for choosing =vertico=: it is not only more minimalistic and lightweight, but it is also the system directly supported by =citar=.
To install Citar, we should tangle this line to =package.el=:

#+begin_src emacs-lisp
(package! citar)
#+end_src

# Please, rewrite this text for further clarity:
Again, we don't. Doom had already took care of it in the =biblio= module.
Since everything is in the right place, let's assing our path.

#+begin_src emacs-lisp :tangle config.el
;; (setq! bibtex-completion-bibliography '("/path/to/references.bib"))
(setq! citar-bibliography '("~/Dropbox/references.bib"))
#+end_src

#+begin_quote
You may also set the respective note and library path variables as well for enhanced functionality:
#+end_quote

#+begin_src emacs-lisp :tangle config.el
;; (setq! citar-library-paths '("/path/to/library/files/")
;;       citar-notes-paths '("/path/to/your/notes/"))
#+end_src

#+begin_quote
Once you have a bibliography source, you can start referencing to your heart’s content! The basic citation syntax is as follows:
#+end_quote

#+DOWNLOADED: screenshot @ 2023-04-26 18:00:32
#+Caption: Basic citation syntax with org-cite
[[file:Citations/2023-04-26_18-00-32_screenshot.png]]

# Al completo
#+DOWNLOADED: screenshot @ 2023-04-26 18:06:17
#+Caption: Full citation syntax
[[file:Citations/2023-04-26_18-06-17_screenshot.png]]

Use CSL format files.
Export processor to use format files written in Citation Style Language (=.csl=). This isn't latex-only, so I should be able to use it with Libre Office and HTML too, if needed.

#+begin_src emacs-lisp :tangle packages.el
(package! citeproc)
#+end_src

Why Citar?
# [[https://kristofferbalintona.me/posts/202206141852/#citar][Kristoffer Balintona]]:

#+begin_quote
Using org-cite is really simple. But many users will find the interface… too bare.
Citar is, roughly, the foremost attempt to provide a pleasing frontend to org-cite. It adds the citar citation-insert processor.
#+end_quote

Other sources:
- [[https://kristofferbalintona.me/posts/202206141852/#citar][Citation in org-mode: Org-cite and Citar]]
- [[https://jethrokuan.github.io/org-roam-guide/][How I takes notes with Org-Roam]]
- [[https://blog.tecosaur.com/tmio/2021-07-31-citations.html][Introducing citations!]]
- [[https://github.com/doomemacs/doomemacs/tree/master/modules/tools/biblio][:tools biblio (Doom Emacs docs)]]
- [[https://www.reddit.com/r/emacs/comments/cxu0qg/comment/eyqe4vq/][Reddit thread]]

** Wikipedia
Get Wikipedia data directly on org-mode.
# Richiama informazioni da Wikipedia direttamente su org.

#+begin_src emacs-lisp :tangle packages.el
(package! wikinforg)
#+end_src

*** COMMENT Italiano :it:
Spesso mi servono i contenuti in italiano.
L'ideale sarebbe scegliere per ogni query.

#+begin_src emacs-lisp :tangle config.el
;; (custom-set-variables '(wikinforg-wikipedia-edition-code "it"))
#+end_src

Purtroppo, i risultati che ottengo da questa versione sono poco accurati.
Per il momento la disabiliterò.

* LaTeX
** Emacs changed how I LaTeX
# Translate this text from Italian into English:
# Emacs ha rivoluzionato il modo in cui scrivo LaTeX.
# Questo non solo a causa del fatto che Emacs ha modificato il mio approccio al testo in generale, ma anche perché Org-mode è un layer d'astrazione perfetto per LaTeX e ne estende di molto la versatilità.
# Non solo la sintassi si semplifica drammaticamente (come già accade nei casi di Markdown -> LaTeX), ma il codice LaTeX può anche essere generato per mezzo di org-babel a partire da dati espressi in forma più intuitiva. Insomma, Org-mode agisce come un layer d'astrazione ulteriore che può facilitare molto la scrittura a chi dovesse già avere dimestichezza con il mezzo (forse non al neofita: è importante imparare prima a conoscere LaTeX, altrimenti gli errori che ci saranno (e ci saranno) saranno di difficile attribuzione: bisogna ricercare la causa nel layer d'astrazione, che è org-mode/babel, o nel codice LaTeX generato? Solo l'esperienza aiuta ad orientarsi in questi casi.

Emacs has revolutionized the way I write LaTeX. Not only because Emacs has changed my approach to text in general, but also because Org-mode greatly extends its versatility:
- The syntax is dramatically simplified (much like in "Markdown to LaTeX" approaches),
- LaTeX code can also be generated through org-babel (from data expressed in a more intuitive form).

# Elencare esempi di questo approccio. Tipo CV.

# Using Emacs and Org-mode has greatly improved my LaTeX writing experience. Org-mode provides an abstraction layer for LaTeX that simplifies its syntax and increases its versatility. It enables the generation of LaTeX code from data expressed in a more intuitive form using org-babel. Overall, Emacs and Org-mode revolutionized the way I write LaTeX."
# Emacs has transformed not only my approach to text, but also has revolutionized the way I write LaTeX.

# Melville style
# Methinks, Emacs hath wrought a revolution in the art of mine own LaTeX penmanship. Verily, it hath transformed not only mine approach to text, but also endowed me with Org-mode - a wondrous abstraction layer for LaTeX, thus vastly amplifying its versatility. The ways of syntax be simplified yea manifolds (much like from yon Markdown to LaTeX), and through org-babel, LaTeX code may be fashioned from data in a more facile and intuitive form."
# Hemingway style
# Emacs changed how I LaTeX. Org-mode made LaTeX better by abstracting it. Syntax simpler, and maths easy to generate from intuitive data.

In short, Org-mode acts as a further abstraction layer that can greatly facilitate writing for those who are already familiar with the medium (yet not for beginners: indeed, one must first learn LaTeX, otherwise the errors that will occur (and there will be) will be hardly attributable: should one look for the cause in org-mode/babel, or in the generated LaTeX code? A little bit of experience helps to navigate these cases.

# Melville style:
# "Verily, Org-mode doth serve as a cloak of abstraction, which doth abundantly aid those already acquainted with the medium (yet not for novices: verily, one must first learn LaTeX, lest the errors that do arise (and arise they shall) prove unattributable: shall the cause be sought in the abstraction, that is org-mode/babel, or in the wrought LaTeX code? Of a truth, experience alone doth guide in these cases)."

** A tidy directory, a tidy mind
# We add other extensions to logfiles, to let Emacs delete them after exporting the actual tex file; therefore, we have tidier directories.
# Zhuangzi:
# Once, a wise Emacs user said: "Let us not cling to the trifles of life, such as the accumulation of logfiles. Instead, let us enhance our workflow by enabling Emacs to perform the noble task of tidying up after itself. In this way, we cultivate a tidy mind and a tidy directory, and move closer to the true path of productive efficiency."

We extend logfiles with other extensions, so Emacs can scrub them post export.
In this way, we cultivate a tidy directory, and move closer to a tidy mind.

#+begin_src emacs-lisp :tangle config.el
(setq org-latex-logfiles-extensions (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl" "xmpi" "run.xml" "bcf")))
#+end_src

* Spellchecking :it:
Uso Jinx.

#+begin_src emacs-lisp :tangle packages.el
(package! jinx)
#+end_src

Richiede:
- =libenchant= (su AUR è =enchant=).

Using vertico, abilitiamo una sua estensione, cioè =vertico-multiform=.
fatto ciò, aggiungiamo un elemento alla lista di categorie di multiform.

#+begin_src emacs-lisp :tangle config.el
;; Enable vertico-multiform
(vertico-multiform-mode)

(add-to-list 'vertico-multiform-categories
             '(jinx grid (vertico-grid-annotate . 20)))
(vertico-multiform-mode 1)
#+end_src

Supporto in lingua inglese con Aspell o Hunspell.
Io utilizzo i dizionari Hunspell.

Ad esempio, su Debian derivate si possono installare così.

# Vedi qua
# https://200ok.ch/posts/2020-08-22_setting_up_spell_checking_with_multiple_dictionaries.html
#+begin_src bash
apt install hunspell \
	    hunspell-de-de \
	    hunspell-en-gb \
	    hunspell-en-us \
	    hunspell-de-ch-frami
#+end_src

Personalmente, li ho cercati ed installati da AUR.
Lanciando =jinx-languages= in Emacs, è possibile verificare siano stati installati davvero.

Ci servono più lingue.
Io scrivo spesso inglese ed italiano mischiandoli tra loro.
Quindi vorrei supporto per entrambe contemporaneamente.
Servirebbe un dizionario combinato o più sorgenti contemporaneamente (scelta più pulita).

Se ne parla qui:
https://emacs.stackexchange.com/questions/21378/spell-check-with-multiple-dictionaries

Vedi anche:
https://200ok.ch/posts/2020-08-22_setting_up_spell_checking_with_multiple_dictionaries.html

* Completion :it:
** TODO Sorting and filtering

Voglio usare Prescient.

#+begin_quote
prescient.el: simple but effective sorting and filtering for Emacs.
#+end_quote

Installiamo:

#+begin_src emacs-lisp :tangle packages.el
(package! prescient)
#+end_src

Siccome uso vertico, allora:

#+begin_src emacs-lisp :tangle packages.el
(package! vertico-prescient)
#+end_src

Queste sarebbero le altre possibilità, secondo [[https://github.com/radian-software/prescient.el][documentazione]]:

#+begin_src emacs-lisp
(straight-use-package 'corfu-prescient)
(straight-use-package 'company-prescient)
(straight-use-package 'ivy-prescient)
(straight-use-package 'selectrum-prescient)
#+end_src

* Org D2 diagrams
I want to generate D2 diagrams without leaving my org-mode files.
Apparently, that's why [[https://github.com/dmacvicar/ob-d2][ob-d2]] (an org-babel exporter for D2) was written.
It's not on MELPA yet, so I'll get it from its GitHub repo.

#+begin_src emacs-lisp :tangle packages.el
(package! ob-d2 :recipe (:host github :repo "dmacvicar/ob-d2"))
#+end_src

Add d2 to =org-babel-load-languages=.

#+begin_src emacs-lisp :tangle config.el
(org-babel-do-load-languages
    'org-babel-load-languages
    '((d2 . t)))
#+end_src

Add d2 to exec-path.

#+begin_src emacs-lisp :tangle config.el
(add-to-list 'exec-path "~/.local/bin/")
#+end_src

Test D2 (d2 requires a ":file" header argument):

#+begin_src d2 :file test.png
# Actors
hans: Hans Niemann

defendants: {
  mc: Magnus Carlsen
  playmagnus: Play Magnus Group
  chesscom: Chess.com
  naka: Hikaru Nakamura

  mc -> playmagnus: Owns majority
  playmagnus <-> chesscom: Merger talks
  chesscom -> naka: Sponsoring
}

# Accusations
hans -> defendants: 'sueing for $100M'

# Offense
defendants.naka -> hans: Accused of cheating on his stream
defendants.mc -> hans: Lost then withdrew with accusations
defendants.chesscom -> hans: 72 page report of cheating
#+end_src

* Org JSON export
JSON is a lightweight data interchange format used to transmit and store data.
It is often used in web applications to exchange data between the application and the server.

This package enables the export of org files to JSON, making them easy to parse for machines.

#+begin_src emacs-lisp :tangle packages.el
(package! ox-json)
#+end_src

Require it at startup:

#+begin_src emacs-lisp :tangle config.el
(require 'ox-json)
#+end_src

* Org-roam
:PROPERTIES:
:EXPORT_HUGO_SECTION: software/org-roam
:EXPORT_FILE_NAME: index.en.md
:EXPORT_DATE: [2023-04-08 sab]
:EXPORT_ZOLA_COVER_IMAGE: graph-gicrisf-11.png
:END:

# Ogni volta che devo prendere un appunto, una domanda torna a pungolarmi: dove scriverlo?
Every time I have to take a note, a question keeps nagging me: where should I write it?
Org-roam frees information from hierarchies, hence freed me from the burden of confusion.

{{{more}}}
# Update with title
{{{backlink(org-roam)}}}

Until this very moment, my method involved ammassing notes in "notebooks", which meant I had a folder with a lot of org-mode files named with some kind of topic. For example, I had a file for Python, a file for Linux, a file for Organic chemistry and so on. But my files kept growing and the themes kept mixing: what if I want to take a note about writing organic molecule in emacs? Should I store it in the "Emacs notebook" or the "Organic chemistry notebook"? Every single time a similar but quite different dilemma. That's why I searched for a less structured approach and thus, the Zettelkasten method occurred to me.

** What is a Zettelkasten?
A zettelkasten is a personal knowledge management system popularized by Niklas Luhman, a German sociologist. As the (German) term suggests, it consists of a collection of small notes; the small notes are often called "slips" and each of them must contain a single idea or topic.
The point is that these slips can be organized and linked together in various ways and traditionally they required a lot of paper and storage tools to aid in the retrieval of the informations. Today, the zettelkasten can be totally virtual. Of course, this doesn't exclude the usefulness of the analogical one, we have just more options.

The zettelkasten method comes with a series of rules and peculiarities but, to be honest, I don't think I will follow the zettelkasten method zealously; as I said, I was searching for a less hierarchized tool and that's what I found in Org-roam.

** What is Org-roam?
# When it comes to note-taking software, Notion and Obsidian comes to mind. Web-based software is used more and more, but I don't want to leave Org-mode, plain text and open-source software.
# Logseq looks like a wonderful project, since it supports org-mode files and is open-source; I'm interested in Logseq too, but we will talk about it later.
# Software web-based sono sempre più usati, ma io non voglio abbandonare org-mode. Logseq fornisce supporto per org-mode, ma si tratta di una versione di org-mode con modifiche che la rendono dipendente dalla piattaforma stessa. Non possono essere lette (così come sono) su Emacs. A quel punto, tanto vale usare una versione modificata di Markdown, la portabilità è uguale, i limiti sono gli stessi.
# Since I like to stay in Emacs as much as I can, I want to talk about Org-roam first.

# What is org-roam?
Org-roam is an Emacs package that leverages Org-mode for note-taking and knowledge management based on the principles of Roam Research.
It allows you to create and link notes in plain text files and provides navigation and search features for exploring your notes graph.

# Are the following lines written in correct english? Verify the grammar and the tone.
Org-roam employ a SQLite3 database to deliver the content faster when you search for it, but the *real* archive it's the plain text one.
This means you can easily synchronize your content across devices and the archive remains extremely resilient, not dependent on any service, not even Emacs itself.
Org-roam seems to provide the tool I was searching for.
# The sentence is grammatically correct and has a positive tone.

# Are the following line written in correct english?
Moreover, Org-roam is a solid piece of software with a large community and has reached a second version, that is the one I will refer to from now on.
# Yes, the given line is written in correct English.

# Essendo il mio primo approccio, sicuramente sto trascurando fattori che emergeranno in seguito, ma mi sembrano buone basi.
# Ho anche letto delle [[https://karl-voit.at/2020/06/14/Zettelkasten-concerns/][critiche]], ad esempio relative al fatto che risulterebbe scomodo mantenere contemporaneamente differenti domini.

** Installation
The installation is very easy:
- You must have SQLite3 on your system (and you probably already have);
- On Doom Emacs you have to uncomment the =org= module, while adding =roam2= like this: =(org +roam2)=.

** Basic configuration
Now, the configuration.
# A questo punto, bisogna passare alla configurazione.
# In pratica, grazie a Doom abbiamo già una preconfigurazione, ma dobbiamo comunicare almeno la directory in cui vogliamo tenere i file.

In the following directory, I will keep the plain-text files. I want to be clear about this point: if you have the file, you can always retrieve the full content you wrote.

#+begin_src emacs-lisp :tangle config.el
(setq org-roam-directory "~/Dropbox/roam")
#+end_src

# Ora sorge un altro problema. Come eseguo il backup della mia org roam directory?
# Potrei usare Dropbox, ma odio l'idea che possa darmi problemi per carenza di spazio.
# L'evidente alternativa sarebbe usare git.
I sync everything in my Dropbox by storing the files, not the database.

** The first note
I use Evil on Doom Emacs, hence the keybinding I use for creating a note is =SPC+n+r+i= (action -> notes -> roam -> insert).
# Non resta che seguire i comandi di Doom Emacs per creare la prima nota: =SPC+n+r+i= per inserire una nota.

The command will leave a link to the note on the underlying buffer. This behaviour can be useful in a lot of situations, for example you can easily chain more notes together.
# Mentre stiamo scrivendo la nota, con la stessa combinazione si può inserire un link ad una nota.
# Questa risulterà connessa alla prima nel buffer.

** Backlinks
# Explain why backlinks are one of the most relevant strenghts in Org-roam
# Raw output
Backlinks in Org-roam are one of the most relevant strengths because they allow for easy navigation and organization of information. Just by adding a link to another note, all notes that link to it are automatically generated, providing a web of related information. This helps in discovering and exploring relationships between pieces of information, making it easier to create connections and draw meaningful insights. Additionally, backlinks allow for a more flexible and non-linear way of organizing information, as notes can be linked in multiple locations without duplicating them.

** Web UI
This UI helps exploring the nodes and the backlinks.
# I need a UI to explore the nodes:

#+begin_src emacs-lisp :tangle packages.el
(package! org-roam-ui)
#+end_src

# In questo modo posso vedere i nodi in maniera molto piacevole all'interno del browser.

** Citations
# No "references" perché questo è riservato al paragrafo finale con le citazioni del post, se presente
# Una delle cose per cui potrei usare lo zettelkasten è memorizzare tweet o toots. Questo sarebbe facilitato dalle API, ma per quanto riguarda Twitter è difficile capire se valga la pena spendere del tempo, visto che hanno già annunciato cambiamenti. I thread sono difficili da immagazzinare tweet per tweet, quindi non se ne parla.

It's better to not mix your own written production with others' written productions. In other words, don't fill your notes with citations.
# Altro punto importante: *non è bene mescolare la propria produzione scritta con le citazioni altrui*.

How to reference others' work, then? I looked at [[https://jethrokuan.github.io/org-roam-guide/][the approach of Jehtro Kuan (org-roam author)]].
# Per organizzare il roam, meglio seguire un approccio simile a [[https://jethrokuan.github.io/org-roam-guide/][quello descritto in questo post da Jehtro Kuan]] (autore di org-roam).

{{{begforstars}}}

# Al momento commentato perché non ci sono citazioni da elencare
# #+print_bibliography:

{{{prismcss}}}
{{{prismjs}}}

** Experimental
*** Citations as nodes

#+begin_src emacs-lisp :tangle packages.el
(package! citar-org-roam)
#+end_src

I take the suggestions from the [[https://github.com/emacs-citar/citar-org-roam][README]].

#+begin_src emacs-lisp
(use-package citar-org-roam
  :after (citar org-roam)
  :config (citar-org-roam-mode))

(setq citar-org-roam-note-title-template "${title} - ${author}")

(setq org-roam-capture-templates
      '(("d" "default" plain
         "%?"
         :target
         (file+head
          "%<%Y%m%d%H%M%S>-${slug}.org"
          "#+title: ${note-title}\n")
         :unnarrowed t)
        ("n" "literature note" plain
         "%?"
         :target
         (file+head
          "%(expand-file-name (or citar-org-roam-subdir \"\") org-roam-directory)/${citar-citekey}.org"
          "#+title: ${citar-citekey} (${citar-date}). ${note-title}.\n#+created: %U\n#+last_modified: %U\n\n")
         :unnarrowed t)))

(setq citar-org-roam-capture-template-key "n")
#+end_src

Legacy:

#+begin_src emacs-lisp
;; slightly modified version of this:
;; https://jethrokuan.github.io/org-roam-guide/
(defun gicrisf/org-roam-node-from-cite (keys-entries)
    (interactive (list (citar-select-refs)))
    (let ((title (citar--format-entry-no-widths (cdr keys-entries)
                                                "${author editor} :: ${title}")))
      (org-roam-capture- :templates
                         '(("r" "reference" plain "%?" :if-new
                            (file+head "reference/${citekey}.org"
                                       ":PROPERTIES:
:ROAM_REFS: [cite:@${citekey}]
:END:
,#+title: ${title}\n")
                            :immediate-finish t
                            :unnarrowed t))
                         :info (list :citekey (car keys-entries))
                         :node (org-roam-node-create :title title)
                         :props '(:finalize find-file))))
#+end_src
** COMMENT Resources
- [[https://blog.jethro.dev/posts/introducing_org_roam/][Introducing Org Roam]]
- [[https://jethrokuan.github.io/org-roam-guide/][How I take notes with Org-roam]]
- [[https://org-roam.discourse.group/t/is-there-a-solution-for-images-organization-in-org-roam/925][Images organization]]
- [[https://takeonrules.com/2020/12/08/revisiting-hydra-menu-for-org-roam-lookup-in-emacs/][Revisiting Hydra Menu for Org Roam Lookup in Emacs]]

* Org Transclusion
Manual: https://nobiot.github.io/org-transclusion/

#+begin_src emacs-lisp :tangle packages.el
(package! org-transclusion)
#+end_src

#+begin_src emacs-lisp :tangle config.el
(use-package! org-transclusion
              :after org
              :init
              (map!
               :map global-map "<f12>" #'org-transclusion-add
               :leader
               :prefix "n"
               :desc "Org Transclusion Mode" "t" #'org-transclusion-mode))

;; hack per risolvere il fatto che transclusion non trova i file, per qualche motivo
;; https://github.com/nobiot/org-transclusion/issues/62
(org-id-update-id-locations (directory-files org-roam-directory t "org$"))
#+end_src

* Emacs Feed Configuration
:PROPERTIES:
:EXPORT_HUGO_SECTION: software/emacs-config-feed
:EXPORT_FILE_NAME: index.en.md
:EXPORT_DATE: [2023-03-13 lun 21:48]
:EXPORT_HUGO_LASTMOD: [2023-03-15]
:END:

People continuously write a viscous, non-local, scattered gargantuan text just by existing on the internet.
Managing how to access this text can be tricky since we need to filter out the noise and focus on the content we need or are curious about. When it comes to text, Emacs is usually well-equipped to improve our life. As we will discover soon in this post, this case makes no exception.

{{{more}}}

To be more accurate, we should distinguish between two parts of the collective text: one we actively compose that is accessible to any of us, and another one, which is generated to track our actions on private platforms and is structured not to be read by humans, but parsed by machines. In this post, we will focus on the first part, the public and human-oriented text, but this (apparently) simple topic has implications that cross over and touch the production of the other text, which the sociologist Shoshana Zuboff usually refers to as /shadow text/.
Indeed, by consciously choosing how to screen our readings, we partially subtract ourselves from the aggressive tracking operated by companies like Google or Meta. To be notified when new content is published online, we can leverage a technology that solved this problem even before the advent of those companies on the scene: RSS feeds. With Elfeed, Emacs is able to read both the RSS and the newer Atom feeds.

#+begin_quote
Elfeed is an extensible web feed reader for Emacs, supporting both Atom and RSS.
#+end_quote

On Doom Emacs, Elfeed is already integrated as a module and can be enabled in the =init.el= file.

By default, Elfeed only needs you to set a simple list to work: as shown below, the list is called =elfeed-feeds= and can easily be typed in the =config.el= file.
# Di default, basta aggiungere gli URL dei feed desiderati in questa lista per avere già Elfeed operativo.

# Not tangling it anymore
# :tangle config.el
#+begin_src emacs-lisp
(setq elfeed-feeds (quote
                    (("https://www.zwitterio.it/rss.xml" stem)
                     ("https://materiaimpersonale.wordpress.com/feed/" lit))))
#+end_src

I don't follow this method anymore, because I find more comfortable to keep my feeds in a specific org file.
# Io non uso più questo metodo perché trovo più comodo tenere i miei feed in un file org-mode separato.

To make elfeed prettier, we can add =elfeed-goodies= to our packages in =packages.el=.
# Per abbellire elfeed, aggiungiamo =elfeed-goodies=.
Particularly, this package adds a cool powerline and changes the layout (panels are split vertically, not horizontally).
# In particolar modo, cambia il layout (apre in un altro pannello verticale, anziché orizzontale) e si guadagna una powerline.

#+begin_src emacs-lisp :tangle packages.el
(package! elfeed-goodies)
#+end_src

This package helps you to customize some aspects if you want to.
For example, here we edit the size of the popup entry pane.

#+begin_src emacs-lisp :tangle config.el
(require 'elfeed-goodies)
(elfeed-goodies/setup)
(setq elfeed-goodies/entry-pane-size 0.5)
#+end_src

Refer to [[https://github.com/jeetelongname/elfeed-goodies][the package README]] for more.

# Ora voglio assicurarmi che elfeed appaia sulla dashboard (vedi sezione dedicata alla dashboard).
You can make a lot of different uses of elfeed: if you just follow some blogs, you probably have no problem with it. Let's say you follow 20, 30, or 50 blogs and you love them all. You want to see every news, but every blog post once a week if it is active. In this case, elfeed is already perfect. It shows you everything in chronological order. But what if you follow sources that publish a lot of content day by day?
For example, let's say you follow the RSS feeds of government agencies or scientific publishers. In that case, you better filter the posts to list the most important things first. A lot of social media platforms do that: they let you see the posts of accounts you interact with the most before any other, then they proceed with others. It doesn't matter that the others are more recent: the point is to maximize the probability you see the stuff you're more interested in, to make you interact and stay on the platform as long as you can. Here we're facing a similar problem: since we all know you're never going to see every single post in your feed, it's fundamental to establish priorities. We will not implement a machine learning model to learn our preference like social media /algorithms/ do, but there's a package that keeps things simple, and let you score the posts by keywords: not surprisingly, it's called =elfeed-score=.

You can see it in action in [[https://emacsconf.org/2021/talks/research/][this interesting Emacs talk, published in 2021]].
Like said by Ahmed Khaled, the author,

#+begin_quote
Elfeed-score enables me to assign a numerical score [...] This numerical score is very simple. It's just based on matching things.
#+end_quote

We're now fully convinced that we need =elfeed-score=, so we proceed to install it:

#+begin_src emacs-lisp :tangle packages.el
(package! elfeed-score)
#+end_src

Arxiv or ChemRxiv feeds are listed in the org file like any other feed.
Now, we have to configure =elfeed-score=. From [[https://www.unwoundstack.com/doc/elfeed-score/curr#The-Score-File][the docs]]:

#+begin_quote
The rules for scoring are written down in the score file, a plain-text file containing a single Lisp form. The location of the score file is defined in =elfeed-score-serde-score-file=.
#+end_quote

By default, the configuration is written in a file named =elfeed.score= in the =.emacs.d= directory:

#+begin_src emacs-lisp :tangle ~/.config/doom/elfeed.score
;;; Elfeed score file                                     -*- lisp -*-
(("title")
 ("content")
 ("title-or-content"
  (:text "spectroscopy" :title-value 50 :content-value 10 :type s)
  (:text "Alzheimer" :title-value 50 :content-value 10 :type s)
  (:text "small molecule" :title-value 50 :content-value 10 :type s)
  (:text "Peptide" :title-value 50 :content-value 10 :type s)
  (:text "Molecular Dynamics" :title-value 50 :content-value 10 :type s)
  (:text "infrared" :title-value 100 :content-value 10 :type s))
 ("tag")
 ("authors")
 ("feed")
 (mark -600)
 ("adjust-tags"))
#+end_src

Moving towards using regular expressions in the =text= field can minimize matching against unintended targets.
To see regex in action, I suggest looking at [[https://cundy.me/post/elfeed/][this Chris Cundy's blog post]], of which I'm about to give a glimpse below.

#+begin_src emacs-lisp
;; An example of using regexes
;; Source: https://cundy.me/post/elfeed/
;; ...
("title-or-content"
  ("uncertainty" 50 10 s 1597198724.419375)
  (".*[- ]ODE[- s].*" 100 20 R 1596818708.18127))
;; ...
#+end_src

#+begin_quote
So the field (".*[- ]ODE[- s].*" 100 20 R 1596818708.18127) is a case-sensitive (specified by the R) regexp matching against any of " ODEs”, " ODE “, " ODE-", etc. If a match occurs in the title it adds 100 to the score of the entry. If a match occurs in the content field (for us, this is the abstract of the paper) it will add 20 to the score of the entry. The scale is arbitrary, but I’m aiming for a score of 0 for papers I may want to read, 100 for papers I will probably want to read, 200 for papers I will very likely want to read, and 300 for papers I will certainly want to read. I generally put the content matches with a lower score since they may occur multiply times and e.g. I don’t want to miss an interesting paper just because one of the applications was an area I’m not interested in.
#+end_quote

The scoring is not only based on text or content: unsurprisingly, the =authors= field lets you push up specific authors' work; by adding elements to the =tag= field you can prioritize posts with particular tags and through the =feed= field it's possible to put some feed content before others.

Finally, we activate =elfeed-score= by adding these lines in the init file (=config.el=):

#+begin_src emacs-lisp :tangle config.el
(require 'elfeed-score)
(elfeed-score-enable)
(define-key elfeed-search-mode-map "=" elfeed-score-map)
#+end_src

{{{prismcss}}}
{{{prismjs}}}

* Typescript
# Innanzitutto, bisogna avere aggiunto alcuni moduli: =web= e =javascript=, in particolare.
First of all, you need to have added some modules: =web= and =javascript=, in particular.
This is done by uncommenting them in =.doom.d/init.el= (remove =;;= as shown in the "Doom modules" paragraph above).

# Per farlo, basta togliere =;;= nel file di configurazione =.doom.d/init.el=, come fatto nel paragrafo sopra.
At this point, someone may want to work with files in the =.tsx= format.
Support for this use case may be coming soon, but for the moment we can use a simple line of Lisp in the configuration file.

# A questo punto, è possibile che uno voglia lavorare con file in formato =.tsx=. Il supporto per questo caso d'uso potrebbe arrivare presto, ma per il momento ci viene in soccorso una semplice riga di lisp nel file di configurazione, [[https://github.com/hlissner/doom-emacs/issues/2252#issuecomment-569059839][secondo il suggerimento di hlissner]]:

#+begin_src emacs-lisp :tangle config.el
;; Support for React
(add-to-list 'auto-mode-alist '("\\.tsx\\'" . typescript-mode))
#+end_src

# In caso foste in cerca di una soluzione per Vanilla Emacs o Spacemacs, quest'altra soluzione potrebbe fare al caso vostro:
If you are looking for a solution for Vanilla Emacs or Spacemacs, this other one may be suitable for you:

#+begin_src emacs-lisp
(use-package typescript-mode
  :mode (rx ".ts" string-end)
  :init
  (define-derived-mode typescript-tsx-mode typescript-mode "typescript-tsx")
  (add-to-list 'auto-mode-alist (cons (rx ".tsx" string-end) #'typescript-tsx-mode)))
#+end_src

# Praticamente dichiariamo una modalità derivata dalla =typescript-mode= e le assegniamo anche i file con estensione =.tsx=. Per maggiori dettagli, [[https://github.com/emacs-typescript/typescript.el/issues/4#issuecomment-849355222][fate riferimento a questo issue su Github]].
Basically, we make a new mode derived from =typescript-mode= and we assign it the =.tsx= extension too.
For more details, refer to [[https://github.com/emacs-typescript/typescript.el/issues/4#issuecomment-849355222][this Github issue]].

* Vala
Vala is an object-oriented programming language designed to provide modern programming features while maintaining compatibility with the C programming language. It compiles to efficient, easily-readable C code, which can interface with existing C libraries. It is primarily used for developing desktop applications for the GNOME desktop environment on Linux.
# (From my Roam)

Since it is syntactically similar to C#, the Emacs support for Vala is largely inherited from the C# mode.

#+begin_src emacs-lisp :tangle packages.el
(package! vala-mode)
#+end_src

* Python
Python is simple and readable, with a clean syntax that supports multiple programming paradigms. It's popular among web developers, data analysts, and scientists, thanks to its vast standard library and third-party contributors.

** Virtualenv
Virtualenv allows you to make separate Python environments for different projects with their own dependencies and packages. It's fundamental to avoid problems with package dependencies and version conflicts between different projects. It also makes it easier to manage packages and share code with other developers.

Pyvenv leverages virtualenv to create isolated Python environments from within Emacs. By invoking pyvenv within Emacs, you can activate a virtual environment and use its Python executable, as well as the libraries installed inside it.

#+begin_src emacs-lisp :tangle packages.el
(package! pyvenv)
#+end_src

** COMMENT Python lsp
Avendo problemi con lsp di python. Tentando di installare mspyls,

#+begin_quote
LSP :: Server mspyls install process failed with the following error message: Bad url: /.
#+end_quote

Qua ulteriori informazioni, ma non molto utili:
https://github.com/doomemacs/doomemacs/issues/2600

* Rust
# Semantica analysis for Rust in Emacs
# TODO scrivere un articolo riscrivendo il tutto
# E facendo funzionare quanto scritto sotto
** Semantic analysis
# [[https://robert.kra.hn/posts/rust-emacs-setup/][Come scrive Robert Krahn]],
[[https://robert.kra.hn/posts/rust-emacs-setup/][As Robert Krahn writes]],

#+begin_quote
Racer used to be the best option for getting IDE features (code navigation etc) into Emacs. It is a non-LSP solution which is still faster than RLS and rust-analyzer. However, the number of features especially around code completion are not up to par with rust-analyzer anymore.
#+end_quote

# Il consiglio, quindi, è quello di passare direttamente al paragrafo successivo, ma chi proprio desiderasse Racer (che era piacevole), lascio qui tutte le istruzioni del caso.
The advice, therefore, is to skip directly to the next paragraph, but for those who really want Racer (which was enjoyable), I leave here all the necessary instructions.

*** Racer
# Dopo avere abilitato =rust= in =init.el=, Doom Emacs lamentava l'introvabilità del binario di Racer:
After enabling =rust= in =init.el=, Doom Emacs complained about the inability to find the Racer binary.

#+begin_quote
Please set ‘racer-rust-src-path’ or ‘RUST_SRC_PATH’
#+end_quote

# Il primo problema derivava non tanto dal fatto che fosse scorretta la variabile =racer-rust-src-path=, ma che proprio non esistesse alcuna =src-path= perché bisognava prima che installarla:
The first issue derived not so much from the fact that the variable =racer-rust-src-path= was incorrect, but that there was no =src-path= at all because it had to be installed first.

#+begin_src bash
rustup component add rust-src
#+end_src

# Ma si ottiene un altro errore:
But you get another error:

#+begin_quote
eldoc error: (user-error /.../.cargo/bin/racer exited with 127. ‘M-x racer-debug’ for more info)
#+end_quote

# Questo perché manca racer, che [[https://lib.rs/crates/racer][va installato a parte]].
# Siccome Racer risiede nella nightly toolchain, installiamo prima quella:
This is because Racer is missing, which [[https://lib.rs/crates/racer][must be installed separately]].
Since Racer is included in the nightly toolchain, we install it first:

#+begin_src bash
rustup toolchain install nightly
#+end_src

# Poi aggiungiamo gli strumenti da sviluppatore =rustc-dev=:
Then we add the developer tools =rustc-dev=.

#+begin_src bash
rustup component add rustc-dev --toolchain=nightly
#+end_src

# Assicuriamoci che anche Cargo sia già installato e lanciamo:
Let's make sure that Cargo is also already installed and let's launch it.

#+begin_src bash
cargo +nightly install racer
#+end_src

# [[https://github.com/racer-rust/racer/issues/1181][La compilazione potrebbe fallire]], ma bisogna tenere a mente è che Racer non è al momento mantenuto:
[[https://github.com/racer-rust/racer/issues/1181][The compilation might fail]], but it should be kept in mind that Racer is not currently maintained.

#+begin_quote
Racer is not actively developed now. Please consider using newer software such as rust-analyzer.
#+end_quote

# Per il momento Racer funziona egregiamente, ma successivamente potrei voler dare un occhio anche a [[https://rust-analyzer.github.io/][rust-analyzer]].

# Emacs potrebbe non individuare subito Racer, nonostante l'installazione.
Emacs might not detect Racer right away, even if it is installed.

#+name: racer-path
#+begin_src emacs-lisp
"~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library"
#+end_src

# Quick fix per consentire ad Emacs di trovare i binari di Racer:
Quick fix to allow Emacs to find Racer binaries.

#+begin_src emacs-lisp :tangle config.el :noweb no-export
;; (setq racer-rust-src-path <<racer-path>>)
#+end_src

# Io non uso più Racer, ma eldoc si ostina a farlo, dando sempre questo fastidiosissimo errore:
I no longer use Racer, but eldoc insists on using it, always giving this very annoying error:

#+begin_quote
eldoc error: (user-error /home/cromo/.cargo/bin/racer exited with 127. ‘M-x racer-debug’ for more info)
#+end_quote

[[https://github.com/doomemacs/doomemacs/issues/2271#issuecomment-569775470][As @hlissner said]]:

#+begin_quote
The =:lang rust= module doesn't use =rust-mode=, it uses [[https://github.com/brotzeit/rustic][rustic-mode]], a fork of =rust-mode=.

When =+lsp= is not enabled, the module uses =racer= to provide code completion, type info in the minibuffer (eldoc) and other features, but the racer package depends on =rust-mode=, so it must be installed (but doom still doesn't use it directly).
#+end_quote

# Bisogna perciò evitare che Racer sia avviato tutte le volte che LSP non è attivo. Come ricordato da [[https://www.reddit.com/r/DoomEmacs/comments/slb92w/comment/hvrfkax/?utm_source=share&utm_medium=web2x&context=3][@subderisorious]], per fortuna Doom ci consente di disabilitare un pacchetto della configurazione di default semplicemente richiamando la macro =package!= in =packages.el=.
Therefore, it is necessary to avoid starting Racer every time LSP is not active. As recalled by [[https://www.reddit.com/r/DoomEmacs/comments/slb92w/comment/hvrfkax/?utm_source=share&utm_medium=web2x&context=3][@subderisorious]], fortunately Doom allows us to disable a package from the default configuration simply by calling the macro =package!= in =packages.el=.

(Note: I corrected the formatting of the original text for clarity.)

#+begin_src emacs-lisp :tangle packages.el
(package! racer :disable t)
#+end_src

*** Rust analyzer
# Circa sei mesi dopo, è tempo di dare un'occhiata a rust-analyzer.
It's time to look at =rust-analyzer=.

Quoting the [[https://rust-analyzer.github.io/manual.html#installation][manual]]:

#+begin_quote
At its core, rust-analyzer is a library for semantic analysis of Rust code as it changes over time. This manual focuses on a specific usage of the library — running it as part of a server that implements the Language Server Protocol (LSP). The LSP allows various code editors, like VS Code, Emacs or Vim, to implement semantic features like completion or goto definition by talking to an external language server process.
#+end_quote

# Anche questa volta, possiamo usare =rustup=:
This time too, we can use =rustup=.

#+begin_src bash
rustup component add rust-src
#+end_src

# Io sto su Arch, quindi installo con pacman:
I use Arch (btw), so I will show the command with pacman:

#+begin_src bash
sudo pacman -S rust-analyzer
#+end_src

# È il caso di specificare quale server intendiamo utilizzare, altrimenti Rustic potrebbe fraintendere o optare per Racer:
It is necessary to specify which server we intend to use, otherwise Rustic could misunderstand or opt for Racer.

#+begin_src emacs-lisp :tangle config.el
(setq rustic-lsp-server 'rust-analyzer)
#+end_src

# Questo dovrebbe essere sufficiente, ma per essere proprio sicuri:
This should be sufficient, but to be absolutely sure:

#+begin_src emacs-lisp :tangle config.el
(after! lsp-rust
  (setq lsp-rust-server 'rust-analyzer))
#+end_src

# Lanciamo =lsp= in un buffer con Rust ed assistiamo al compiersi della magia.
We launch =lsp= in a buffer with Rust and witness the magic happen.
* Cobol
#+begin_src emacs-lisp :tangle packages.el
(package! cobol-mode)
#+end_src

* Common Lisp
Setting up a local version of the Common Lisp HyperSpec provides instant and offline access to Lisp documentation. This is especially useful when using Emacs with the SLIME package for Common Lisp development.

** Setting up Local Common Lisp HyperSpec in Emacs with SLIME
From my fediverse, a chatgpt generated by =@qhBidG3d@emacs.ch= (Marcus) using his code:
https://emacs.ch/@qhBidG3d/111042058648335328

*** Prerequisites
- Emacs installed
- SLIME package installed
- Common Lisp implementation (like SBCL) installed

I use SLY, but whatever.

*** Downloading the HyperSpec
Download the Common Lisp HyperSpec from [[http://www.lispworks.com/downloads/documentation.html][LispWorks Documentation]]. Unzip it into a folder of your choice. Remember this folder location.

*** Emacs configuration
We'll use Emacs-Lisp functions to find and set up the local HyperSpec automatically.

#+BEGIN_SRC emacs-lisp :tangle packages.el
(defvar mk/hyperspec-dir-locations
  '("~/Downloads/HyperSpec-7-0/HyperSpec/")
  "List of possible locations where the local HyperSpec could reside.")

(defun mk/find-dir (x)
  "Recursively search for a valid directory from a list X of directories.
Returns the first valid directory, or nil if none found."
  (cond ((null x) nil)
        ((file-directory-p (car x)) (car x))
        (t (mk/find-dir (cdr x)))))

(defun mk/hyperspec-dir ()
  "Finds and returns the URI of the local HyperSpec directory.
Uses `mk/hyperspec-dir-locations' to find the directory."
  (let ((dir-prefix
         (if (eq system-type 'windows-nt)
             "file:///"
           "file://"))
        (dir (mk/find-dir mk/hyperspec-dir-locations)))
    (if dir
        (concat dir-prefix
                (expand-file-name dir))
      nil)))
#+END_SRC

Setto così la directory:

#+begin_src emacs-lisp :tangle packages.el
(setq common-lisp-hyperspec-root (let ((dir-found? (mk/hyperspec-dir)))
                                   (if dir-found?
                                       dir-found?
                                     "http://www.lispworks.com/reference/HyperSpec/")))
#+end_src

Non sono sicuro che io debba passargli il sito come alternativa.
Mi sa che l'impostazione è solo per le cartelle in locale.
Sennò dovrei passare nil.
Si potrebbe riassumere con:

#+begin_src emacs-lisp
(setq common-lisp-hyperspec-root (mk/hyperspec-dir))
#+end_src

In caso di fallimento, la funzione dovrebbe restituire =NIL=.

**** COMMENT SLIME
Poi c'è questa parte, ma la tolgo perché io non ho SLIME, ma SLY (ed è già installato via doom).

#+begin_src emacs-lisp
(use-package slime
  :defer t
  :custom
  (slime-autodoc-use-multiline-p 1)
  :bind ("C-c C-q" . slime-close-all-parens-in-sexp)
  :config
  (slime-setup '(slime-autodoc
                 slime-tramp
                 slime-fancy
                 slime-asdf
                 slime-indentation
                 slime-editing-commands
                 slime-sbcl-exts))
  (progn
    (setq common-lisp-hyperspec-symbol-table
          (concat common-lisp-hyperspec-root "Data/Map_Sym.txt"))
    (setq common-lisp-hyperspec-issuex-table
          (concat common-lisp-hyperspec-root "Data/Map_IssX.txt"))))
#+end_src

*** Verification
  - Restart Emacs or evaluate the above configuration.
  - Open a SLIME REPL by executing =M-x slime=.
  - Press =C-c C-d h= to invoke HyperSpec lookup. You should now access the local copy.

*** Conclusion
  That's it! You have successfully configured a local Common Lisp HyperSpec with Emacs and SLIME. Now you can enjoy seamless and offline access to Lisp documentation.

* Ebooks
** Send ebooks to Kindle with Emacs
:PROPERTIES:
:EXPORT_HUGO_SECTION: software/send-ebooks-to-kindle
:EXPORT_FILE_NAME: index.en.md
:EXPORT_DATE: [2023-04-06 gio]
:END:

Since I often stockpile text to read in the form of ebooks, I usually prefer to read them on my Kindle.

{{{more}}}

Essentially, there are two practical ways for loading new ebooks on a Kindle:
- USB
- Mail

# Per inviare qualcosa sul tuo Kindle personale, prima di tutto bisogna abilitare l'indirizzo email da cui gli ebook saranno inviati, altrimenti Amazon rifiuterà il file (per ragioni di sicurezza). Dopo avere abilitato la mail sul portale di Amazon, disporremo non solo di una mail a cui inviare l'epub, ma anche di un username ed una password, in modo non dissimile da quello che solitamente vale per il bearer token nelle API di servizi simili.
In order to send something to your personal Kindle, the first step is to enable the email address from which the eBooks will be sent, otherwise Amazon will reject the file (for security reasons). After having enabled the email on the Amazon portal, we will have not only an email to send the epub to but also a username and password, similar to what usually applies to the bearer token in the APIs of similar services.

# Per agevolare l'invio di email contenenti ebook al Kindle, Calibre ha disposto delle funzioni specifiche. Io, però, sono troppo pigro pure per aprire la GUI di Calibre e, generalmente, se un ebook è in giro per il mio computer, significa che prima o poi vorrò leggerlo. Quindi ho pensato di automatizzare il lavoro, affidandolo ad un singolo comando.
To facilitate the sending of emails containing ebooks to Kindle, Calibre provides specific functions. However, I am too lazy to even open the Calibre GUI and, usually, if an ebook is on my computer, it means that sooner or later I will want to read it. Therefore, I have decided to automate the task by entrusting it to a single function.

*** The strategy
# Questa è la strategia:
My strategy is pretty simple:
- The code iterates over all files that have the =.epub= extension in a specific directory.
- Every =.epub= file can be converted to the =.mobi= format and sent as an email attachment to the Kindle email address using =calibre-smtp= (Calibre must be installed).
- The mail is sent with autentication using a given mail server port and login credentials.
- Once the mail is sent, the =.mobi= files can be moved in another directory or deleted. The same applies to the =.epub= files.

We have the blueprint, it's time to proceed in order, imagining a function.

# TODO diagram

# Translate this text in english, using a technical style and precision:
# Prima di tutto, scegliamo la directory in cui vanno cercati i file che vogliamo inviare sul Kindle.
Firstly, we set the =epub-path=, the directory in which to search for the files we want to send to the Kindle.

#+begin_src emacs-lisp :tangle config.el
(setq tokindle-epub-path "~")
#+end_src

What will we do with the original files after conversion?
We set directories for archiviation:

#+begin_src emacs-lisp :tangle config.el
(setq tokindle-epub-path-sent "~/Scaricati/epub_sent")
#+end_src

# Check if the following line is expressed in a correct english:
If we convert the epub into mobi, we may want to manage the mobi files too in a similar fashion:

#+begin_src emacs-lisp :tangle config.el
(setq tokindle-mobi-path-sent "~/Scaricati/mobi_sent")
#+end_src

Finally, we can write the function, here called =send-to-kindle=.

#+begin_src emacs-lisp
(defun send-to-kindle ()
  (dolist (file (directory-files tokindle-epub-path 'full (rx ".epub" eos) 'nosort))
    (let ((filename (file-name-sans-extension file))
          (ext (file-name-extension file)))

      ;; Manage conversion between formats
      ;; ...

      ;; Send the mobi files with calibre
      ;; ...

      ;; now you can move the ebook files into the proper directories
      ;; ...
      ))
  ;; congratulations *clap clap*, the files were sent to your kindle
  (message "All available ebooks are being sent to your Kindle."))
#+end_src

- We start iterating over every epub file in =tokindle-epub-path=.
- We give =full= and =nosort= optional arguments as non-nils to =directory-files= because we like the absolute path of files and we don't need any sorting; making the function sort the files would be a waste of time.
- Expanding the path is not necessary, because =directory-files= is able to do it by itself.

*** Epub to mobi
It would be convenient having a function to convert any epub file to mobi format.
Calibre has [[https://manual.calibre-ebook.com/generated/en/ebook-convert.html][a CLI command for solving this problem]]:

#+begin_src
ebook-convert input_file output_file [options]
#+end_src

Formatting the command in emacs lisp, we got:

#+begin_src emacs-lisp :tangle config.el
(defun ebook-convert-epub-to-mobi (file)
  (format "ebook-convert \"%s\" \"%s\".mobi" file file))
#+end_src

We could run it as a subprocess with =shell-command= and having good results, but the problem is that Emacs hangs on the process and stays blocked until it's finished. Making the function async would be better. Instead of using =shell-command= directly, we can implement it with Emacs' async libraries or directly using a function provided by =magit=.

# TODO riscrivi dicendo se c'è magit fai una cosa, sennò fai l'altra
Thanks to =magit-shell-command= we can monitor the process in a dedicated buffer.

We can run the async function if Magit is installed, or run the previous one if Magit is missing. This way, Magit is not a hard requirement for this code to run correctly.
# You can use the =if= statement and the =featurep= function to achieve this.

# #+name: convert-in-mobi
#+begin_src emacs-lisp
;; if the mobi counterpart already exists, go on
(if (not (file-exists-p (concat file ".mobi")))
    ;; else convert the epub file in mobi
    (if (featurep 'magit)
        ;; function to run if Magit is installed
        (magit-shell-command (ebook-convert-epub-to-mobi file))
      ;; function to run if Magit is missing
      (shell-command (ebook-convert-epub-to-mobi file))))
#+end_src

Before converting the epub file into mobi, we better check if the conversion wasn't already done.

# How to check if a file already exists in emacs lisp?
We can check if a file already exists in Emacs Lisp using the =file-exists-p= function.
# It takes a file path as its argument and returns =t= if the file exists, or =nil= if it does not. Here's an example:

Since the mobi conversion its done in the same directory of epub files, some files with the =mobi= extension could be left there from a previous failed process. This shouldn' happen and never happened to me, but being safe doesn't costs.

# Per mandare via mail usiamo un altro comando reso disponibile da Calibre. Potremmo anche non usarlo, ma visto che già dipendiamo da Calibre per la funzione precedente (ed è quindi necessariamente installato), perché non usarlo?

*** Sending emails
To send via email, we use [[https://manual.calibre-ebook.com/it/generated/it/calibre-smtp.html][another command made available by Calibre]].
We could also choose another tool, but since we are already dependent on Calibre for the previous function (and it is therefore necessarily installed), why not use it?

#+begin_src
calibre-smtp [options] [from to text]
#+end_src

Again, we realize a function that maps it to a string that we can launch as subprocess.
To build the SMTP command, we need to set up SMTP and credentials; the simpler way to store this informations is as environment variables. So, retrieving them is a matter of few =getenv= commands.

#+begin_src emacs-lisp :tangle config.el
(defun tokindle-calibre-smtp-cmd (filename)
  (concat "calibre-smtp "
          ;; attachment
          (format "-a \"%s.mobi\" " filename)
          ;; subject
          (format "-s \"%s\" " (file-name-nondirectory filename))
          (format "-r \"%s\" " (getenv "TOKINDLE_SMTP"))
          (format "--port \"%s\" " (getenv "TOKINDLE_PORT"))
          (format "-u \"%s\" " (getenv "TOKINDLE_USERNAME"))
          (format "-p \"%s\" " (getenv "TOKINDLE_PASSWORD"))
          (format "\"%s\" " (getenv "TOKINDLE_MY_MAIL"))
          (format "\"%s\" " (getenv "TOKINDLE_KINDLE_MAIL"))
          ;; text
          "\"\""))
#+end_src

We run this command for each mobi file available.
The question is: asynchronously or synchronously?

*** The sync approach
The problem with async is that we have to make sure that the commands in the second block (email) doesn't start before the commands in the first block (conversion). Since the "rate determining step" is the first one (the conversion is the slower block), we have to be particularly careful. At this point, it's clear that we cannot write another block like the previous one; not like the following:

# #+name: send-ebook
#+begin_src emacs-lisp
(if (file-exists-p (concat file ".mobi"))
    (if (featurep 'magit)
        (magit-shell-command (tokindle-calibre-smtp-cmd file))
      (shell-command (tokindle-calibre-smtp-cmd file))))
#+end_src

This is a traditional problem in asynchronous programming: the asynchronous flow and the synchronous one must be considered separately or the code gets messy.
The simple way to do this is just having two different functions.
That's why we will rewrite the blocks before to work synchronously, then we will write the fully asynchronous functions in a second moment.

To convert in mobi synchronously:

#+name: convert-in-mobi-sync
#+begin_src emacs-lisp
(if (not (file-exists-p (concat file ".mobi")))
    (progn
      (message (concat "Converting " file "to mobi..."))
      (shell-command (ebook-convert-epub-to-mobi file))
      (message "Converted.")))
#+end_src

To send ebooks synchronously:

#+name: send-ebook-sync
#+begin_src emacs-lisp
(if (file-exists-p (concat file ".mobi"))
    (progn
      (message (concat "Sending " (concat file ".mobi") "to your Kindle..."))
      (shell-command (tokindle-calibre-smtp-cmd file))
      (message "File sent.")))
#+end_src

# Non ci resta che scrivere una funzione che faccia piazza pulita dei file non più necessari. Poi potremo considerare la funzione conclusa.
We just have to write a function that cleans up unnecessary files. Then we can consider this function finished.

# How can I move files from a directory to another with Emacs lisp?
In emacs lisp, you can move files from one directory to another using =rename-file= function.
# Replace the file paths with your own and run this code in Emacs Lisp.

#+name: clean-up
#+begin_src emacs-lisp
;; archive the epub
(rename-file file (file-name-concat tokindle-epub-path-sent
                                    (file-name-nondirectory file)))
;; archive the mobi
(rename-file (concat file ".mobi")
             (file-name-concat tokindle-mobi-path-sent
                               (file-name-nondirectory (concat file ".mobi"))))
#+end_src

# Prima di passare ad altro, prendiamo un momento per osservare la funzione nella sua interezza.
Before moving on to something else, let's take a moment to observe the function as a whole.

#+begin_src emacs-lisp :tangle config.el :noweb yes
(defun send-to-kindle ()
  (dolist (file (directory-files tokindle-epub-path 'full (rx ".epub" eos) 'nosort))
    (let ((filename (file-name-sans-extension file))
          (ext (file-name-extension file)))

      ;; Manage conversion between formats
      <<convert-in-mobi-sync>>

      ;; Send the mobi files with calibre
      <<send-ebook-sync>>

      ;; now you can move the ebook files into the proper directories
      <<clean-up>>
      ))
  ;; congratulations *clap clap*, the files were sent to your kindle
  (message "All available ebooks are being sent to your Kindle."))

;; try me!
;; (send-to-kindle)
#+end_src

The sync function takes time but works fine.
It could be especially useful to be called from the shell:

#+begin_src sh
emacsclient -e '(send-to-kindle)'
#+end_src

# How can I write two async blocks in emacs lisp, being careful that the first one is being finished before the second block runs?
# You can use the =async-start= function with the =:sync= option set to =t= for the first block. This will cause it to run synchronously and not return until it has finished. Then use =async-start= again for the second block without setting =:sync= to ensure it runs asynchronously.

*** COMMENT Async excursus
Now, let's go back to the asynchronous version.

How can I write asynchronously functions in emacs lisp?

You can write asynchronous functions in Emacs Lisp by using the built-in =async-start= and =async-start-process= functions to execute a function in the background.
You can also use the =deferred= library or the newer =async= library which provides more advanced functionality for writing asynchronous code.

Write and explain a simple example of using deferred library in emacs lisp

Here is a simple example of using the deferred library in Emacs Lisp:

#+begin_src emacs-lisp
(require 'deferred)

(defvar my-deferred-result nil)

(deferred:$
  (deferred:next (lambda () 42))
  (deferred:nextc it (lambda (x) (* x 2)))
  (deferred:nextc it (lambda (x) (concat "The answer is " (number-to-string x))))
  (deferred:nextc it (lambda (result) (setq my-deferred-result result))))

;; Wait for the deferred operation to complete and print the result
(deferred:wait my-deferred-result
  (lambda (result) (message result)))
#+end_src

In this example, we use =deferred:$= to chain a sequence of deferred operations together. We start with a lambda function that returns the value 42. We then use =deferred:nextc= to chain two additional lambda functions that double the result and convert it to a string. Finally, we use =deferred:nextc= again to set the value of the =my-deferred-result= variable to the final result.

To wait for the deferred operation to complete, we use =deferred:await= to specify the deferred result (=my-deferred-result=) and the function to call when the result is available (a lambda function that prints the result using =message=).

#+begin_src emacs-lisp
(require 'deferred)

(deferred:$
  (deferred:process "ls" "-l")
  (deferred:nextc it
    (lambda (process)
      (message "Process output: %s" (buffer-string (process-buffer process))))))

#+end_src

In this example, we use the =deferred:process= function to run a process that lists the contents of the current directory (using the =ls -l= command). This function returns a deferred object that represents the result of the process.

We then use the =deferred:nextc= function to schedule a callback that will be run when the deferred object is resolved. The callback takes the process object as its argument, and logs the output of the process to the minibuffer using the =message= function.

By using =deferred=, we are able to run the process asynchronously, without blocking the Emacs UI, and handle the result of the process in a separate callback function. =deferred= also provides other useful functions for dealing with asynchronous operations, such as =deferred:map= and =deferred:wait=.

Show how can I store a lambda to a variable in emacs lisp

You can store a lambda to a variable in Emacs Lisp using the =defvar= or =setq= functions. Here's an example:

#+begin_src emacs-lisp
(defvar my-lambda (lambda (x) (+ x 1)))
(funcall my-lambda 3)
#+end_src

In this example, we define a variable =my-lambda= and set it equal to a lambda function that takes one argument =x= and returns the value of =x + 1=.

Now, I want to define a list of lambdas.

You can use dolist in Emacs Lisp to iterate over a list and execute a body of code for each element in the list. Here is an example:

#+begin_src emacs-lisp
(dolist (elem list) (print elem))
#+end_src

In this example, =list= is the list you want to iterate over and =elem= is the variable that represents each element in the list.

Going to the serious stuff, let's store a list of lambdas.

#+begin_src emacs-lisp
(defvar my-lambdas '((lambda (x) (+ x 1))
                     (lambda (x) (- x 1))))

(dolist (my-lambda my-lambdas) (message (number-to-string (funcall my-lambda 3))))
#+end_src

My point is those lambda can be procedurally generated from another list, then passed to be runned in parallel.

Riscriviamo popolando una lista. Non si sa mai, meglio testare.

#+begin_src emacs-lisp
(defvar my-lambdas '())

(defvar list-example '((lambda (x) (+ x 1))
                     (lambda (x) (- x 1))))

(dolist (example list-example) (add-to-list 'my-lambdas example))
(add-to-list 'my-lambdas (lambda (x) (- x 3)))

(print my-lambdas)
#+end_src

Ok, si può fare.

#+RESULTS:

*** The async approach
# Translate this italian text in english:
# Non avrei bisogno nemmeno di scrivere questa funzione, visto che ora Amazon ha annunciato che supporterà epub come formato, ma lo faccio giusto perché mi va di vedere come funzionano le chiamate asincrone su Emacs.

# Potrei scriverla così, ma c'è un problema. Nel momento in cui lancio =add-to-list=, quel che viene dopo non viene valutato, solo trascritto. A me questo piace, ma voglio selettivamente valutare la variabile =file=.

I could write it like this, but there's a problem. At the moment I launch 'add-to-list', what comes after is not evaluated, but only transcribed. I like it this way, but I want to selectively evaluate the 'file' variable.

#+begin_src emacs-lisp :results output
(defun send-to-kindle-async ()
  ;; collect the lambdas you want to execute in parallel
  (setq conversion-lambdas '())
  (dolist (file (directory-files tokindle-epub-path 'full (rx ".epub" eos) 'nosort))
    (add-to-list 'conversion-lambdas (lambda ()
                                       (if (not (file-exists-p (concat file ".mobi")))
                                           (progn
                                             (message (concat "Converting " file "to mobi..."))
                                             (shell-command (ebook-convert-epub-to-mobi file))
                                             (message "Converted."))))))

  (print conversion-lambdas))

;; try me!
(send-to-kindle-async)
#+end_src

#+RESULTS:
:
: ((lambda nil (if (not (file-exists-p (concat file ".mobi"))) (progn (message (concat "Converting " `file "to mobi...")) (shell-command (ebook-convert-epub-to-mobi file)) (message "Converted.")))))

Qua subentra il [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Backquote.html][backquoting]].

Ne parlano anche su [[https://emacs.stackexchange.com/questions/7481/how-to-evaluate-the-variables-before-adding-them-to-a-list][Stack Exchange]].
"How to evaluate the variables before adding them to list?"

Il problema credo sia che =add-to-list= a sua volta fa uso di questi metodi, quindi backquoting dentro =add-to-list= non funziona.
Mi conviene usare un metodo più semplice per aggiungere elementi alla lista.

=cons= è il metodo più semplice.
Non controlla niente, non fa verifiche strane.

#+begin_quote
=cons= is often used to add a single element to the front of a list. This is called /consing/ the element onto the list. 5 For example:
#+end_quote

#+begin_src emacs-lisp :results output
(defun send-to-kindle-async ()
  ;; collect the lambdas you want to execute in parallel
  (setq conversion-lambdas '())
  (dolist (file (directory-files tokindle-epub-path 'full (rx ".epub" eos) 'nosort))
    (setq conversion-lambdas (cons `(lambda ()
                                      (if (not (file-exists-p (concat ,file ".mobi")))
                                          (progn
                                            (message (concat "Converting " ,file "to mobi..."))
                                            (shell-command-to-string (ebook-convert-epub-to-mobi ,file))
                                            (message "Converted.")))) conversion-lambdas)))

  (print conversion-lambdas))

;; try me!
(send-to-kindle-async)

;; (deferred:$
;;    (deferred:parallel
;;      ()
;;      ))

(mapc #'funcall conversion-lambdas)

;; espanso
;; perché non arriva mai al secondo?
(mapc #'funcall '((lambda nil (if (not (file-exists-p (concat "/home/cromo/Scaricati/epub/wsw.epub" ".mobi"))) (progn (message (concat "Converting " "/home/cromo/Scaricati/epub/wsw.epub" "to mobi...")) (shell-command (ebook-convert-epub-to-mobi "/home/cromo/Scaricati/epub/wsw.epub")) (message "Converted.")))) (lambda nil (if (not (file-exists-p (concat "/home/cromo/Scaricati/epub/boh.epub" ".mobi"))) (progn (message (concat "Converting " "/home/cromo/Scaricati/epub/boh.epub" "to mobi...")) (shell-command (ebook-convert-epub-to-mobi "/home/cromo/Scaricati/epub/boh.epub")) (message "Converted."))))))

;; non va bene
;; si aspetta stringp
;; trova 0
;; dopo aver fatto la prima generazione, quindi il primo comando
;; prima di scrivere converted
;; ma non è converted
;; è questo il problema
;; viene restituito da ebook-convert-epub-to-mobi
;; 0 (#o0, #x0, ?\C-@)
;; perché?
;; la funzione si aspetta che sia restituito qualcosa
;; una stringa
;; invece non restituisce nulla
;; dobbiamo usare il comando "shell-command-to-string"

;; (funcall (car conversion-lambdas))
#+end_src

*** Conclusions

[...]

{{{prismcss}}}
{{{prismjs}}}

** Notes and Highlights
# TODO Prova il pacchetto e lascia una stella su GitHub
# How Kindle manage notes?
# Tell people of Ramiel
# This code could be hacked and mix-matched for exporting to multiple formats

# How ebooks have changed our way to take notes?
Ebook readers allow to easily highlight, annotate, and search through digital text. This has made note-taking more efficient and convenient.
I own a Kindle since 2014 and I always wondered how I optimize the process of importing my notes in the text I write.

*** Kindle clippings
Kindles store the notes in a really simple text file called =My Clippings.txt=.

The Kindle clippings file is formatted in the following way:
- Each clipping is separated by a line with 10 "equal" signs.
- The first line of each clipping contains the title of the book and the author's name.
- The second line contains lots of metadata, separated by pipes ("|"):
  - the type of the clipping (e.g., "Highlight," "Note");
  - the position in the book where the clipping was made (it can be an integer or a range of two integers);
  - the date and time when the clipping was made.
- The third line is a blank line.
- The fifth line contains the actual text of the clipping.

Here is an example of a clipping from a Kindle clippings file:

#+begin_src txt
The Art of War (Sun Tzu)
- Highlight Loc. 444-45 | Added on Sunday, November 7, 2021, 11:10 PM

Victorious warriors win first and then go to war, while defeated warriors go to war first and then seek to win.
#+end_src

*** COMMENT Il problema della lingua
Come si può facilmente osservare, il testo si legge facilmente.
Un umano legge facilmente, ma una macchina ha bisogno di storare i dati in maniera più strutturata prima di riportarli in altri formati.
La sintassi è scandita da parole più che da semplici segni.
Questo aumenta la leggibilità, ma può essere un problema perché in altre lingue cambiano le keys.
Vedi un esempio in italiano:

#+begin_src txt
Chthulucene (Donna Haraway)
- La tua evidenziazione a pagina 6 | posizione 88-88 | Aggiunto in data giovedì 2 luglio 2020 00:20:41

Ci ritroviamo a vivere sulla Terra in tempi confusi, torbidi e inquieti.
#+end_src

Notiamo un po' di differenze:
- Al posto di avere "Highlight" abbiamo "La tua evidenziazione"
- È riportata anche la pagina, prima della posizione
- La data è espressa in un differente formato. Non più "Month day, year, time" ma "day month year time"

È evidente che questo complica le cose in fase di parsing.
Dobbiamo fare in modo che il parser disponga di tutte le possibili varianti linguistiche per poter trasferire i dati in un formato leggibile.

Se va bene solo l'inglese e solo il formato org-mode, questo pacchetto fa al caso vostro.
Prima ancora di conoscere l'esistenza di questo pacchetto e di cominciare ad usare org-mode così intensamente, io mi ero posto lo stesso problema ed avevo pensato ad una soluzione che fosse in grado di esportare in HTML, JSON e Markdown, anche supportando l'italiano e altre lingue.
Avevo chiamato questo pacchetto ramiel e l'avevo scritto in rust per avere un codice quanto mai solido e facile da mantenere.
Al fine di richiamare questo codice rust in Emacs, ho pensato di scrivere delle bindings in python.
Le bindings in python sono utili perché emacs si interfaccia molto più facilmente a python che non ad un binario rust attraverso CLI.
Inoltre, questo consente l'integrazione del pacchetto anche in altro codice python.
Per esempio, potrebbe tornare utile richiamarlo in plugin per Pelican o Django o, ancora, in Flask.
Ma tutto ciò verrà più avanti.
Intanto importante focalizzarsi sul parsing.
# Link al parser in rust e lo chiamo ramiel-clippings or something.
# La repo è ancora privata

# Fare schema D2:
My Clippings.txt -> JSON (grazie a ramiel, in rust) -> altri formati

Nel frattempo sulla scena sono apparsi molti altri gestori di note.
Github ha categoria =kindle-clippings=

Abbiamo supporto per Notion, per Obsidian, per Logseq.
Ognuno di questi presenta vantaggi, svantaggi.
Notion è in python, supporto per alcune lingue, pacchetto abbastanza semplice.
Obsidian è in typescript, già più complesso, consente di importare direttamente dal cloud di Amazon.

C'è un'altra persona che ha realizzato un parser in rust. Sta sviluppando tutto un progetto intorno che sfrutta Serde. In pratica ha avuto la mia stessa idea.
Vedo caratteri cinesi, quindi persona a cui interessa del supporto multilingua.
Il supporto è solo per cinese e inglese al momento, ma c'è un enum che può essere facilmente esteso.

Continuo a credere che Rust sia la scelta giusta.
Si fa il parsing dei dati in JSON. Poi da JSON si esporta nella maniera preferita:
- Org mode
- HTML
- Markdown
- Altri formati tipo Notion, Obsidian e quant'altro

Per org mode sarebbe interessante il supporto per la sintassi di org-cite.
Questo faciliterebbe molto. Ho visto che il pacchetto di obsidian fa la ricerca del libro online. ISBN.
Questo consentirebbe molto facilmente la generazione di references.

*** Export clippings in org-mode
#+begin_quote
This package converts Kindle’s “My Clippings.txt” to a format usable in Org mode. The result will be sorted by book title and displayed in a temporary buffer named ”*clippings*”.
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! clip2org :recipe (:host github :repo "Kungsgeten/clip2org"))
#+end_src

After setting =clip2org-clippings-file=...

#+begin_src emacs-lisp
(require 'clip2org)
(setq clip2org-clippings-file "/path/to/My Clippings.txt")
#+end_src

... launch =M-x clip2org=.

** COMMENT Reading
Org noter per prendere appunti: https://github.com/weirdNox/org-noter
Per leggere qui gli epub: https://github.com/wasamasa/nov.el
Questo è lo stato dell'arte per i PDF: https://github.com/vedang/pdf-tools

* Zola Org Exporter :it:

{{{italian}}}

L'exporter per Zola è un pacchetto che sto mantenendo io, quindi capita spesso che io debba testare delle modifiche in locale. =package!= gestisce i download, quindi in teoria non dovrebbe essere impiegato per la gestione di file in locale, ma [[https://github.com/doomemacs/doomemacs/issues/3842#issuecomment-681039894][Henrik Lissner consiglia di usare comunque la macro perché è stata adattata anche a questo genere di situazioni]].

Aggiunge:

#+begin_quote
Note: with =:no-byte-compile t=, you don't have to run doom sync every time you make a change to the package.
#+end_quote

Così:

#+begin_src emacs-lisp
(package! ox-hugo :recipe (:local-repo "lisp/ox-zola"))
#+end_src

Peccato che a me dia "runtime error":

#+begin_quote
Details: ((:private . packages) "/home/cromo/.doom.d/packages.el" (wrong-type-argument listp (doom-package-error "ox-hugo" . "Keyword argument :no-byte-compile not one of (:local-repo :files :flavor :build :pre-build :post-build :includes :type :repo :host :branch :protocol :remote :nonrecursive :fork :depth :source :inherit)")))
#+end_quote

Non ho ben capito perché (che sia [[https://github.com/doomemacs/doomemacs/issues/4142#issuecomment-715532212][questo il problema]]? non mi pare...), ma ho risolto più brutalmente. Innanzitutto installo il codice dalla mia repo.

#+begin_src emacs-lisp :tangle packages.el
;; (package! ox-hugo :recipe (:host github :repo "gicrisf/ox-zola"))
(package! ox-hugo)
#+end_src

In secondo luogo, faccio le modifiche in locale e lancio =emacs-lisp-byte-compile-and-load= tutte le volte che modifico qualcosa. Finché non riavvio Emacs, è possibile testare quanto si vuole. Forse un po' più scomodo, ma è un approccio che fa il suo sporco lavoro.

# Frontmatter
Esportare da org a Hugo/Zola Markdown richiede la scrittura di un =:PROPERTIES:= frontmatter.
Ma io sono pigro e non mi va di riscrivere ogni volta lo scaffold del frontmatter, quindi ecco una funzione ausiliaria.

#+begin_src emacs-lisp :tangle config.el
;; Generate ORG/Zola frontmatter
;; TODO Section management
;; Update the directory
;; MAYBE Add hook to org file IF hugo_base_dir or hugo_section is present at top
(defun org-zola-frontmatter (slug)
  "Insert org-mode properties under a paragraph to setup ox-hugo/zola exports"
  (interactive "sEnter slug: ")
  (insert ":PROPERTIES:\n"
          (concat ":EXPORT_HUGO_SECTION: 2022/" slug "\n")
          ":EXPORT_FILE_NAME: index\n"
          ":END:\n"))
#+end_src

Sempre al fine di automatizzare la produzione dei metadati, meglio automatizzare l'inserimento del timestamp con questa funzione org-mode:

#+begin_src emacs-lisp :tangle config.el
;; add "CLOSED" when an item is set with DONE state
(setq org-log-done 'time)
#+end_src

Inserita la possibilità di dichiarare shortcode dedicati, facciamolo.

#+begin_src emacs-lisp :tangle config.el
(setq ox-zola-special-block-type-properties '(("twitter" . (:trim-pre t :trim-post t))
                                              ("figure" . (:trim-pre t :trim-post t))))
#+end_src

** COMMENT Resources
# - [[https://scripter.co/sidenotes-using-ox-hugo/#opulate%20the%20Org%20source%20of%20this%20blog%20with%20Hugo-specific%20shortcodes%20when%20I%20am%20using%20ox-hugo%20%F0%9F%98%84.%20So%20instead,%20we%20just%20use%20the%20plain-old][Sidenote using ox-hugo]]

* Twitter
# Tradotto dall'articolo introduttivo
It is a very common practice on several websites, but especially on blogs and news outlets, to quote tweets in the body of text. To do so, the official Twitter widget is usually employed: a copy and paste seems to be enough to accomplish the magic. Unfortunately, this magic comes at a high price.

What really happens is that the web page hosting the tweet is infiltrated by an iframe for each tweet, resulting in:
- A considerable increase in the weight of the web page (thus more latency for slow connections and more energy consumption on the network);
- The introduction of several trackers that monitor the reader's activity.

Assuming we are writing in Markdown for a static site generator, how can we address the problem?

There are plenty of ways, but this small package provide a simple one.

#+begin_src emacs-lisp :tangle packages.el
(package! eltweet :recipe (:host github :repo "gicrisf/eltweet"))
#+end_src

# If you speak italian, [[https://zwitterio.it/coding/2022/quote-tweets-properly-with-emacs-lisp/][at this link I narrate how it was written, commenting the code line-by-line from a perspective of a lisp beginner]];
# (Installed from the repo because is not on MELPA yet)

* Mastodon
Firstly, let's install =mastodon.el=:
# Prima di tutto, installiamo mastodon.el:

# now *Untangled*
# :tangle packages.el
#+begin_src emacs-lisp
(package! mastodon)
#+end_src

You can find me on "@gicrisf@fosstodon.org", so:
# Io sono su "@gicrisf@fosstodon.org", quindi:

#+begin_src emacs-lisp :tangle config.el
(setq mastodon-instance-url "https://fosstodon.org"
      mastodon-active-user "gicrisf")
#+end_src

I'm amazed by how easy it was to read the TL on Emacs, thanks to this package.
The weak spot is the layout, but fortunately [[https://gist.github.com/rougier/e92d446600dfe350b9ec9d7cabaca211][Nicolas Rougier is working on it]].

# Sono meravigliato da quanto facile sia stato arrivare alla propria TL da Emacs grazie a mastodon.el, ma il layout di default è veramente insostenibile.
# Fortunatamente, Nicolas Rougier ha già [[https://gist.github.com/rougier/e92d446600dfe350b9ec9d7cabaca211][pubblicato un gist in cui rielabora il layout per adeguarlo alla propria configurazione]].
# Io non uso NANO, quindi servirà qualche ritocco sicuramente.

#+begin_src emacs-lisp :tangle packages.el
;; (package! mastodon :recipe (:host codeberg :repo "rougier/mastodon.el"))
#+end_src

* COMMENT Matrix
Could be useful in the future.

#+begin_src emacs-lisp :tangle packages.el
(package! ement :recipe (:host github :repo "alphapapa/ement.el"))
#+end_src

* COMMENT Music
Not used anymore. I was just playing.

# Di questa parte ho già parlato in [[https://www.zwitterio.it/coding/2022/how-do-i-play-my-lofi-music/][un post dedicato]].
The following lines are widely commented in a [[https://www.zwitterio.it/en/software/how-do-i-play-my-lofi-music/][specific post]].

# La musica è bella
# Su youtube c'è un sacco di musica
# Voglio ascoltare musica presente su youtube
# Non voglio decidere sempre quale pezzo o album nello specifico
# Vorrei andare per "vibes" o generi o playlist
# Ho quindi bisogno di una funzione che faccia da shuffle

#+begin_src emacs-lisp :tangle config.el
;; Play Lo-Fi
;; Implementation of the knuth shuffle
;; TODO Start amberol or other music player
(defun nshuffle (sequence)
  (cl-loop for i from (length sequence) downto 2
        do (cl-rotatef (elt sequence (random i))
                    (elt sequence (1- i))))
  sequence)

(setq lofi-links '("https://www.youtube.com/watch?v=8nXqcugV2Y4" ;; 3:30 music session
                   "https://www.youtube.com/watch?v=FVue6P2VoTc"
                   "https://www.youtube.com/watch?v=NrJiXKwUjPI" ;; Music to put you in a better mood
                   "https://www.youtube.com/watch?v=kgx4WGK0oNU"
                   "https://www.youtube.com/watch?v=5qap5aO4i9A"))

(setq vaporwave-links '("https://www.youtube.com/watch?v=nVCs83gSYD0"  ;; architecture in tokyo - Summer Paradise
                        ))

(defun play-lofi ()
  "Play random lofi music on your browser"
  (interactive)
  (shell-command (concat "python -mwebbrowser " (car (nshuffle lofi-links)))))

(defun play-vaporwave ()
  "Play random lofi music on your browser"
  (interactive)
  (shell-command (concat "python -mwebbrowser " (car (nshuffle vaporwave-links)))))
#+end_src

** COMMENT La svolta :it:
Anziché aprire youtube esternamente, ho pensato che sarebbe bene scaricare il file ed ascoltarlo in locale quando lo si desidera. Si potrebbe pure sincronizzare tutto con syncthing così da averle sul telefono. Funzionerebbe bene fino a un certo punto.

Allora ho pensato che si potrebbe usare youtube-dl.

Allora ho notato che youtube-dl è scritto in Python ed espone robe come libreria.

Allora ho pensato che si potrebbe usare attraverso il server, tipo in llamacs.
https://github.com/ytdl-org/youtube-dl#embedding-youtube-dl

Ho anche pensato che a me spesso piacciono le playlist, ma sono come unico video.
Allora si potrebbero usare i capitoli del video per suddividere la lunga traccia audio nei brani che la compongono.

Questo codice in dart mi conferma che si può fare.
https://github.com/redsolver/yt-splitter

Poi c'è questo post che parla di come mpv integri naturalmente youtube-dl per lo streaming:
https://ag91.github.io/blog/2022/05/02/emms-+-org-roam-youtube-playlists-with-titles/

Inoltre sarebbe bene amministrare tutto con EMMS, qui il manuale.
https://www.gnu.org/software/emms/manual/#Introduction

Per questo player si fa qui una buona intro
https://emacs.stackexchange.com/questions/3667/what-are-the-options-to-play-music-from-within-emacs

In questo articolo si citano un po' di belle playlist da videogiochi
https://www.indiscreto.org/capire-le-safe-rooms-nei-videogiochi/

* Pretty print XML
# Funzioni che tornano utili in varie situazioni.
# Questa è per la uso per il pretty-printing di HTML, di solito, ma va bene per un qualunque chunk XML:
I usually use this one for pretty printing HTML, but it runs fine on any XML chunk.

#+begin_src emacs-lisp :tangle config.el
(defun bf-pretty-print-xml-region (begin end)
  "Pretty format XML markup in region. You need to have nxml-mode
http://www.emacswiki.org/cgi-bin/wiki/NxmlMode installed to do
this.  The function inserts linebreaks to separate tags that have
nothing but whitespace between them.  It then indents the markup
by using nxml's indentation rules."
  (interactive "r")
  (save-excursion
    (nxml-mode)
    (goto-char begin)
    (while (search-forward-regexp "\>[ \\t]*\<" nil t)
      (backward-char) (insert "\n") (setq end (1+ end)))
    (indent-region begin end)
    (normal-mode))
  (message "Ah, much better!"))
#+end_src

* Which key
#+begin_quote
Let’s make this popup a bit faster
#+end_quote

# [[https://tecosaur.github.io/emacs-config/config.html#which-key][Dalla configurazione di tecosaur]]:
From [[https://tecosaur.github.io/emacs-config/config.html#which-key][From tecosaur's configuration]]:

#+begin_src emacs-lisp :tangle config.el
(setq which-key-idle-delay 0.5) ;; I need the help, I really do
#+end_src

* Curriculum Vitae
Finding myself forced, once again, to write a CV, I thought to myself, once again, how necessary it was to find a way for it to be the last one. Yet, no matter how much time is spent devising automatic procedures, a CV is something that is intrinsically in the process of being defined, and thus always subject to change. One can only keep revising it continually. The focus should then be on the path that guarantees the least amount of friction, in order to make the practice of updates not too detestable.

The most important output of a CV today is still the printable format, which is a PDF. You can achieve a good PDF mainly through these methods:
- LaTeX
- LibreOffice, Microsoft Office or other WYSIWYG office suites
- Images (SVG and vector graphics in general)

I would like, however, to also have a constantly updated web page, so I can manage an exportable file in both PDF (more or less directly) and HTML. LaTeX isn't convenient for exporting to web formats and I would like to maintain a useful matrix for exporting on both sides with even small differences (without keeping two files or two parallel branches on git). Some achieve this result by exporting from JSON, but I can't imagine writing a JSON by hand. We could maintain a YAML/TOML to export to JSON and then export in various formats, but still, I feel like the idea of managing an org file gives more flexibility.

That's why I'm working on [[https://github.com/gicrisf/orgcv][my CV exporter in org-mode]].
Keep in mind this is a work in progress and the code can look kind of messy at this moment.

The next settings aren't essential, just potentially useful.

# :tangle config.el
#+begin_src emacs-lisp 
(after! org
  ;; Import ox-latex to get org-latex-classes and other funcitonality
  ;; for exporting to LaTeX from org
  (use-package! ox-latex
    :init
    ;; code here will run immediately
    :config
    ;; code here will run after the package is loaded
    (setq org-latex-pdf-process
          '("pdflatex -interaction nonstopmode -output-directory %o %f"
            "bibtex %b"
            "pdflatex -interaction nonstopmode -output-directory %o %f"
            "pdflatex -interaction nonstopmode -output-directory %o %f"))
    (setq org-latex-with-hyperref nil) ;; stop org adding hypersetup{author..} to latex export
    ;; (setq org-latex-prefer-user-labels t)

    ;; deleted unwanted file extensions after latexMK
    ;; (setq org-latex-logfiles-extensions
    ;;      (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl" "xmpi" "run.xml" "bcf" "acn" "acr" "alg" "glg" "gls" "ist")))

    (unless (boundp 'org-latex-classes)
      (setq org-latex-classes nil))))

(after! org
  (use-package! ox-extra
    :config
    (ox-extras-activate '(latex-header-blocks ignore-headlines))))
#+end_src

* Emacs info pages
# Le pagine dei manuali su Emacs mancano spesso di colore, cosa che le rende più difficili da leggere delle loro controparti web.
# Il seguente pacchetto corregge questa mancanza:
The manual pages on Emacs often lack color, which makes them harder to read than their web counterparts.
The following package corrects this deficiency:

#+begin_src emacs-lisp :tangle packages.el
(package! info-colors)
#+end_src

[[https://github.com/ubolonton/info-colors][As shown in the README]], to enable it you have to add a hook in =config.el=.
# per abilitarlo bisogna aggiungere un hook in =config.el=.

#+begin_src emacs-lisp :tangle config.el
(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src

* Games
** Textual adventures
# GPT
# What is a text-based adventure game?
A text-based adventure game is a computer game in which the player interacts with the game world through text commands inputted by the player, rather than through graphical interfaces. The game typically presents the player with a narrative or puzzle to solve, and the player navigates the game world by typing in commands to perform actions or interact with objects.

# GPT
# Why they relied so much on player's imagination? (or something)
Text-based adventure games relied heavily on players' imagination because the game's interactive fiction format was limited to text descriptions of the game's environment and the player's actions. The player had to use their imagination to visualize the game's setting and their character's surroundings as they explored and interacted with the game world. This made text-based adventure games challenging and engaging, as the player's imagination played a crucial role in bringing the game to life.

With [[https://github.com/speedenator/malyon][Malyon]], you can play your favourite text adventure inside Emacs.

#+begin_src emacs-lisp :tangle packages.el
(package! malyon)
#+end_src

# Why Emacs works well with text-based adventure games?
Emacs works well with text-based adventure games because it is designed to be customizable and extensible, making it easy to create and run interactive command-line programs within the editor. Additionally, Emacs has built-in support for navigating and manipulating text, which is critical for playing text-based adventure games.

#+begin_quote
Malyon is a [[http://ifwiki.org/index.php/Interpreter][Z-machine interpreter]] for playing text-based adventure games such as Zork.
#+end_quote

# GPT
# Tell me about Zork, the textual game
Zork is a classic interactive fiction game that was popular in the 1980s. It was developed by MIT students in the late 1970s and was originally called Dungeon. Zork was a text-based adventure game where players typed commands to explore a fantasy world and solve puzzles. The game was known for its sense of humor and imaginative world-building. It has since inspired many other similar text-based adventure games.

Download Zork and other games from:
- [[http://www.ifarchive.org/indexes/if-archiveXgamesXzcode.html][Iteractive Fiction Archive]],
- [[https://ifdb.org/][Interactive Fiction Database]],

or make your own with [[https://www.emacswiki.org/emacs/InformMode][InformMode]].

# Secondo me si potrebbe sviluppare un gioco con org-mode
# Prima di convertire Inform mode per il literate approach sarebbe meglio studiare bene Inform
# Non ho tempo al momento, ma si tratta di un progettino potenzialmente interessante
# Check [[https://github.com/lmintmate/malyon][this fork]] if you encounter some problem.

* Dashboard
** Open org configuration (SPC o c)
# Al posto di aprire la cartella =.doom.d= per configurare Emacs, da ora in avanti vogliamo aprire questo file direttamente, quindi la funzione nella dashboard va modificata.
# Per riuscirci, innanzitutto dobbiamo creare una funzione che apra questo file.
Instead of opening the folder =.doom.d= to configure Emacs, from now on we want to open this file directly, so the function in the dashboard needs to be modified. To do this, we first need to create a function that opens this file.

# Ci servono due elementi, che possono variare di caso in caso:
# - Il nome del file
# - La directory in cui cercarlo
We need two elements that may vary in each case:
- The name of the file
- The directory in which to search for it

#+begin_src emacs-lisp :tangle config.el
(setq config-org-file-name "config.org"
      config-org-directory "~/.doom.d")
#+end_src

# Scriviamo una funzione dedicata all'apertura del file preselezionato.
We write a function dedicated to opening the right file.

#+begin_src emacs-lisp :tangle config.el
(defun open-config-org ()
  "Open your private config.org file."
  (interactive)
  (find-file (expand-file-name config-org-file-name config-org-directory)))
#+end_src

# Shortcut
# Assegniamo una scorciatoia da tastiera dedicata, sulle orme di =SPC+f+P= (file > Private).
We assign a dedicated keyboard shortcut, following in the footsteps of =SPC+f+P= (file > Private).
[[https://www.dschapman.com/notes/bde6e938-0984-4d60-974d-77178f1ecd9b][How?]]

#+begin_quote
In your =config.el= file add a map declaration using the =:leader= attribute and whatever prefix key you would like to use. Then after you have added the necessary prefix keys add a =:desc "Description of the command"= ="key" #'elisp-command-to-execute= for each shortcut you wish to add.
#+end_quote

Using =map!=:

# (SPC open/configuration)
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("o" . "open")
       :desc "Open your private config.org file." "c" #'open-config-org))
#+end_src

# Dashboard
# Per intervenire sul menù, prima diamo un'occhiata alle sezioni della dashboard.
To intervene on the menu, let's first take a look at the sections of the dashboard.

#+begin_src emacs-lisp
(cl-subseq +doom-dashboard-menu-sections 0)
#+end_src

# Otteniamo una lista, da cui estrapoliamo la funzione che vogliamo sostituire (questa):
We obtain a list, from which we extract the function we want to replace (this one).

#+begin_src emacs-lisp
("Open private configuration" :icon (all-the-icons-octicon "tools" :face 'doom-dashboard-menu-title) :when (file-directory-p doom-private-dir) :action doom/open-private-config)
#+end_src

# Come intendiamo modificarla? Così:
How do we intend to edit it? Like this:

#+name: open-org-configuration-menu-section
#+begin_src emacs-lisp
("Open org configuration" :icon (all-the-icons-octicon "tools" :face 'doom-dashboard-menu-title) :action open-config-org)
#+end_src

# Intanto teniamo questa funzione da parte col nome di =open-org-configuration-menu-section=.

# Ora sostituiamola al menù [[https://stackoverflow.com/questions/170931/replace-an-item-in-a-list-in-common-lisp][con la funzione =setf=]].
#
Now let's replace it in the menu with the =setf= function (like shown [[https://stackoverflow.com/questions/170931/replace-an-item-in-a-list-in-common-lisp][on StackOverflow]]).

#+begin_src emacs-lisp :tangle config.el :noweb yes
(setf (nth 5 +doom-dashboard-menu-sections) '<<open-org-configuration-menu-section>>)
#+end_src

** Enter Elfeed (SPC e e)
# Ripercorro i passi fatti prima, ma stavolta senza dilungarmi in chiacchiere.
I retrace the steps taken before, but this time without delving into chatter.

# Shortcut

# Prima assegno una scorciatoia da tastiera:
First, I assign a keyboard shortcut:

# SPC elfeed enter
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("e" . "elfeed")
       :desc "Enter elfeed." "e" #'elfeed))
#+end_src

# Dashboard

# Voglio questo elemento sulla dashboard:
I want this element on the dashboard.

#+name: open-elfeed-menu-section
#+begin_src emacs-lisp
("Open elfeed" :icon (all-the-icons-octicon "rss" :face 'doom-dashboard-menu-title) :action elfeed)
#+end_src

# Stavolta vado a sostituire il terzo elemento, che raramente uso (=Recently opened files=).
This time I am going to replace the third element, which I rarely use (=Recently opened files=).

#+begin_src emacs-lisp :tangle config.el :noweb yes
(setf (nth 2 +doom-dashboard-menu-sections) '<<open-elfeed-menu-section>>)
#+end_src

# Già che ci siamo, aggiungiamo una shortcut per aggiornare elfeed:
Since we're at it, let's add a shortcut to update Elfeed.

#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("e" . "elfeed")
       :desc "Update all the feeds in elfeed." "u" #'elfeed-update))
#+end_src

** Quit and go Home (SPC q h)
# Una semplice scorciatoia da tastiera per tornare alla dashboard:
A simple keyboard shortcut to return to the dashboard:

# SPC quit (and go) home
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("q" . "quit/session")
       :desc "Switch to the dashboard in the current window, of the current FRAME." "h" #'+doom-dashboard/open))
#+end_src

** Org Manual (SPC o i)
Move "Open project" section of the dashboard and make space for the documentation.

# Anche stavolta andiamo avanti velocemente.
This time too we move forward quickly.

# Voglio questo elemento sulla dashboard:
I need this element on my dashboard:

#+name: open-docs-menu-section
#+begin_src emacs-lisp
("Open info" :icon (all-the-icons-octicon "info" :face 'doom-dashboard-menu-title) :action info)
#+end_src

# Stavolta vado a sostituire il terzo elemento, che raramente uso (=Recently opened files=).
This time I am going to replace the third element, which I rarely use (=Recently opened files=).

#+begin_src emacs-lisp :tangle config.el :noweb yes
(setf (nth 3 +doom-dashboard-menu-sections) '<<open-docs-menu-section>>)
#+end_src

# Riprendiamo l'elemento rimosso...
We take back the removed element...

#+name: switch-project-menu-section
#+begin_src emacs-lisp
("Open project" :icon (all-the-icons-octicon "briefcase" :face 'doom-dashboard-menu-title) :action projectile-switch-project)
#+end_src

# ... e sistemiamolo in prima posizione:
...and let's put it in first position.

#+begin_src emacs-lisp :tangle config.el :noweb no-export
(setf (nth 0 +doom-dashboard-menu-sections) '<<switch-project-menu-section>>)
#+end_src

Let's add a shortcut for org-mode, since I refer to it frequently.

# SPC elfeed enter
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("o" . "open")
       :desc "Open org manual." "i" #'org-info))
#+end_src

** Doom documentation (SPC h d h)
Just changing the name.

#+name: open-doom-docs-menu-section
#+begin_src emacs-lisp
("Doom documentation" :icon (all-the-icons-octicon "book" :face 'doom-dashboard-menu-title) :action doom/help)
#+end_src

Let's leave it in sixth position.

#+begin_src emacs-lisp :tangle config.el :noweb no-export
(setf (nth 6 +doom-dashboard-menu-sections) '<<open-doom-docs-menu-section>>)
#+end_src

** COMMENT PNG home banner
I liked this pixelart.
See [[https://www.hypertalking.com/2023/05/08/1-bit-pixel-art-of-hokusais-the-great-wave-off-kanagawa/][the blog post]] from its creator.

#+begin_src emacs-lisp :tangle config.el :noweb no-export
(setq fancy-splash-image "~/Fuji-01-desktop-ptn-640x480-1.png")
#+end_src

** COMMENT Banner
Experimental.
Just trying stuff out, but I stick with the regular banner for the moment.

See [[https://discourse.doomemacs.org/t/how-to-change-your-splash-screen/57][this discourse post]].

A weebish example (not tangled code):
# :tangle config.el
#+begin_src emacs-lisp
(defun my-weebery-is-always-greater ()
  (let* ((banner '("⢸⣿⣿⣿⣿⠃⠄⢀⣴⡾⠃⠄⠄⠄⠄⠄⠈⠺⠟⠛⠛⠛⠛⠻⢿⣿⣿⣿⣿⣶⣤⡀⠄"
                   "⢸⣿⣿⣿⡟⢀⣴⣿⡿⠁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣸⣿⣿⣿⣿⣿⣿⣿⣷"
                   "⢸⣿⣿⠟⣴⣿⡿⡟⡼⢹⣷⢲⡶⣖⣾⣶⢄⠄⠄⠄⠄⠄⢀⣼⣿⢿⣿⣿⣿⣿⣿⣿⣿"
                   "⢸⣿⢫⣾⣿⡟⣾⡸⢠⡿⢳⡿⠍⣼⣿⢏⣿⣷⢄⡀⠄⢠⣾⢻⣿⣸⣿⣿⣿⣿⣿⣿⣿"
                   "⡿⣡⣿⣿⡟⡼⡁⠁⣰⠂⡾⠉⢨⣿⠃⣿⡿⠍⣾⣟⢤⣿⢇⣿⢇⣿⣿⢿⣿⣿⣿⣿⣿"
                   "⣱⣿⣿⡟⡐⣰⣧⡷⣿⣴⣧⣤⣼⣯⢸⡿⠁⣰⠟⢀⣼⠏⣲⠏⢸⣿⡟⣿⣿⣿⣿⣿⣿"
                   "⣿⣿⡟⠁⠄⠟⣁⠄⢡⣿⣿⣿⣿⣿⣿⣦⣼⢟⢀⡼⠃⡹⠃⡀⢸⡿⢸⣿⣿⣿⣿⣿⡟"
                   "⣿⣿⠃⠄⢀⣾⠋⠓⢰⣿⣿⣿⣿⣿⣿⠿⣿⣿⣾⣅⢔⣕⡇⡇⡼⢁⣿⣿⣿⣿⣿⣿⢣"
                   "⣿⡟⠄⠄⣾⣇⠷⣢⣿⣿⣿⣿⣿⣿⣿⣭⣀⡈⠙⢿⣿⣿⡇⡧⢁⣾⣿⣿⣿⣿⣿⢏⣾"
                   "⣿⡇⠄⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢻⠇⠄⠄⢿⣿⡇⢡⣾⣿⣿⣿⣿⣿⣏⣼⣿"
                   "⣿⣷⢰⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⢰⣧⣀⡄⢀⠘⡿⣰⣿⣿⣿⣿⣿⣿⠟⣼⣿⣿"
                   "⢹⣿⢸⣿⣿⠟⠻⢿⣿⣿⣿⣿⣿⣿⣿⣶⣭⣉⣤⣿⢈⣼⣿⣿⣿⣿⣿⣿⠏⣾⣹⣿⣿"
                   "⢸⠇⡜⣿⡟⠄⠄⠄⠈⠙⣿⣿⣿⣿⣿⣿⣿⣿⠟⣱⣻⣿⣿⣿⣿⣿⠟⠁⢳⠃⣿⣿⣿"
                   "⠄⣰⡗⠹⣿⣄⠄⠄⠄⢀⣿⣿⣿⣿⣿⣿⠟⣅⣥⣿⣿⣿⣿⠿⠋⠄⠄⣾⡌⢠⣿⡿⠃"
                   "⠜⠋⢠⣷⢻⣿⣿⣶⣾⣿⣿⣿⣿⠿⣛⣥⣾⣿⠿⠟⠛⠉⠄⠄          "))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat line (make-string (max 0 (- longest-line (length line))) 32)))
               "\n"))
     'face 'doom-dashboard-banner)))

(setq +doom-dashboard-ascii-banner-fn #'my-weebery-is-always-greater)
#+end_src

* COMMENT Zen mode
# Usiamo un font seriffato:
Using a serif font for Zen mode:

# :tangle config.el
#+begin_src emacs-lisp
(defvar +zen-serif-p t
  "Whether to use a serifed font with `mixed-pitch-mode'.")
#+end_src

Detangled because I don't like this anymore. Maybe I should look for a totally different font with Zen mode.

* Weather
# [[https://github.com/bcbcarl/emacs-wttrin/][Esiste già un frontend per Emacs]], ma è da almeno cinque anni che non dà segni di manutenzione. Quindi [[https://github.com/gicrisf/emacs-wttrin][lavorerò sul mio fork]] (tanto avevo comunque intenzione di aggiungere funzioni supplementari, avrei probabilmente forkato a prescindere).
[[https://github.com/bcbcarl/emacs-wttrin/][There is already a frontend for Emacs]], but it has not shown any signs of maintenance for at least five years. Therefore, [[https://github.com/gicrisf/emacs-wttrin][I will work on my fork]] (since I intended to add additional functions anyway, I would have probably forked it regardless).

# Innanzitutto aggiungiamo questo pacchetto:
First, let's add this package:

#+begin_src emacs-lisp :tangle packages.el :noweb yes
(package! wttrin :recipe (:host github :repo "gicrisf/emacs-wttrin"))
#+end_src

# Qui lo configuro secondo le mie necessità:
Here, I configure it according to my needs:

#+begin_src emacs-lisp :tangle config.el :noweb yes
(setq wttrin-default-cities '("Caltagirone" "Bologna" "Ferrara" "Catania"))
(setq wttrin-default-accept-language '("Accept-Language" . "it-IT"))
#+end_src

* COMMENT Protonmail :it:
Quando Protonmail ha rilasciato ProtonBridge mi sono chiesto se non valesse la pena di ritentare un approccio locale alle email.
Le alternative apprezzabili per il momento mi sembrano due:
- Mozilla Thunderbird
- Emacs

Thunderbird ha di recente ricevuto un importante aggiornamento che ha fatto fare all'app un apparente salto di qualità, anche in termini di design, cosa che sicuramente torna utile in un client email del 2022 in competizione con delle web app sempre più piacevoli da vedere.

Emacs, d'altra parte, mi consentirebbe di scrivere le email in org-mode ed all'interno di un sistema integrato con il mio flusso di lavoro abituale; posso persino scrivere in un buffer separato mentre mi occupo di qualcos'altro nel buffer principale ecc. La comodità di avere tutto a portata di shortcut è irresistibile, soprattutto se non c'è troppo da smanettare con strani script arrangiati in casa.
Per una volta, mi trovo dinnanzi un servizio che supporta i client locali, anziché antagonizzarli (sì gmail, guardo proprio te).
Per fortuna, c'è già che chi si è portato avanti su questa strada:
- [[https://shom.dev/posts/20220108_setting-up-protonmail-in-emacs/][shom.dev]]
- [[https://systemcrafters.net/emacs-mail/][system crafters]]
- [[http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-/][Caches to Caches (Gregory J. Stein)]]
- [[https://jherrlin.github.io/posts/emacs-mu4e/][jherrlin.github.io]]

Il primo post, in particolar modo, torna utile per la sua brevità. Cosa bisogna fare?

#+begin_quote
*ATTENZIONE!*

Prima di continuare, tieni a mente che Proton Bridge è un servizio fornito solo ai possessori di un account premium.
Io l'ho scoperto troppo tardi, motivo per cui lascerò tutto nel mio file di configurazione (potrebbe tornare utile in futuro), ma per ora non aggroviglierò nulla.
#+end_quote

** Installare ProtonBridge
Da AUR:

#+begin_src bash
yay protonmail-bridge
#+end_src

Si tratta di un'applicazione open source che rimane aperta in background e genera tutti i file necessari per autenticarsi in sicurezza mediante un client esterno.
Apprezzo il fatto che non sia un'app di Electron, ma che il frontend sia in Qt. Ciononostante, comunque temo un po' per il consumo sul mio laptop.

** Installare mbsync
Innanzitutto, è necessario installare e configurare =mbsync=. Sarebbe materia per i miei literate dotfiles, ma al fine di tenere tutto in un posto preferisco gestire da qui anche questo.

#+begin_src bash
sudo pacman -S isync
#+end_src

** Configurazione di mbsync
La configurazione di mbsync è l'ennesimo dotfile sulla home, =~/.mbsyncrc=:

# User giovanni . crisalfi at...
# :tangle ~/.mbsyncrc
#+begin_src txt
IMAPAccount proton
Host 127.0.0.1
User user@protonmail.com
PassCmd "cat ~/.protonBridgePass"
SSLType NONE
CertificateFile /etc/ssl/certs/ca-certificates.crt

IMAPStore proton-remote
Account proton

MaildirStore proton-local
Subfolders Verbatim
Path ~/mail/proton
Inbox ~/mail/proton/inbox

Channel proton
Far :proton-remote:
Near :proton-local:
Patterns *
Create Both
SyncState *
#+end_src

** Configurazione di mu4e
Su Doom Emacs, è possibile abilitare il modulo =mu4e= onde avere quasi tutto l'occorrente.

Passiamo alla configurazione di mu4e.
- Ricerca delle mail ogni mezzora;
- Recupero delle mail attraverso =mbsync=;
- Tutte le mail finiscono nella home, sotto la cartella mail.
- Le shortcut per il momento seguono la notazione inglese.

# :tangle config.el
#+begin_src emacs-lisp
(setq mu4e-change-filenames-when-moving t ; avoid sync conflicts
      mu4e-update-interval (* 30 60) ; check mail 30 minutes
      mu4e-compose-format-flowed t ; re-flow mail so it's not hard wrapped
      mu4e-get-mail-command "mbsync -a"
      mu4e-maildir "~/mail/proton")

(setq mu4e-drafts-folder "/proton/Drafts"
      mu4e-sent-folder   "/proton/Sent"
      mu4e-refile-folder "/proton/All Mail"
      mu4e-trash-folder  "/proton/Trash")

(setq mu4e-maildir-shortcuts
      '(("/proton/inbox"     . ?i)
    ("/proton/Sent"      . ?s)
    ("/proton/Trash"     . ?t)
    ("/proton/Drafts"    . ?d)
    ("/proton/All Mail"  . ?a)))
#+end_src

** Configurazione SMTP
Il supporto SMTP è integrato nativamente in Emacs con =smtpmail=.
Non c'è bisogno di installare nulla qui.
Il server SMTP potrebbe interferire con altri server locali? Esempio quello di Zola?

# :tangle config.el
#+begin_src emacs-lisp
(setq message-send-mail-function 'smtpmail-send-it
      auth-sources '("~/.authinfo") ;need to use gpg version but only local smtp stored for now
      smtpmail-smtp-server "127.0.0.1"
      smtpmail-smtp-service 1025
      smtpmail-stream-type  'ssl)
#+end_src

** Componi le email con org-mode
Installiamo =org-msg= per scrivere le mail in org mode ed esportarle in HTML.

#+begin_quote
[[https://github.com/jeremy-compostella/org-msg][OrgMsg]] is a GNU Emacs global minor mode mixing up Org mode and your Mail User Agent Mode (Message mode, mu4e mode, or notmuch mode) to compose and reply to emails in a Outlook HTML friendly style.
#+end_quote

Senza questa accortezza, invieremmo delle mail in puro testo, che sarebbe una cosa pure profondamente amabile, ma qualche tempo fa ho constatato che molti client email tendono ad inserire tra lo spam qualunque cosa non sia formattata in HTML. Lo so, questa idea malsana di introdurre la formattazione HTML per le mail ha rovinato le mail stesse, ma ormai è troppo tardi per opporsi.

# :tangle packages.el
#+begin_src emacs-lisp
(package! org-msg)
#+end_src

Concludiamo con la configurazione minima di =org-msg=.

# :tangle config.el
#+begin_src emacs-lisp
(setq mail-user-agent 'mu4e-user-agent)
(require 'org-msg)

(setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
      org-msg-startup "hidestars indent inlineimages"
      org-msg-default-alternatives '((new . (text html))
                                     (reply-to-html . (text html))
                                     (reply-to-text . (text)))
      org-msg-convert-citation t)

(org-msg-mode)
#+end_src

* Chemical structures
# TODO ristrutturare questa parte
# Prima spiego il problema della rappresentazione delle molecole
# Spiego perché mi dà fastidio portarmi in giro le immagini
# Mi dà fastidio che non siano riproducibili
# Questo vale per 2D e 3D
# Affrontiamo prima il problema delle 2D => chemfig
# Cosa è chemfig
# Come si installa chemfig
# Come possiamo integrare chemfig in Emacs?
# Link alla libreria
# Affrontiamo poi il problema delle 3D => fresnel
# Cos'è fresnel
# Come si installa fresnel

#+begin_src emacs-lisp :tangle packages.el :noweb yes
;; (package! tochemfig :recipe (:host github :repo "gicrisf/tochemfig"))
#+end_src

* COMMENT Whisper (Speech to Text)
I simply find this interesting, so I want to try it.

# :tangle packages.el
#+begin_src emacs-lisp
(package! whisper)
#+end_src

# :tangle config.el
#+begin_src emacs-lisp
(use-package whisper
  :bind ("C-H-r" . whisper-run)
  :config
  (setq whisper-install-directory "/tmp/"
        whisper-model "base"
        whisper-language "en"
        whisper-translate nil))
#+end_src

* COMMENT My life in Emacs: EXWM
I'm a Gnome user, but I think it would be nice to have the EXWM option, especially because I'm interested to study the power consumption.

# :tangle packages.el
#+begin_src emacs-lisp
(package! exwm)
#+end_src

Not tangled, because it's experimental.
# :tangle config.el
#+begin_src emacs-lisp
 (use-package exwm
    :init
    ;; (require 'exwm-randr)
    (exwm-enable)
    ;; (tsa/safe-load-file "~/local-config.el")
    (exwm-randr-enable) ; https://github.com/ch11ng/exwm/wiki
    ;; (defvar efs/polybar-process nil
    ;;  "Holds the process of the running Polybar instance, if any")
#+end_src

* COMMENT Quick browsing
** Deft
Set directory, extension to search for and explicitly say you want to search recursively in the subfolders.

# :tangle config.el
#+begin_src emacs-lisp
;; Not using deft rn
(setq deft-directory "~/org"
      deft-extensions '("org" "txt"))
(setq deft-recursive t)
#+end_src

The main function is too heavy and I don't really need using all deft features.
I'm detangling this block because I prefer simply using =SPC n s= for the moment (notes/search note).
# La funzione principale per me è troppo lenta, oltre ad essere fin troppo fornita. Per ora disabilito tutto, perché preferisco usare =SPC+n+s= (notes/search note).

** Rifle
# Per il momento ne faccio a meno per lo stesso motivo per cui ho disabilitato deft (vedi più avanti).
I'm living without right now for similar reasons on why I disabled DEFT (see later); so, I leave the line commented.

#+begin_src emacs-lisp :tangle packages.el
;; (package! helm-org-rifle)
#+end_src

* COMMENT Backtab
I should find an alternative way, because this one doesn't work, so I'm de-tangling it.

# :tangle config.el
#+begin_src emacs-lisp
;; Source: [[https://stackoverflow.com/questions/23692879/emacs24-backtab-is-undefined-how-to-define-this-shortcut-key]]
(global-set-key (kbd "<backtab>") 'un-indent-by-removing-4-spaces)
(defun un-indent-by-removing-4-spaces ()
  "remove 4 spaces from beginning of of line"
  (interactive)
  (save-excursion
    (save-match-data
      (beginning-of-line)
      ;; get rid of tabs at beginning of line
      (when (looking-s "^\\at-+")
        (untabify (match-beginning 0) (match-end 0)))
      (when (looking-at "^    ")
        (replace-match "")))))
#+end_src

* AI
** ChatGPT
OpenAI's packages:

#+begin_src emacs-lisp :tangle packages.el
(package! openai :recipe (:host github :repo "emacs-openai/openai"))
(package! chatgpt :recipe (:host github :repo "emacs-openai/chatgpt"))
#+end_src

# Recuperiamo l'API key da variabile d'ambiente:
Retrieving the API key from the env var:

#+begin_src emacs-lisp :tangle config.el
(setq openai-key (getenv "OPENAI_KEY"))
#+end_src

# Una dipendenza cosmetica di questi pacchetti è spinner.
# Selezioniamo lo spinner preferito:
A cosmetic dependency of these packages is spinner.
Let's select the preferred spinner.

#+begin_src emacs-lisp :tangle packages.el
;; (setq chatgpt-spinner-type 'rotating-line)
(setq chatgpt-spinner-type 'minibox)
#+end_src

# Questo viene più comodo per selezionare del testo ed elaborarlo direttamente, ma non usa le API:
This is more convenient for selecting text and processing it directly, but it does not use the APIs.

#+begin_src emacs-lisp :tangle packages.el
;; (package! chatgptel :recipe (:host github :repo "joshcho/ChatGPT.el"))
#+end_src

# Diamo il path della repo perché ha bisogno di richiamare un file Python che agisce da server:
We give the path of the repository because it needs to invoke a Python file that acts as a server.

#+begin_src emacs-lisp :tangle config.el
(setq chatgpt-repo-path "~/Projects/ChatGPT.el/")
#+end_src

# La funzione =chatgpt--query= non va a causa dell'impiego di una macro anaforica che coinvolge due =eval=; potrei semplificarla in questo modo:
The =chatgpt--query= function doesn't work because of the use of an anaphoric macro that involves two =eval=; I could simplify it in this way:

#+begin_src emacs-lisp
(defun chatgpt--query (query)
  "Send QUERY to the ChatGPT process."
  (unless chatgpt-process
    (chatgpt-init))
  (let ((saved-id (cl-incf chatgpt-id)))
    (chatgpt--insert-query query saved-id)
    (when chatgpt-enable-loading-ellipsis
      (chatgpt--add-timer saved-id))
    (when chatgpt-display-on-query
      (chatgpt-display))
    (deferred:$
     (deferred:$
      (epc:call-deferred chatgpt-process 'query (list query))
      (deferred:nextc it
               (lambda (response)
                 (chatgpt--stop-wait ,saved-id)
                 (chatgpt--insert-response response ,saved-id)
                 (when chatgpt-display-on-response
                   (chatgpt-display))))))))
#+end_src

# Volendo, potrei usare qualche advice per sovrascriverla temporaneamente.
If I wanted to, I could use some advice to temporarily overwrite it.
# Il problema è che questa libreria nello specifico non usa le API di ChatGPT ed io ne preferirei una che le usa.
# Quindi, per arrivare ad un risultato che mi piaccia, dovrei modificare pure le funzioni nel server, cosa che mi porterebbe a gestire un fork.
The problem is that this specific library does not use the ChatGPT APIs, and I would prefer one that does.
So, to achieve a result that I like, I would also have to modify the functions in the server, which would lead me to manage a fork.

# Non so se ho voglia di mantenere un fork. Vediamo se ci sono alternative.
I don't know if I feel like maintaining a fork.
Let's see if there are alternatives.

[[https://github.com/karthink/gptel][This one, instead, is called gptel]] e usa le API:

#+begin_src emacs-lisp :tangle packages.el
(package! gptel :recipe (:host github :repo "karthink/gptel"))
#+end_src

# Anche qui, recuperiamo la key:
Here too, we recover the key:

#+begin_src emacs-lisp :tangle config.el
(setq gptel-api-key (getenv "OPENAI_KEY"))
#+end_src

# Proviamo il seguente prompt con gptel:
Let's try the following prompt with gptel.

#+begin_quote
Tell me about the geography of Taiwan.
#+end_quote

This is the result:

#+begin_quote
Taiwan is an island located off the southeastern coast of China. It has rugged, mountainous terrain, with more than half of its land area covered in forest. The western side of the island is more densely populated and urbanized, while the eastern side is more rural and less developed. Taiwan also has several small offshore islands.
#+end_quote

Looks fine.

** DALL-E
#+begin_src emacs-lisp :tangle packages.el
(package! dall-e :recipe (:host github :repo "emacs-openai/dall-e"))
#+end_src

#+begin_src emacs-lisp :tangle config.el
(setq dall-e-n 1)
(setq dall-e-spinner-type 'flipping-line)
(setq dall-e-display-width 256)
#+end_src

** Llama
# Sfruttando la CLI fornita da [[https://github.com/rustformers/llama-rs][=llama-rs=/=llama-cli=]], è possibile passare un prompt da emacs e restituire i risultati direttamente nel browser.
Using the CLI provided by [[https://github.com/rustformers/llama-rs][=llama-rs=/=llama-cli=]], it is possible to pass a prompt from Emacs and return the results directly in the browser.

# :tangle config.el
#+begin_src emacs-lisp
(defun llama-prompt (prompt)
  "Get a PROMTP for Llama and return the response."
  (interactive "sEnter PROMPT: ")
  (setq comd (concat "llama-cli --model-path ~/ggml-alpaca-7b-q4.bin -p \'" prompt "\'"))
  (insert (shell-command-to-string comd))
  (message "The Llama has spoken."))
#+end_src

# Voglio evitare che questo processo faccia laggare l'intera piattaforma.
# Mi serve un RPC stack per Emacs.
I want to avoid this process from making the entire platform lag.
I need an RPC stack for Emacs.

# Prima installo =deferred=...
I install =deferred= first.

#+begin_src emacs-lisp :tangle packages.el
(package! deferred)
#+end_src

Then =epc=.

#+begin_src emacs-lisp :tangle packages.el
(package! epc :recipe (:host github :repo "kiwanami/emacs-epc"))
#+end_src

# Scrivo =llamacs= e ne faccio un pacchetto.
# A questo punto, devo configurarlo.
I write =llamacs= and [[https://github.com/gicrisf/llamacs][turn it into a package]]. At this point, I need to configure it.

#+begin_src emacs-lisp :tangle config.el
(setq llamacs-model-path "~/ggml-alpaca-7b-q4.bin")
(setq llamacs-repo-path "~/Projects/llamacs/")
#+end_src

* Snippets
# Why yasnippet is so useful in the Emacsers' workflow?
Reusing and adapting frequently used code saves precious time, while also minimizing mistakes.
That's why templating libraries are born: to help people coding fast and safely.
YASnippet is an Emacs library that allows for the creation and insertion of custom snippets, making easier to reuse code blocks.

Helm and Vertico are both extensions for Emacs that help with navigating and selecting options.
While YASnippet works perfectly fine with Helm, after switching to Vertico it stopped working on my system.
The following function is a workaround proposed by [[https://github.com/doomemacs/doomemacs/issues/4127#issuecomment-1019731798][jgrey4296]].

#+begin_src emacs-lisp :tangle config.el
(defun +snippet--completing-read-uuid (prompt all-snippets &rest args)
  (let* ((snippet-data (cl-loop for (_ . tpl) in (mapcan #'yas--table-templates (if all-snippets
                                                                                    (hash-table-values yas--tables)
                                                                                  (yas--get-snippet-tables)))

                                for txt = (format "%-25s%-30s%s"
                                                  (yas--template-key tpl)
                                                  (yas--template-name tpl)
                                                  (abbreviate-file-name (yas--template-load-file tpl)))
                                collect
                                `(,txt . ,(yas--template-uuid tpl))))
         (selected-value (apply #'completing-read prompt snippet-data args)))
    (alist-get selected-value snippet-data nil nil 'equal)))
#+end_src

* Kaomoji
#+begin_src emacs-lisp :tangle packages.el
(package! kaomel :recipe (:host github :repo "gicrisf/kaomel"))
#+end_src

* COMMENT Docsets
Dash docsets.

#+begin_src emacs-lisp
(package! dash-docs :recipe (:host github :repo "dash-docs-el/dash-docs"))
#+end_src

Forse è preinstallato.

Abbiamo installato per Python 3.
"Docset installed. Add "Python 3" to dash-docs-common-docsets or dash-docs-docsets."

Dobbiamo aggiungerlo.

# :tangle config.el
#+begin_src emacs-lisp
(setq dash-docs-docsets "Python 3")
#+end_src

Proviamo:

#+begin_src emacs-lisp
(dash-docs-search-docset '("Python 3") "class")
#+end_src

#+RESULTS:

Va be', basta, uso Elpy, anzi, prima provo lsp.
https://github.com/doomemacs/doomemacs/issues/1997

#+begin_src emacs-lisp :tangle packages.el
(package! elpy :recipe (:host github :repo "jorgenschaefer/elpy"))
#+end_src

Voglio più documentazione:

#+begin_src emacs-lisp :tangle config.el
(add-to-list 'Info-default-directory-list "~/info_manuals")
#+end_src

* Tangle and compile from path

#+begin_src emacs-lisp :tangle config.el
(defun gicrisf/emacs-lisp-byte-compile-and-load-from-path (path)
  "Byte-compile the file in PATH (if it has changed), then load compiled code."
  (interactive nil emacs-lisp-mode)
  (emacs-lisp--before-compile-buffer)
  (require 'bytecomp)
  (let ((abspath (expand-file-name path)))
    (byte-recompile-file abspath nil 0)
    (load (byte-compile-dest-file abspath))))
#+end_src

* Regex
#+begin_src emacs-lisp :tangle packages.el
(package! pcre2el :recipe (:host github :repo "joddie/pcre2el"))
#+end_src

* Conclusions
# Questo file è in continua trasformazione.
This file is in constant change: more like a partially molded amorphous substance than like a liquid, but still in constant change.

# Esporto prism.js perché per il momento Zola ha un bug che non mi consente di colorare la sintassi.
{{{prismcss}}}
{{{prismjs}}}
