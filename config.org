#+title: Doom Emacs Configuration
#+author: Giovanni Crisalfi
#+STARTUP: show2levels

# Export metadata
#+hugo_base_dir: ~/zwitterio-it/
#+hugo_tags: emacs org
#+hugo_categories: software posts notes
#+hugo_publishdate: 2022-08-10
#+hugo_auto_set_lastmod: t
#+hugo_date: [2023-04-09 dom]
#+hugo_section: software/emacs-config/index.en.md

# Zola specific divider
#+MACRO: more @@html:<!-- more -->@@
# Temporary macros for prism support
#+MACRO: prismcss @@html:<link href="/assets/prism/prism.css" rel="stylesheet" />@@
#+MACRO: prismjs @@html:<script src="/assets/prism/prism.js"></script>@@
# Macro for backlinks in exported posts
#+MACRO: exportedfrom @@html:<hr><p>This post was exported from <a href="https://github.com/gicrisf/emacs-config">my literate configuration for Emacs</a></p>@@

Hello, and welcome to my Emacs configuration!
It's written in Org-mode and designed to be /literate/, meaning that I've documented many of the choices I made throughout the process.

{{{more}}}

* Intro
** What is Emacs
# What is Emacs?
# developed by Richard Stallman in the 1970s, known for its extensibility and productivity features.

- Emacs is a highly customizable text editor.
- Emacs is a lisp interpreter.
- Emacs is a text manipulation application, known for its extensibility.
- Emacs, like water, adapts to any container, flows around any obstacle, erodes mountains (of data), transforms into different phases (or modes) depending on circumstances.

# Describing Emacs is not easy, because Emacs it's a moldable environment.

Describing Emacs isn't easy, because Emacs is many things, and different ones to different people.
To me, Emacs is the place where I write code, I write prose, I manage files, I read feeds, I think.
In the next sections, I will show how.

Being Emacs so generic and powerful, it can be difficult to approach it and learn how to work with it. That's why Emacs distributions exist.

** Emacs distributions
The entry barrier can be partially broken down through pre-configured Emacs distributions, of which I mention a few of the most famous:
- [[https://www.spacemacs.org/][Spacemacs]] was my first distribution: it is particularly indicated for newcomers coming from vim, like I was. Not only is it effective in emulating vim (thanks to [[https://github.com/emacs-evil/evil][Evil]]), but it also has countless auxiliary functions callable with a simple touch on the space bar (space-emacs, not surprisingly).
- [[https://github.com/rougier/nano-emacs][NANO Emacs]]: minimal dependencies, exceptionally elegant, functionally very close to Vanilla Emacs;
- [[https://github.com/doomemacs/doomemacs][Doom Emacs]] is my current distribution, and therefore the one I am using to write this document; also this one (like Spacemacs) is very well integrated with Evil and lends itself well to the needs of any ex-vimmer. In addition, the use of various lazy-loading strategies and, in general, a thoughtful selection of packages make this distribution extremely responsive.

# La configurazione riportata in questo file può, potenzialmente, essere adattata anche ad altre distribuzioni Emacs, ma presa com'è funziona solo su Doom Emacs.
The configuration reported in this file could potentially be adapted to other Emacs distributions, but as it is, it only works for Doom Emacs.

** Emacs Lisp
As I was saying, Emacs is a Lisp interpreter, but to be more precise we should refer to Emacs Lisp, a dialect of the programming language family that falls under the name "Lisp" (LISt Processor).

Lisp is a functional programming language known for its simple syntax and powerful macro system.
Lisp's monomorphism demands bare-bones syntax (enough to scare lots of C-like coders), but this also gives flexibility that allows for easy prototyping and experimentation.
Its versatility is illustrated by its use in artificial intelligence, theorem proving and web development, among other areas.

# Non voglio dilungarmi in questa sede nella descrizione del linguaggio. Per un assaggio della sintassi e di qualche funzione base, piuttosto, rimando [[https://www.zwitterio.it/software/elisp-intro/][a questo post che ho scritto sul blog come breve introduzione]].

# I don't want to go into detail about the language in this forum. For a taste of the syntax and some basic functions, instead, I refer you to [this post I wrote on the blog as a brief introduction]."# [[https://www.zwitterio.it/coding/2022/elisp-intro/][Ho scritto sul blog un'introduzione ad Emacs Lisp]], ma è in effetti più un mucchietto di appunti personali, un riassunto di funzioni utili.
# Avendo iniziato solo da poco tempo a navigare nell'oceano di meraviglie e parentesi lispiane, non sono certo la fonte più autorevole per scendere più nel dettaglio.

For a quick guide to Emacs Lisp, I recommend taking a look at [[https://github.com/chrisdone/elisp-guide][this repo]].
For a less quick but more in-depth guide, refer to [[https://github.com/hypernumbers/learn_elisp_the_hard_way][Learn elisp the hard way]].

# Per essere ancora più precisi, Emacs fa largo uso di CL e altro con adeguate interfacce

** Literate programming
CLOSED:
:PROPERTIES:
:EXPORT_HUGO_SECTION: software/literate-programming
:EXPORT_FILE_NAME: index.en.md
:EXPORT_DATE: [2023-04-10 lun]
:END:

What is /literate programming/? Is it not just another way of describing code?

{{{more}}}

Literate programming is a programming paradigm that emphasizes the organization of code for human understanding, rather than computer execution. It involves embedding documentation and explanatory text alongside code in a single document, allowing for clearer communication of the code's intent and functionality.

# Mia vecchia introduzione
# Il literate programming è un paradigma di programmazione ideato da Donald Knuth che prevede l'alternarsi di testo e di codice, in un modo che sono sicuro sia noto a chiunque si sia mai trovato a maneggiare un Jupiter Notebook.

In short, everything is written in a single file and the editor is taught how to assemble the code at a later time. The practice of writing the source is called /weaving/, while the moment of exporting is called /tangling/.

This approach has numerous advantages, but I will mention just two of the most evident:
- First of all, the code is very readable even after a long time, but this is a result that could be achieved by commenting a source code properly in the traditional way. Certainly, it is much simpler to associate simplified code blocks or examples from the manual just before writing the code that will then be part of the exported file. In org-mode, it is also possible to combine various languages and run them on the spot with org-babel;
- Secondly, the act of writing does not necessarily have to conform to the order that the text should have for the compiler to understand it, but rather it is expected to follow the developer's reasoning.

To quote Donald Knuth, who was the first to conceive of this approach,

#+begin_quote
The WEB language allows a person to express programs in a "stream of consciousness" order. TANGLE is able to scramble everything up into the arrangement that a PASCAL compiler demands. This feature of WEB is perhaps its greatest asset; it makes a WEB-written program much more readable than the same program written purely in PASCAL, even if the latter program is well commented. And the fact that there's no need to be hung up on the question of top-down versus bottom-up, since a programmer can now view a large program as a web, to be explored in a psychologically correct order is perhaps the greatest lesson I have learned from my recent experiences.

– Donald Knuth ([[https://academic.oup.com/comjnl/article/27/2/97/343244?login=false][Literate Programming, 1984]])
#+end_quote

To generate the compilable, it is sufficient to call the blocks in the right order with very easy-to-create and easy-to-manage macros, all within the same file. After naming a block of code with its own name, for example =patate=, using the /noweb/ syntax it is sufficient to write =<<patate>>= in another block to see it reappear in the right place.

I don't mean this is the best way to code always. Often it's better to stick to clear and concise code. But sometimes, /weaving/ a few extra characters ahead of time can make processing a lot smoother in the long run. This is especially true with infrequently modified configuration files.

By doing so, it can be easier to explain code to folks. Moreover, there is nothing to prevent writing the more self-evident parts in a classical way and extensively commenting only the small notable pieces. Literate programming extends the freedoms of intervention on the text without imposing limitations in any way, except for adding layers of abstraction that the developer must learn to manage.

The tools of literate programming can be useful to any developer, but they can also become the nucleus of a new way of conceiving programming.

#+begin_quote
Let us change our traditional attitude to the construction of programs: Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.

*The practitioner of literate programming can be regarded as an essayist*, whose main concern is with exposition and excellence of style. Such an author, with thesaurus in hand, chooses the names of variables carefully and explains what each variable means. He or she strives for a program that is comprehensible because its concepts have been introduced in an order that is best for human understanding, using a mixture of formal and informal methods that reinforce each other.

– Donald Knuth
#+end_quote

For those who seek a deeper dive, behold I leave some additional readings:
- [[https://www.cs.upc.edu/~eipec/pdf/p583-van_wyk.pdf][Communication of the ACM, 1987]]
- [[https://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][Literate programming in org-mode]]

* Literate configuration
How can we make the Emacs configuration /literate/?
# As the winds of Emacs blow, one can refine the art of configuring it, much like a master observes and learns from the tricks of others.

First, we need to know the usual configuration of Emacs.
Traditionally, Emacs expects the configuration to be all contained in =.emacs=, so the approach is very simple and straightforward.
# TODO: eltweet import as org shortcode
# @@html:<blockquote class="twitter-tweet"><p lang="en" dir="ltr">OH: I now officially work with people younger than my .emacs file</p>&mdash; â¨ Phil CalÃ§ado (@pcalcado) <a href="https://twitter.com/pcalcado/status/871810979180556292?ref_src=twsrc%5Etfw">June 5, 2017</a></blockquote>@@

Distributions instead provide for a hierarchy of contents in different files.
Doom Emacs, for example, collects the configuration in three fundamental files:
- =config.el=;
- =init.el=;
- =packages.el=.

These are contained in a special directory in the home directory, =.doom.d=.
Other distributions have more chaotic or more layered hierarchies (e.g. Spacemacs with its layers).

In my opinion, Doom maintains a pleasant middle ground.

Instead of directly modifying these files, we can write our configuration in an =.org= file, from which we can then generate the 3 main configuration files. This practice is based on the principles of literate programming, a paradigm first proposed by Donald Knuth, who demonstrated its potential by writing the TeX compiler in this way.

The art of configuring Emacs (like many others) is refined by studying the tricks of others.
Interesting literary configurations: [[https://gitlab.com/zzamboni/dot-doom][Zamboni's]] and [[https://git.tecosaur.net/tec/emacs-config][Tecosaur's]].

# Grazie ad org-mode è possibile abbracciare il literate programming per mezzo di una libreria detta "babel".
# [[https://blog.thomasheartman.com/posts/configuring-emacs-with-org-mode-and-literate-programming][Come scrive Thomas Heartman sul suo blog]], nelle versioni più recenti di Emacs bastano poche righe di codice per incorporare in org-mode la propria configurazione, grazie ad una funzione speciale di org-babel che supporta proprio questo scopo (sempre più diffuso nella comunità di utenti).

** Frontmatters
# Translate the following line from italian to english:
# Cominciamo dalla testa dei nostri file di configurazione, cioè da tutti i commenti che troviamo di norma nelle prime 10-20 righe. C'è solo una modifica che è il caso di fare in questo punto: aggiungere un piccolo commento che ricordi all'eventuale lettore che il file in uscita è un file generato e che non va modificato direttamente.
Let's start from the head of our configuration files, that is, from all the comments that we usually find in the first 10-20 lines. There is only one modification that needs to be made at this point: adding a small comment that reminds the potential reader that the output file is a generated file and should not be directly modified.

# Aggiungere questo pezzo con una macro:

#+name: do-not-edit
#+begin_src emacs-lisp
;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; https://github.com/gicrisf/emacs-config
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)
#+end_src


# Frontespizio di =init.el=.
Frontmatter of =init.el=.

#+begin_src emacs-lisp :tangle init.el :noweb no-export
;;; init.el -*- lexical-binding: t; -*-

<<do-not-edit>>

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a "Module Index" link where you'll find
;;      a comprehensive list of Doom's modules and what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).
#+end_src

# Frontespizio di =packages.el=.
Frontmatter of =packages.el=.

#+begin_src emacs-lisp :tangle packages.el :noweb no-export
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

<<do-not-edit>>

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or
;; use 'M-x doom/reload'.


;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;(package! some-package)
#+end_src

# Frontespizio di =config.el=.
Frontmatter of =config.el=.

#+begin_src emacs-lisp :tangle config.el :noweb no-export
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

<<do-not-edit>>

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!


;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
#+end_src

** Doom modules
Every time Doom Emacs is started, the following code is evaluated for adding or deleting eventually edited packages.
# Il codice seguente è impiegato da Doom Emacs per capire quali moduli installare e lanciare tutte le volte che viene avviato.
# Ogni modifica a questo livello richiede =doom/sync=.

#+name: init.el
#+attr_html: :collapsed t
#+begin_src emacs-lisp :tangle init.el :noweb no-export
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :input
       <<doom-input>>

       :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

As you can see, this part basically consists of a simple list of modules.
# Si tratta di uno dei tratti più leggibili in assoluto, visto che, appunto, è una lista di moduli.
# Lo riporto qui senza modifiche particolari.

*** Input
#+name: doom-input
#+begin_src emacs-lisp
;;chinese
;;japanese
;;layout            ; auie,ctsrnm is the superior home row
#+end_src

*** Completion
#+name: doom-completion
#+begin_src emacs-lisp
company           ; the ultimate code completion backend
;;helm              ; the *other* search engine for love and life
;;ido               ; the other *other* search engine...
ivy               ; a search engine for love and life
#+end_src

*** UI
#+name: doom-ui
#+begin_src emacs-lisp
;;deft              ; notational velocity for Emacs
doom              ; what makes DOOM look the way it does
doom-dashboard    ; a nifty splash screen for Emacs
doom-quit         ; DOOM quit-message prompts when you quit Emacs
(emoji +unicode)  ; 🙂
hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
;;hydra
;;indent-guides     ; highlighted indent columns
;;ligatures         ; ligatures and symbols to make your code pretty again
;;minimap           ; show a map of the code on the side
modeline          ; snazzy, Atom-inspired modeline, plus API
;;nav-flash         ; blink cursor line after big motions
neotree           ; a project drawer, like NERDTree for vim
ophints           ; highlight the region an operation acts on
(popup +defaults)   ; tame sudden yet inevitable temporary windows
;;tabs              ; a tab bar for Emacs
;;treemacs          ; a project drawer, like neotree but cooler
;;unicode           ; extended unicode support for various languages
vc-gutter         ; vcs diff in the fringe
vi-tilde-fringe   ; fringe tildes to mark beyond EOB
;;window-select     ; visually switch windows
workspaces        ; tab emulation, persistence & separate workspaces
zen               ; distraction-free coding or writing
#+end_src

*** Editor
#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere); come to the dark side, we have cookies
file-templates    ; auto-snippets for empty files
fold              ; (nigh) universal code folding
;;(format +onsave)  ; automated prettiness
;;god               ; run Emacs commands without modifier keys
;;lispy             ; vim for lisp, for people who don't like vim
multiple-cursors  ; editing in many places at once
;;objed             ; text object editing for the innocent
;;parinfer          ; turn lisp into python, sort of
;;rotate-text       ; cycle region at point between text candidates
snippets          ; my elves. They type so I don't have to
;;word-wrap         ; soft wrapping with language-aware indent
#+end_src

# **** Cursori multipli
About multiple cursors: just run the =g z z= sequence to spawn a new cursor on place.
# Basta usare =g z z= come shortcut sequenziale per avviare un altro cursore sul posto.

*** Emacs
#+name: doom-emacs
#+begin_src emacs-lisp
dired             ; making dired pretty [functional]
electric          ; smarter, keyword-based electric-indent
;;ibuffer         ; interactive buffer management
undo              ; persistent, smarter undo for your inevitable mistakes
vc                ; version-control and Emacs, sitting in a tree
#+end_src

*** Term
#+name: doom-term
#+begin_src emacs-lisp
;;eshell            ; the elisp shell that works everywhere
;;shell             ; simple shell REPL for Emacs
;;term              ; basic terminal emulator for Emacs
vterm               ; the best terminal emulation in Emacs
#+end_src

*** Checkers
#+name: doom-checkers
#+begin_src emacs-lisp
syntax              ; tasing you for every semicolon you forget
;;(spell +flyspell) ; tasing you for misspelling mispelling
;;grammar           ; tasing grammar mistake every you make
#+end_src

*** Tools
#+name: doom-tools
#+begin_src emacs-lisp
;;ansible
;;debugger          ; FIXME stepping through code, to help you add bugs
;;direnv
;;docker
;;editorconfig      ; let someone else argue about tabs vs spaces
;;ein               ; tame Jupyter notebooks with emacs
(eval +overlay)     ; run code, run (also, repls)
;;gist              ; interacting with github gists
lookup              ; navigate your code and its documentation
lsp               ; M-x vscode
magit             ; a git porcelain for Emacs
;;make              ; run make tasks from Emacs
;;pass              ; password manager for nerds
;;pdf               ; pdf enhancements
;;prodigy           ; FIXME managing external services & code builders
;;rgb               ; creating color strings
;;taskrunner        ; taskrunner for all your projects
;;terraform         ; infrastructure as code
;;tmux              ; an API for interacting with tmux
;;upload            ; map local to remote projects via ssh/ftp
#+end_src

*** OS
#+name: doom-os
#+begin_src emacs-lisp
(:if IS-MAC macos)  ; improve compatibility with macOS
;;tty               ; improve the terminal Emacs experience
#+end_src

*** Lang

#+name: doom-lang
#+begin_src emacs-lisp
;;agda              ; types of types of types of types...
;;beancount         ; mind the GAAP
;;cc                ; C > C++ == 1
;;clojure           ; java with a lisp
;;common-lisp       ; if you've seen one lisp, you've seen them all
;;coq               ; proofs-as-programs
;;crystal           ; ruby at the speed of c
;;csharp            ; unity, .NET, and mono shenanigans
;;data              ; config/data formats
;;(dart +flutter)   ; paint ui and not much else
;;elixir            ; erlang done right
elm               ; care for a cup of TEA?
emacs-lisp        ; drown in parentheses
;;erlang            ; an elegant language for a more civilized age
;;ess               ; emacs speaks statistics
;;factor
;;faust             ; dsp, but you get to keep your soul
;;fsharp            ; ML stands for Microsoft's Language
;;fstar             ; (dependent) types and (monadic) effects and Z3
;;gdscript          ; the language you waited for
;;(go +lsp)         ; the hipster dialect
;;(haskell +dante)  ; a language that's lazier than I am
;;hy                ; readability of scheme w/ speed of python
;;idris             ; a language you can depend on
;;json              ; At least it ain't XML
;;(java +meghanada) ; the poster child for carpal tunnel syndrome
javascript        ; all(hope(abandon(ye(who(enter(here))))))
;;julia             ; a better, faster MATLAB
;;kotlin            ; a better, slicker Java(Script)
latex             ; writing papers in Emacs has never been so fun
;;lean              ; for folks with too much to prove
;;ledger            ; be audit you can be
;;lua               ; one-based indices? one-based indices
markdown          ; writing docs for people to ignore
;;nim               ; python + lisp at the speed of c
;;nix               ; I hereby declare "nix geht mehr!"
;;ocaml             ; an objective camel
(org +roam2)               ; organize your plain life in plain text
;;php               ; perl's insecure younger brother
;;plantuml          ; diagrams for confusing people more
;;purescript        ; javascript, but functional
python            ; beautiful is better than ugly
;;qt                ; the 'cutest' gui framework ever
;;racket            ; a DSL for DSLs
;;raku              ; the artist formerly known as perl6
;;rest              ; Emacs as a REST client
;;rst               ; ReST in peace
;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
(rust +lsp)              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala             ; java, but good
;;(scheme +guile)   ; a fully conniving family of lisps
sh                  ; she sells {ba,z,fi}sh shells on the C xor
;;sml
;;solidity          ; do you need a blockchain? No.
;;swift             ; who asked for emoji variables?
;;terra             ; Earth and Moon in alignment for performance.
web               ; the tubes
yaml              ; JSON, but readable
;;zig               ; C, but simpler
#+end_src

*** Mail
Per il momento, non uso Emacs per le mie email.
[[https://www.zwitterio.it/software/mutt/][Una volta ho provato a gestire tutto da CLI]], anche con buoni risultati, ma a causa di problemi di vario genere alla fine ho deciso che era meglio tornare alla web-app.
Non tanto perché sia una cattiva idea, quanto piuttosto perché è un inferno con tutto l'HTML pazzo che mettono in mezzo al testo, cosa che si può risolvere leggendo le mail con lynx o altri browser testuali, ma in fin dei conti dà l'impressione di stare sistematicamente forzando il mezzo. Usare il solito browser (coi dovuti accorgimenti) mi sembra la scelta più efficace.
Ecco perché non uso mu4e, sebbene l'idea mi tenti di tanto in tanto.

#+name: doom-email
#+begin_src emacs-lisp
;;(mu4e +gmail)
;;notmuch
;;(wanderlust +gmail)
#+end_src

Ed ecco che la tentazione ritorna: TODO, [[https://shom.dev/posts/20220108_setting-up-protonmail-in-emacs/][sincronizzare con protonmail]].

*** App
Uso Emacs come RSS reader.

#+name: doom-app
#+begin_src emacs-lisp
;;calendar
;;emms
;;everywhere        ; *leave* Emacs!? You must be joking
;;irc               ; how neckbeards socialize
(rss +org)        ; emacs as an RSS reader
;;twitter           ; twitter client https://twitter.com/vnought
#+end_src

*** Config
# Questa è una literate configuration, quindi mi pare il caso di abilitare il modulo relativo.
This is a literate configuration, so it looks reasonable to enable the relative module.

#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

** Package!
# Chiaramente, non tutti i pacchetti disponibili per emacs sono stati integrati in moduli di Doom, quindi alcuni andranno installati per altre vie, ad esempio MELPA o delle repository git.
Clearly, not every package in Emacs are molded as Doom Emacs modules: it would be crazy. Many of them are to be installed via MELPA or git repositories.
Like before, I keep original comments of =packages.el= here, but the file will be populated in the next part, side by side with the relative package configuration.

# Manteniamo i commenti originali di =packages.el= all'interno del file.

*** Recipe
#+name: packages-recipe
#+begin_src emacs-lisp :tangle packages.el
;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/raxod502/straight.el#the-recipe-format
;(package! another-package
;  :recipe (:host github :repo "username/repo"))
#+end_src

*** Files
#+name: packages-files
#+begin_src emacs-lisp :tangle packages.el
;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;(package! this-package
;  :recipe (:host github :repo "username/repo"
;           :files ("some-file.el" "src/lisp/*.el")))
#+end_src

*** Disable
#+name: packages-disable
#+begin_src emacs-lisp :tangle packages.el
;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;(package! builtin-package :disable t)
#+end_src

*** Override
#+name: packages-override
#+begin_src emacs-lisp :tangle packages.el
;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;(package! builtin-package :recipe (:nonrecursive t))
;(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

*** Branch
#+name: packages-branch
#+begin_src emacs-lisp :tangle packages.el
;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see raxod502/straight.el#279)
;(package! builtin-package :recipe (:branch "develop"))
#+end_src

*** Pin
#+name: packages-pin
#+begin_src emacs-lisp :tangle packages.el
;; Use `:pin' to specify a particular commit to install.
;(package! builtin-package :pin "1a2b3c4d5e")
#+end_src

*** Unpin
#+name: packages-unpin
#+begin_src emacs-lisp :tangle packages.el
;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;(unpin! pinned-package)
;; ...or multiple packages
;(unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;(unpin! t)
#+end_src

** Configuration
In the end, we get to the actual configuration.

#+begin_quote
*Keep in mind that not every part is translated into English*.
Since Italian is my mother language, I sometimes write sections in Italian and publish them as is. It may take some time before I can translate everything into English.
#+end_quote

*** Who am I?
# *** Chi sono?
Hi there, I am Giovanni Crisalfi.

#+begin_src emacs-lisp :tangle config.el
;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
(setq user-full-name "gicrisf"
      user-mail-address "giovanni.crisalfi@protonmail.com")
#+end_src

*** Emacs as Daemon
:PROPERTIES:
:EXPORT_HUGO_SECTION: software/emacs-as-daemon
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2023-04-05 mer]
:END:

Running Emacs as a daemon allows you to start Emacs once and then use it in multiple sessions or on different terminals without the overhead of starting up Emacs anew each time.
This translates to faster startup times and more efficient use of system resources.

{{{more}}}

# Si tratta di una possibilità introdotta con Emacs 23.1 per ridurre i (già bassi) tempi di avvio di ogni finestra. Ottimo se, come me, utilizzate Emacs anche per modificare piccoli file di testo per cui andrebbe benissimo vim o nano.
This is a feature introduced with Emacs 23.1 to reduce the (already low) startup times of each window. It's great if, like me, you also use Emacs to edit small text files for which vim or nano would be just fine.

Launching the daemon is simple as running a simple command:

#+begin_src bash
emacs --daemon
#+end_src

# Per lanciarlo all'avvio, si può aggiungere il comando qui sopra nella sezione opportuna fornita dal DE o, meglio ancora, perdere mezzo minuto per impostare systemd (utile soprattutto per chi usa un tiling manager anziché un DE "fatto e finito").
To launch it at startup, you can add the above command in the appropriate section provided by your DE, or better yet, spend half a minute setting up systemd (especially useful for those who use a tiling manager instead of a "ready-made" DE).

#+begin_src :tangle tangled/.config/systemd/user/emacs.service
[Unit]
Description=Emacs text editor
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=/usr/bin/emacs --daemon
ExecStop=/usr/bin/emacsclient --eval "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=on-failure

[Install]
WantedBy=default.target
#+end_src

Systemd needs you to enable and start the process:

#+begin_src bash
systemctl enable --user emacs
systemctl start --user emacs
#+end_src

# Ovviamente non mi sono inventato nulla, sto solo riprendendo la [[https://www.emacswiki.org/emacs/EmacsAsDaemon][documentazione]]. L'approccio qui sopra non funziona se usate CentOS o, chiaramente, se non usate [[https://wiki.archlinux.org/title/Systemd][systemd]]. Ma, solitamente, chi non usa systemd non ha bisogno che glielo dica io, perché se l'è andata a cercare.
Obviously I'm not making anything up, I'm just referring to the [[https://www.emacswiki.org/emacs/EmacsAsDaemon][documentation]]. The approach above doesn't work if you use CentOS or, clearly, if you don't use [[https://wiki.archlinux.org/title/Systemd][systemd]]. But usually, those who don't use systemd don't need me to tell them that, because they went looking for it themselves.

# Fatto ciò, non è sufficiente avviare Emacs con il consueto comando =emacs=, perché quello continuerebbe ad avviare un'istanza per ogni finestra.
# È necessario specificare che vogliamo solo [[https://www.emacswiki.org/emacs/EmacsClient][lanciare un client]].
# After doing this, it is not enough to start Emacs with the usual command "emacs", because that would still start an instance for each window. It is necessary to specify that we only want to launch a client.

To launch Emacs as a client instead of starting a new instance for each window, specifying a special =emacsclient= command (instead of just =emacs=) is necessary.
# Al posto di =emacs=, scriveremo:

#+begin_src bash
emacsclient --create-frame --alternate-editor=""
#+end_src

# Chiaramente, scrivere di volta in volta questo comando è a dir poco noioso, quindi ci conviene aggiungere degli alias su =.bashrc= o lanciarlo con una scorciatoia da tastiera, a seconda del nostro ambiente.
Writing this command everytime is boring, so it would be best to add some aliases to =.bashrc= or launch it with a keyboard shortcut, depending on our environment.

*** Environment variables on Emacs
:PROPERTIES:
:EXPORT_HUGO_SECTION: software/environment-variables-on-emacs
:EXPORT_FILE_NAME: index.en.md
:EXPORT_DATE: [2023-04-04 mar]
:END:

An environment variable is a key-value pair that is declared and stored in the operating system. They can be referenced by different programs or scripts running on the same system.
Clearly, the program must have access to the environment to use the variable: that's the whole point of *environment* variables.

{{{more}}}

Traditional examples of environment variables include =PATH=, =HOME=, and =USER=.

In most linux distributions, you can launch an =echo= command like this to check your =HOME= var:

#+begin_src bash :exports value :wrap SRC
echo $HOME
#+end_src

In my case, that's the result.

#+RESULTS:
#+begin_SRC
/home/cromo
#+end_SRC

Maybe, you need a different environment variable ("env var" from now on).
How do you set it?

**** The traditional approach
If you have bash as a shell, you can simply set it the traditional way:

#+begin_src bash
#~/.bashrc
export VARNAME="var string"
#+end_src

Maybe, you need the said env var *inside Emacs*, because a package requires it.
Emacs has you covered, since emacs-lisp has a function to access env vars.

#+begin_src emacs-lisp
(getenv "VARNAME")
#+end_src

I used to to export my env vars from =.bashrc= like showed above and it was fine, especially if the variables didn't require extra caution (it's the case of a token you use for running a bot, for example). In most cases, you should be fine with a similar setup.
But most cases are not "all cases" and I encountered the problematic case.
Was I surprised? Of course not, it's never so simple.

**** The problem with the daemon
If you run Emacs from a Daemon, your =getenv= functions start returning =nil=.
Why's that?

To answer this question, we need to understand how processes are managed in a typical Linux system.
The following diagram represents a high-level overview of the architecture of an operating system.

#+begin_comment d2
hardware: Hardware {
  # CPU
  # Memory
  # Devices
  os: OS/Kernel space {
    user: User space {
      direction: right

      shell: Shell {
        utilities: Utilities, shared libraries
        programs: User programs

        programs -> utilities -> programs
      }
      init: systemd
      daemons: Daemons, servers, glibc, other applications

      init -> shell: starts and supervises
      init -> daemons: starts and supervises
      daemons -> shell.programs -> daemons
    }
  }
}
#+end_comment

#+Caption: This diagram shows the hardware layer (CPU, memory, and devices are implicit) and the software layer on top, which includes the OS/kernel space and the user space. The image was made with D2. Released by Giovanni Crisalfi under CC BY-NC-SA.
[[file:os-overview.png]]

Within the user space, there are various components such as the shell (which includes utilities and user programs), systemd (which starts and supervises the shell and daemons), daemons (servers and other applications), and shared libraries.

#+begin_comment d2 :file user-space-emacs-daemon-diagram.png
user: User space {
  direction: right

  shell: Shell {
    utilities: Utilities, shared libraries

    envvars: Env vars are here! {
      shape: stored_data
      style: {
        font-color: white
        font-size: 28
        fill: red
      }
    }

    programs: User programs
    programs -> utilities -> programs

    # emacsf: Emacs frame
  }
  init: systemd
  daemons: Daemons {
    emacs: Emacs daemon {
      style: {
        fill: "#41208b"
        font-color: white
        font-size: 28
        stroke: "#6045a1"
        stroke-width: 5
      }
    }
  }

  # daemons.emacs -> shell.emacsf -> daemons.emacs

  servers: Servers
  glibc: GNU C library
  apps: other applications

  init -> servers
  init -> glibc
  init -> apps
  init -> shell
  init -> daemons

  servers -> shell -> servers
  glibc -> shell -> glibc
  apps -> shell -> apps

  daemons -> shell.programs -> daemons
}
#+end_comment

#+Caption: This diagram shows the relationships between the components inside the user space (for example, how systemd supervises both the shell and daemons). The image was made with D2. Released by Giovanni Crisalfi under CC BY-NC-SA.
[[file:user-space.png]]

By focusing on the user space, we can observe that *Emacs is not running within the shell and therefore does not have access to the environment variables*. However, if Emacs is launched from the terminal emulator, the =getenv= command will work again.
# When setting up the Emacs daemon, it is launched *directly* by systemd.

So, how can you maintain the daemon while not giving up on environment variables?
As for every technical problem, there are a lot of ways to solve it.
It depends on the case what is the most appropriate solution.

**** The "Emacs as OS" approach
# Questo ed i prossimi due paragrafi sono stati pubblicati per la prima volta il 2022.03.16
Xahlee solved the problem in the most emacs-y way possible: [[http://xahlee.info/emacs/emacs/emacs_env_var_paths.html][setting everything from inside Emacs]]. He must have thought "why should I ever leave Emacs?". That's the classical thought process of any emacser, so it shouldn't surprise anybody.

Emacs let you set environment variables with =setenv=.

#+begin_src emacs-lisp
(setenv "VARNAME" "var string")
#+end_src

I was searching for something different, since I have other scripts that run outside of Emacs and they need access to env vars too. I could duplicate the env vars, but I refuse: it feels hacky and it's difficult to maintain.

**** The Systemd approach
A member of the Arch community "[[https://bbs.archlinux.org/viewtopic.php?id=163436][found a good way to export environment variables using systemctl so that they are available to systemd spawned processes]]". This could be exactly what I was looking for, but I don't like the idea of converting the other scripts and messing with systemd, so I kept looking for a different solution.

**** The diffy approach
In my quest for a balanced way to manage this problem, I found [[https://unix.stackexchange.com/a/285257][an interesting answer on unix stackexchange]] that links a [[https://gist.github.com/ffevotte/9345586][gist]] which presents a

#+begin_quote
nice piece of Emacs lisp that uses diff to compare outputs of export command before and after sourcing, and then calls setenv function accordingly.
#+end_quote

The idea is to maintain a shell file as a source and getting the environment variables from there, while diffing it with the ones that are loaded already:

#+begin_src emacs-lisp
(defun source (filename)
  "Update environment variables from a shell source file."
  (interactive "fSource file: ")

  (message "Sourcing environment from `%s'..." filename)
  (with-temp-buffer

    (shell-command (format "diff -u <(true; export) <(source %s; export)" filename) '(4))

    (let ((envvar-re "declare -x \\([^=]+\\)=\\(.*\\)$"))
      ;; Remove environment variables
      (while (search-forward-regexp (concat "^-" envvar-re) nil t)
        (let ((var (match-string 1)))
          (message "%s" (prin1-to-string `(setenv ,var nil)))
          (setenv var nil)))

      ;; Update environment variables
      (goto-char (point-min))
      (while (search-forward-regexp (concat "^+" envvar-re) nil t)
        (let ((var (match-string 1))
              (value (read (match-string 2))))
          (message "%s" (prin1-to-string `(setenv ,var ,value)))
          (setenv var value)))))
  (message "Sourcing environment from `%s'... done." filename))
#+end_src

I think it's kind of an overenginereed solution, but I like the spirit of leaving the source of variables *outside* Emacs and accessible to the shell. So, I came out with a simpler method that works for me.

# In 2022-03-16 I wrote:
# "Now I must do other things in my life, but I promise that I will update this post soon, hopefully with a reasonable and elegant solution. Better: with a working solution. A working solution would be just fine."
# Well, now I'm fucking back

**** The lispy approach
# As it was rightly explored in [[https://github.com/syl20bnr/spacemacs/issues/12451][this Spacemacs' Github issue]], if you load Emacs as Daemon, it doesn't have any access to your usual environment variables.
If you keep the environment variables in a single "lisp-y" file (I mean a valid lisp list stored as simple text), it's possible to import the values both in Emacs and in Bash with a minimal effort. I present an example of such text here below:

#+begin_src lisp
'(("EXAMPLE_OF_KEY" "example-of-pwd")
  ("ANOTHER_EXAMPLE_OF_KEY" "another-example-of-pwd"))
#+end_src

# Assicuriamoci che le variabili d'ambiente siano correttamente importate.
# Nel mio caso, le variabili sono innanzitutto conservate in un piccolo file, da cui poi vengono riportate sia nella shell che qui su Emacs.
# Come possiamo importarle?

# Su Emacs, la funzione per creare una variabile d'ambiente è =setenv=, così come quella per leggere una variabile d'ambiente è =getenv=.
# Molto semplice. Allora noi prendiamo questa lista ed applichiamo =setenv= ad ogni elemento.

# Let's make sure that the environment variables are correctly imported.
Now, how can we import them in Emacs?

As we saw before, the function to create an environment variable is =setenv=, just as the function to read an environment variable is =getenv=. Very simple.
So, we take the list in the file and apply =setenv= to each element.

Since applying a function to every element in a list is what functional programmers call "mapping", we can rephrase by saying that we need to map the list.

# I made this one to watch how to remember how one should use a map function, in order to personally write the next example
# Here's an example Emacs Lisp function that maps a list of cons cells against another function:

#+begin_comment emacs-lisp
(defun mapcons (fn lst)
  "Apply FN to each element of LST, which is a list of cons cells."
  (mapcar (lambda (cons-cell)
            (cons (funcall fn (car cons-cell))
                  (funcall fn (cdr cons-cell))))
          lst))
#+end_comment

# This function takes two arguments: =fn=, which is the function that should be applied to each element of the cons cell; and =lst=, which is the list of cons cells to be mapped over. The =mapcar= function applies the anonymous lambda function provided to each element of the list, using =funcall= to call the =fn= function on both the =car= and =cdr= of each cons cell. The result is a new list of cons cells, with the original contents mapped to the result of applying =fn=.

In the next example, the previous list is called =example-list-of-api-keys=; a =mapc= function call is called on it, and every =cons-cell= in the list has its car bound as the key of the environment variable, while its cdr is bound as its value.

#+begin_src emacs-lisp
;; List of `cons-cells` to bind to shell variables.
(setq example-list-of-api-keys
      '(("EXAMPLE_OF_KEY" "example-of-pwd")
        ("ANOTHER_EXAMPLE_OF_KEY" "another-example-of-pwd")))

;; Binds the contents of the `cdr` branch of each `cons-cell`
;; in `example-list-of-api-keys` as environment variables,
;; using the `car` branch as the variable name.
(mapc (lambda (cons-cell)
        (setenv (car cons-cell) (car (cdr cons-cell))))
      example-list-of-api-keys)
#+end_src

From the example to the reality: we now need a function to retrieve the variables from the file. Since the content of the file should be a valid lisp string, we better evaluate it directly with this function.

#+begin_src emacs-lisp :tangle config.el
;; Thanks to
;; https://stackoverflow.com/a/30568768
(defun eval-file (file)
  "Execute FILE and return the result of the last expression."
  (load-file file)
  (with-temp-buffer
    (insert-file-contents file)
    (emacs-lisp-mode)
    (goto-char (point-max))
    (backward-sexp)
    (eval (sexp-at-point))))
#+end_src

# Adesso carichiamo le variabili vere e proprie.
# Now, this is how we could actually load the secret env vars in =./envvars= file.
#+begin_comment emacs-lisp
;; Set the actual env vars with the function used in the example above
(mapc (lambda (cons-cell)
        (setenv (car cons-cell) (car (cdr cons-cell)))) (eval-file "~/.envvars"))
#+end_comment

# Instead of leaving all condensed in a single =mapc=, naming the process under a single function it's useful because it's better to hooks it at Emacs' startup.
Moreover, we can decouple the file path in a proper variable, which makes everything more readable and editable in the long run.

Finally, we create:
- a variable that stores the path of the file with the env vars
- a function that executes all the needed steps
# - a hook that runs the function on startup

Then, we run it right away.

#+begin_src emacs-lisp :tangle config.el
;; This file could be placed anywhere
(setq env-vars-file-path "~/.envvars")

(defun load-env-vars ()
  (let ((env-var-list (eval-file env-vars-file-path)))
    (mapc (lambda (cons-cell)
            (setenv (car cons-cell) (car (cdr cons-cell)))) env-var-list)))

(load-env-vars)
#+end_src

# As suggested here
# https://emacs.stackexchange.com/a/15099/39328
# (add-hook 'after-init-hook #'load-env-vars)

**** Back in Bash
How to print strings in a file with emacs lisp?

You can use the =write-region= function to write a string to a file in Emacs Lisp. Here's an example:

#+begin_src emacs-lisp
(with-temp-file "filename.txt"
  (insert "Hello, world!"))
#+end_src

This will create a new file called "filename.txt" in the current directory and write the string "Hello, world!" to it.

#+begin_src emacs-lisp :tangle config.el
(defun bash-load-env-vars ()
  (let* ((env-var-list (eval-file env-vars-file-path))
         (bash-strings (mapcar (lambda (cons-cell)
                                 (concat "export "
                                         (car cons-cell) "="
                                         (concat "'" (car (cdr cons-cell)) "'")))
                               env-var-list)))
    (with-temp-file "~/.bashvars"
      (mapc (lambda (exp_string)
              (insert (concat exp_string "\n"))) bash-strings))))
#+end_src

Now I can call this function from =.bashrc= or similar files to have the desired variable exported in the shell.

#+begin_src bash
# ~/.bashrc

# generate or regenerate .bashvars
emacsclient -e '(bash-load-env-vars)' > /dev/null 2>&1

# load or reload .bashvars
if [ -f ~/.bashvars ]; then
. ~/.bashvars
fi
#+end_src

Since we don't need the output of =bash-load-env-vars=, we redirect it to =/dev/null= ([[https://unix.stackexchange.com/a/459404][like shown here]]).

**** Conclusions
Ultimately, the environment variables are managed by three components:
- Lisp variables are loaded into Emacs by calling the function =load-env-vars()=;
- You can sync the variables stored locally with a password manager (e.g. Bitwarden);
- Bash variables are exported from Emacs by calling the function =bash-export-env-vars()= to a local directory.

#+Caption: The diagram represents a system with three components: "Local storage", "Password manager" and "Emacs". The arrows indicate the flow of data and commands between these components. The image was made with D2. Released by Giovanni Crisalfi under CC BY-NC-SA.
[[file:conclusion.png]]

#+begin_comment d2
direction: right

Comment and explain what this d2 diagram represents:

dir: Local storage {
  lispy: Lispy vars {
    shape: stored_data
  }

  bashy: Bash vars {
    shape: stored_data
  }
}

bitwarden: Password manager {
  shape: cloud
}

emacs: Emacs {
  style: {
    fill: "#41208b"
    font-color: white
    stroke: "#6045a1"
    stroke-width: 5
  }
}

dir.lispy -> emacs: load-env-vars()
bitwarden -> dir.lispy -> bitwarden
emacs -> dir.bashy: bash-export-env-vars()
#+end_comment

Well, we made it.

To the next adventure!

{{{prismcss}}}
{{{prismjs}}}

*** Emacs UI
**** Line numbers
#+begin_src emacs-lisp :tangle config.el
;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type t)
#+end_src

**** Maximize on startup
#+begin_src emacs-lisp :tangle config.el
;; Maximize the window upon startup
;; TODO testing this one
(setq initial-frame-alist '((top . 1) (left . 1) (width . 114) (height . 32)))
#+end_src

**** COMMENT Frame transparency
Transparency in UI can add a visually interesting layer to the design of an application like Emacs.
Transparency can create depth and dimensionality, making the UI feel more immersive and interactive.
Therefore, making transparencies in UI is a cool thing to do.

# Transparency in UI can add a visually interesting layer to the design of an application or website. It can enhance the overall aesthetics by allowing elements to blend together in a subtle and harmonious way. Additionally, transparency can create depth and dimensionality, making the UI feel more immersive and interactive. Overall, transparency can help to elevate the design of a UI and make it more engaging for users.

#+begin_src emacs-lisp :tangle config.el
;; Transparency
(set-frame-parameter (selected-frame)'alpha '(99 . 100))
(add-to-list 'default-frame-alist'(alpha . (99 . 100)))
#+end_src

**** Fonts
Fonts are a core element in a text editor.
Overall, the right font can greatly enhance the user experience.

# Fonts are an important element in a text editor because they affect the visual appearance of text, making it easier for users to read and understand. Different fonts have varying weights, sizes, and styles, which can be used to emphasize certain words, headings, or sections. Additionally, some fonts are designed for specific use cases, such as coding fonts that are optimized for ease of use and readability when coding.

#+begin_src emacs-lisp :tangle config.el
;; Doom exposes five (optional) variables for controlling fonts in Doom. Here
;; are the three important ones:
;;
;; + `doom-font'
;; + `doom-variable-pitch-font'
;; + `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;;
;; They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
;; font string. You generally only need these two:
(setq doom-font (font-spec :family "Noto Sans Mono" :size 16 :weight 'semi-light)
      doom-variable-pitch-font (font-spec :family "sans" :size 16))
#+end_src


# TODO: differenziare tra font laptop e desktop e variare la configurazione esportata in base alla situazione.

Since I use Emacs both on a laptop and a desktop computer, I wish I could export the same configuration with simple variations to adjust it to the different hardware. In this case, just changing the font would be nice. I still hadn't work on this, but I have to.

**** Default theme
First of all, let's select a default theme.
# Innanzitutto, selezioniamo un tema di default.

#+begin_src emacs-lisp :tangle config.el
;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
(setq doom-theme 'doom-city-lights)
#+end_src

I'm loving City Lights right now and [[https://github.com/gicrisf/qute-city-lights][I realized a City Lights theme for qutebrowser]] too because I wanted to keep everything so uniform and polished.
There's just one single thing that makes me annoyed: when I declare a task as DONE in org-mode, not only the "DONE" keyword gets grayed out, but the title too. I should work on this detail.

# Al momento mi trovo bene con city lights: c'è solo una piccolezza che mi irrita parecchio.
# Nel momento in cui dichiaro concluso un task (con "DONE") in org-mode, il tema mi grigia non solo la keyword ma anche il titolo.
# TODO cambiare questo comportamento.

# Alcuni commenti da ricordare:
I leave those default comments here; they're pretty helpful and concise.

#+begin_src emacs-lisp :tangle config.el
;; Here are some additional functions/macros that could help you configure Doom:
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
;; This will open documentation for it, including demos of how they are used.
;;
;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
;; they are implemented.
#+end_src

**** Spacemacs themes
# Sono affezionato ai temi di spacemacs. Uso specialmente quello chiaro, se ho bisogno di sovrailluminare lo schermo.
I'm emotionally attached to the Spacemacs' themes. Sometimes I make use of =spacemacs-light=, usually when the environment is brighter than usual (e.g. I'm trying to read outside on a sunny day).

#+begin_src emacs-lisp :tangle packages.el
(package! spacemacs-theme)
#+end_src

Speaking about other distro themes, I would like to make use of Nano-Emacs' colors, but by the moment it does look harder then it seems. Henrik Lissner, Doom Emacs' creator, said he would have made a specific module for this integration, but of course it's not an immediate priority, so I think I'll wait with hope.
# Mi piacerebbe molto avere a disposizione anche i colori di nano-emacs, ma per il momento sembra sia una cosa più complessa del previsto. Henrik Lissner ha detto un paio di volte che avrebbe intenzione di dedicare un intero modulo a questa integrazione, ma non sembra una priorità.

Reaching a similar result is possible with "Lambda themes" (see below).

**** Lambda themes
From [[https://github.com/Lambda-Emacs/lambda-themes][the README]]:

#+begin_quote
In general the theme aims to use as few highly distinct colors as possible without crossing over into full “monochrome” territory. It also means that the themes use various devices other than foreground face color to capture meaningful differences in text. Different text weights are used throughout, as are subtle differences in background coloring. Colored headlines are largely avoided.
#+end_quote

Installing lambda themes:

#+begin_src emacs-lisp :tangle packages.el
(package! lambda-themes :recipe (:host github :repo "lambda-emacs/lambda-themes"))
#+end_src

**** Catppuccin theme
#+begin_quote
[[https://github.com/catppuccin/catppuccin][Catppuccin]] is a community-driven pastel theme that aims to be the middle ground between low and high contrast themes. It consists of 4 soothing warm flavors with 26 eye-candy colors each, perfect for coding, designing, and much more!
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! catppuccin :recipe (:host github :repo "catppuccin/emacs"))
#+end_src

**** Theme ciclator
# Some day I will write what this is about, but I hope the point is pretty easy to grasp for any lisp enthysiast like you probably are.
This Emacs Lisp code defines a circular list of themes (=quick-switch-themes=) and a function (=toggle-theme=) to switch between these themes with a single command. The function will enable the next theme in the list or disable all themes if the end of the list is reached. It also includes a keybinding (=SPC t t=) to quickly toggle between themes. This code could be useful for anyone who frequently switches between different color themes in Emacs.

#+begin_src emacs-lisp :tangle config.el
;; Theme switcher functions
(defvar quick-switch-themes
  (let ((themes-list (list 'lambda-dark-faded
                           'lambda-dark
                           'lambda-light
                           'lambda-light-faded)))
    (nconc themes-list themes-list))
  "A circular list of themes to keep switching between.
Make sure that the currently enabled theme is at the head of this
list always.

A nil value implies no custom theme should be enabled.")

;; Thanks to narendraj9, user of emacs.stackexchange.com
;; https://emacs.stackexchange.com/questions/24088/make-a-function-to-toggle-themes
;; I just tweaked his code.
(defun toggle-theme ()
  (interactive)
  (if-let* ((next-theme (cadr quick-switch-themes)))
      (progn (when-let* ((current-theme (car quick-switch-themes)))
               (disable-theme (car quick-switch-themes)))
             (load-theme next-theme t)
             (message "Loaded theme: %s" next-theme))
    ;; Always have the dark mode-line theme
    (mapc #'disable-theme (delq 'smart-mode-line-dark custom-enabled-themes)))
  (setq quick-switch-themes (cdr quick-switch-themes)))

(map! :leader
      :desc "Quick toggle theme" "t t" #'toggle-theme)
#+end_src

*** Org-mode
[[https://orgmode.org/][Org-mode]] is a major mode for Emacs that provides a powerful system for organizing and managing information.
Another vague definition, isn't it? It is certainly not a coincidence.
The truth is that org-mode is often described as a markup language, but aspires to a much higher goal.

#+begin_quote
Your life in plain text
#+end_quote

Indeed, Org-mode is an enjoyable and versatile markup language, and for this reason it is often compared with [[https://en.wikipedia.org/wiki/Markdown][Markdown]] or [[https://en.wikipedia.org/wiki/ReStructuredText][reStructuredText]], but thanks to its flexibility and extensibility, it can be employed for a wide range of tasks, from writing notes and lists to managing projects and even creating LaTeX documents.

The strength of org-mode lies in its parser. Thanks to it, Emacs is capable of turning a simple text file into living substance: internally, the parsed data is organized into a hierarchical tree structure that can be navigated and manipulated using various commands and functions provided by org-mode.
In addition to its built-in functionality, org-mode also has a vibrant ecosystem of extensions and plugins that can be used to extend its capabilities.

# recognizing and interpreting a wide variety of structured text and, so, enabling to perform operations like formatting, outlining, and export with great flexibility and precision.
# It allows users to create and organize notes, TODO lists, schedules, and documents using plain text files with a simple markup syntax.
# Org-mode is one of the most beloved major modes in Emacs and one of the best pieces of software I have ever encountered.
# Initially, org-mode may appear to be similar to other markup languages such as Markdown or reStructuredText, given its pleasant syntax. However, org-mode offers far more functionality and capabilities beyond that of a simple markup language.
# A prima vista sembra "solo l'ennesimo linguaggio di markup", come [[https://en.wikipedia.org/wiki/Markdown][Markdown]] o [[https://en.wikipedia.org/wiki/ReStructuredText][reStructuredText]], ma in realtà è molto, molto di più [fn::anche se, bisogna dirlo, se pure fosse un semplice linguaggio di markup ci sarebbe da tenerne in conto, vista la piacevole sintassi].

Just like Emacs, Org-mode needs a lot of working hours to be known and tamed for good.
We can enumerate some common uses here:
- simple notes
- /literate programming/
- planners
- zettelkasten
- scientific writing
- blogging

# Proprio come l'abissale versatilità di Emacs riesce a farsi conoscere solo grazie ad ore ed ore di utilizzo, anche Org-mode ha bisogno di tempo per essere addomesticato; in questo caso, in compenso, è più facile annoverare gli utilizzi più comuni:
# - applicazioni di /literate programming/ (un paradigma di programmazione ideato da Donald Knuth, che è alla base anche di questo documento),
# - scrittura di agende
# - scrittura di zettelkasten
# - stesura di documenti scientifici
# - mantenimento di uno o più blog

# Org-mode, o più semplicemente "Org", può anche essere impiegato per scrivere e gestire nel tempo la propria configurazione di Emacs, cioè un mucchio di codice lisp che con il tempo tende a crescere per adeguarsi quanto più possibile alle necessità dell'utente.

Now we declare in which directory we want most org files to be placed, in such way that Emacs can know where they should be searched for.
# Innanzitutto, dichiariamo in quale directory vogliamo che risiedano la maggior parte dei file org (o almeno quelli usati più di frequente), così che Emacs sappia dove cercarli.

#+begin_src emacs-lisp :tangle config.el
;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(setq org-directory "~/org/")
#+end_src

*** Org downloads
Now we can start configuring Org-mode. I think =org-download= is a killer feature of it, since it gives us a way to easily attach elements to the document without never leaving Emacs.
# Adesso possiamo cominciare ad estendere Org-mode. Una prima killer feature, a mio avviso, è data da =org-download=, che ci consente di appiccicare direttamente degli allegati al file org senza mai abbandonare Emacs, né il documento stesso.

#+begin_src emacs-lisp :tangle packages.el
(package! org-download)
#+end_src

[[https://github.com/doomemacs/doomemacs/issues/3830#issuecomment-679925113][Starting from 2020 August 25]],

#+begin_quote
Org-download-clipboard is bound to =SPC m a p= in org-mode.
#+end_quote

# =org-download-clipboard= è legato a =SPC m a p= [[https://github.com/doomemacs/doomemacs/issues/3830#issuecomment-679925113][dal 25 agosto 2020]] in Doom Emacs.

*** Spaced repetition
**** Org drill
# Una volta usavo Anki, ora mi sono chiesto perché usare una GUI quando posso semplicemente scrivere tutto il necessario.
I occasionally use this package, but I prefer writing my text here, then exporting my cards in Anki, so I mostly do that now.

#+begin_src emacs-lisp :tangle packages.el
(package! org-drill)
#+end_src

**** Anki
#+begin_quote
anki-editor – Emacs minor mode for making Anki cards with Org
#+end_quote

#+begin_src emacs-lisp :tangle packages.el
(package! anki-editor)
#+end_src

In order to make this work, you should install the =anki-connect= Anki plugin too.
# Bisogna ricordare di installare il plugin Anki chiamato "anki-connect", altrimenti non funziona.

*** Org Journal
Install the package.

#+begin_src emacs-lisp :tangle packages.el
(package! org-journal)
#+end_src

Configure the keybindings and some parameters.

#+begin_src emacs-lisp :tangle config.el
;; org journal
;; in ~/.doom.d/+bindings.el
;; From: https://www.rousette.org.uk/archives/doom-emacs-tweaks-org-journal-and-org-super-agenda/
(map! :leader
      (:prefix ("j" . "journal") ;; org-journal bindings
        :desc "Create new journal entry" "j" #'org-journal-new-entry
        :desc "Open previous entry" "p" #'org-journal-open-previous-entry
        :desc "Open next entry" "n" #'org-journal-open-next-entry
        :desc "Search journal" "s" #'org-journal-search-forever))

;; The built-in calendar mode mappings for org-journal
;; conflict with evil bindings
(map!
 (:map calendar-mode-map
   :n "o" #'org-journal-display-entry
   :n "p" #'org-journal-previous-entry
   :n "n" #'org-journal-next-entry
   :n "O" #'org-journal-new-date-entry))

;; Local leader (<SPC m>) bindings for org-journal in calendar-mode
;; I was running out of bindings, and these are used less frequently
;; so it is convenient to have them under the local leader prefix
(map!
 :map (calendar-mode-map)
 :localleader
 "w" #'org-journal-search-calendar-week
 "m" #'org-journal-search-calendar-month
 "y" #'org-journal-search-calendar-year)

(setq org-journal-dir "~/org/amalgam")
(setq org-journal-file-format "%Y-%m.org")
(setq org-journal-file-type 'monthly)
#+end_src

*** Org Web Tools
From [[https://github.com/alphapapa/org-web-tools][the README]]:

#+begin_quote
This file contains library functions and commands useful for retrieving web page content and processing it into Org-mode content.
#+end_quote

To install the package:

#+begin_src emacs-lisp :tangle packages.el
(package! org-web-tools)
#+end_src

*** Org-capture
# Org capture torna comodo per appuntarsi in org-mode frammenti di pagine web.
Org capture is useful for taking notes in org-mode of fragments of web pages

# Come manipolare l'HTML, però, è qualcosa che noi dobbiamo spiegare ad =org-capture=, fornendo uno o più template.
How to manipulate HTML, however, is something that we have to explain to =org-capture=, providing one or more templates.

#+begin_src emacs-lisp :tangle config.el
;; org-capture
(setq org-capture-templates `(
	("p" "Protocol" entry (file+headline ,(concat org-directory "notes.org") "Inbox")
        "* %^{Title}\nSource: %u, %c\n #+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?")
	("L" "Protocol Link" entry (file+headline ,(concat org-directory "notes.org") "Inbox")
        "* %? [[%:link][%:description]] \nCaptured On: %U")
))
#+end_src

# Al fine di usare [[https://github.com/sprig/org-capture-extension][Org capture extension (Firefox)]], dobbiamo anche impostare l'org-protocol.
In order to use [[https://github.com/sprig/org-capture-extension][Org capture extension (Firefox)]], we must also set up org-protocol.

#+begin_quote
The gist of it is to make your system recognize emacsclient as the handler of org-protocol:// links. In addition, one needs to set up emacs to load org-protocol and to set up capture templates.
#+end_quote

# Su linux, bisogna prima registrare questo handler:
On Linux, you must first register this handler:

#+begin_src txt :tangle tangled/.local/share/applications/org-protocol.desktop
[Desktop Entry]
Name=org-protocol
Exec=emacsclient %u
Type=Application
Terminal=false
Categories=System;
MimeType=x-scheme-handler/org-protocol;
#+end_src

# A questo punto, su Gnome ed altri GTK-based Desktop Environments, è sufficiente lanciare questo comando:
At this point, on GNOME and other GTK-based desktop environments, it is sufficient to launch this command:

#+begin_src bash
$ update-desktop-database ~/.local/share/applications/
#+end_src

*** Citations
Install Org-ref:
#+begin_src emacs-lisp :tangle packages.el
(package! org-ref)
#+end_src

Install Citar:
#+begin_src emacs-lisp :tangle packages.el
(package! citar)
#+end_src

Use CSL format files.
Export processor to use format files written in Citation Style Language (=.csl=). This isn't latex-only, so I should be able to use it with Libre Office and HTML too, if needed.

#+begin_src emacs-lisp :tangle packages.el
(package! citeproc)
#+end_src

**** Citing Wikipedia
Get Wikipedia data directly on org-mode.
# Richiama informazioni da Wikipedia direttamente su org.

#+begin_src emacs-lisp :tangle packages.el
(package! wikinforg)
#+end_src

***** COMMENT Italian wikipedia :it:
Spesso mi servono i contenuti in italiano.
L'ideale sarebbe scegliere per ogni query.

#+begin_src emacs-lisp :tangle config.el
;; (custom-set-variables '(wikinforg-wikipedia-edition-code "it"))
#+end_src

Purtroppo, i risultati che ottengo da questa versione sono poco accurati.
Per il momento la disabiliterò.

**** COMMENT Org Bibliography :it:
Tentativo di literate bibliography con org-mode basato su =org-bib-mode=, di Nicolas P. Rougier (il creatore di NANO Emacs).

Innanzitutto devo installare le dipendenze dal suo profilo Github.

# :tangle packages.el
#+begin_src emacs-lisp
(package! org-imenu :recipe (:host github :repo "rougier/org-imenu"))
(package! pdf-drop-mode :recipe (:host github :repo "rougier/pdf-drop-mode"))
(package! org-bib-mode :recipe (:host github :repo "rougier/org-bib-mode"))
#+end_src

Purtroppo, quando utilizzo =require= su =org-imenu= noto che qualcosa non va.
Mi chiedo se il problema sia risolvibile impiegando Nano Emacs, ma non ho tempo per verificare.
Anche se fosse, dubito che abbandonerei Doom Emacs, quindi per ora il tentativo mi pare evitabile.

Lo stesso NPR rimanda ad =org-ref= (di John Kitchin) per chi volesse qualcosa di più elaborato.
Anziché aggrovigliare i due blocchi precedenti, aggroviglio i prossimi.

# :tangle packages.el
#+begin_src emacs-lisp
(package! org-ref :recipe (:host github :repo "jkitchin/org-ref"))
#+end_src

Ora configuriamo org-ref.

# :tangle config.el
#+begin_src emacs-lisp
(setq bibtex-completion-bibliography '("~/org/papers/bibliography.bib"
                                       "~/org/papers/dei.bib"
                                       "~/org/papers/master.bib"
                                       "~/org/papers/archive.bib")
      bibtex-completion-library-path '("~/org/papers/bibtex-pdfs/")
      bibtex-completion-notes-path "~/org/papers/notes/"
      bibtex-completion-notes-template-multiple-files "* ${author-or-editor}, ${title}, ${journal}, (${year}) :${=type=}: \n\nSee [[cite:&${=key=}]]\n"

      bibtex-completion-additional-search-fields '(keywords)
      bibtex-completion-display-formats
      '((article       . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${journal:40}")
        (inbook        . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} Chapter ${chapter:32}")
        (incollection  . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
        (inproceedings . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
        (t             . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*}"))
      bibtex-completion-pdf-open-function
      (lambda (fpath)
        (call-process "open" nil 0 nil fpath)))
#+end_src

Su consiglio di Kitchin, aggiungo queste impostazioni per semplificarmi il lavoro:

# :tangle config.el
#+begin_src emacs-lisp
(require 'bibtex)

(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)

(define-key bibtex-mode-map (kbd "H-b") 'org-ref-bibtex-hydra/body)
#+end_src

Now require it:
# :tangle config.el
#+begin_src emacs-lisp
(require 'org-ref)
#+end_src

Vista la complessità della libreria, ho deciso per il momento di non aggrovigliare nulla e aspettare un momento che mi consenta di studiare meglio ogni impostazione.

*** Org LaTeX export
We add other extensions to logfiles, to let Emacs delete them after exporting the actual tex file; therefore, we have tidier directories.
# Aggiungiamo altre estensioni ai cosiddetti logfile, cosicché Emacs si occupi di eliminarle dopo l'uso in fase di esportazione (e ci lasci, così, la cartella pulita).

#+begin_src emacs-lisp :tangle config.el
(setq org-latex-logfiles-extensions (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl" "xmpi" "run.xml" "bcf")))
#+end_src

*** Org D2 diagrams
I want to generate D2 diagrams without leaving my org-mode files.
Apparently, that's why [[https://github.com/dmacvicar/ob-d2][ob-d2]] (an org-babel exporter for D2) was written.
It's not on MELPA yet, so I'll get it from its GitHub repo.

#+begin_src emacs-lisp :tangle packages.el
(package! ob-d2 :recipe (:host github :repo "dmacvicar/ob-d2"))
#+end_src

Add d2 to =org-babel-load-languages=.

#+begin_src emacs-lisp :tangle config.el
(org-babel-do-load-languages
    'org-babel-load-languages
    '((d2 . t)))
#+end_src

Add d2 to exec-path.

#+begin_src emacs-lisp :tangle config.el
(add-to-list 'exec-path "~/.local/bin/")
#+end_src

Test D2 (d2 requires a ":file" header argument):

#+begin_src d2 :file test.png
# Actors
hans: Hans Niemann

defendants: {
  mc: Magnus Carlsen
  playmagnus: Play Magnus Group
  chesscom: Chess.com
  naka: Hikaru Nakamura

  mc -> playmagnus: Owns majority
  playmagnus <-> chesscom: Merger talks
  chesscom -> naka: Sponsoring
}

# Accusations
hans -> defendants: 'sueing for $100M'

# Offense
defendants.naka -> hans: Accused of cheating on his stream
defendants.mc -> hans: Lost then withdrew with accusations
defendants.chesscom -> hans: 72 page report of cheating
#+end_src

*** Org JSON export
#+begin_src emacs-lisp :tangle packages.el
(package! ox-json)
#+end_src

#+begin_src emacs-lisp :tangle config.el
(require 'ox-json)
#+end_src

*** Org Roam
:PROPERTIES:
:EXPORT_HUGO_SECTION: software/org-roam
:EXPORT_FILE_NAME: index.en.md
:EXPORT_DATE: [2023-04-08 sab]
:END:

# Translate the following line from italian in english:
# Ogni volta che devo prendere un appunto, una domanda torna a pungolarmi: dove scriverlo?
Every time I have to take a note, a question keeps nagging me: where should I write it?

Until this very moment, my approach consisted of me collecting notes in "notebooks", which means I had a folder with a lot of org-mode files, named with some kind of topic. For example, I had a file for Python, a file for Linux, a file for Organic chemistry and so on. But my files kept growing and the themes kept mixing: what if I want to take a note about writing organic molecule in emacs? Should I store it in the "Emacs notebook" or the "Organic chemistry notebook"? Every single time a similar but quite different dilemma.
That's why I searched for a less hierarchized method and I remembered of the zettelkasten method.

**** What is a zettelkasten?
A zettelkasten is a personal knowledge management system popularized by Niklas Luhman, a German sociologist. As the (German) term suggests, it consists of a collection of small notes; the small notes are often called "slips" and each of them must contain a single idea or topic.
The point is that these slips can be organized and linked together in various ways and traditionally they required a lot of paper and storage tools to aid in the retrieval of the informations. Today, the zettelkasten can be totally virtual. Of course, this doesn't exclude the usefulness of the analogical one, we have just more options.

The zettelkasten method comes with a series of rules and peculiarities but, to be honest, I don't think I will follow the zettelkasten method zealously; as I said, I was searching for a less hierarchized tool and that's what I found in Org-roam.

**** What is org-roam?
When it comes to note-taking software, Notion and Obsidian comes to mind. Web-based software is used more and more, but I don't want to live Org-mode, plain text and open-source software.
# Logseq looks like a wonderful project, since it supports org-mode files and is open-source; I'm interested in Logseq too, but we will talk about it later.
# Software web-based sono sempre più usati, ma io non voglio abbandonare org-mode. Logseq fornisce supporto per org-mode, ma si tratta di una versione di org-mode con modifiche che la rendono dipendente dalla piattaforma stessa. Non possono essere lette (così come sono) su Emacs. A quel punto, tanto vale usare una versione modificata di Markdown, la portabilità è uguale, i limiti sono gli stessi.
# Since I like to stay in Emacs as much as I can, I want to talk about Org-roam first.

# What is org-roam?
Org-roam is an Emacs package that leverages Org-mode for note-taking and knowledge management based on the principles of Roam Research.
It allows you to create and link notes in plain text files and provides navigation and search features for exploring your notes graph.

# Are the following lines written in correct english? Verify the grammar and the tone.
Org-roam employ a SQLite3 database to deliver the content faster when you search for it, but the *real* archive it's the plain text one.
This means you can easily synchronize your content across devices and the archive remains extremely resilient, not dependent on any service, not even Emacs itself.
Org-roam seems to provide the tool I was searching for.
# The sentence is grammatically correct and has a positive tone.

# Are the following line written in correct english?
Moreover, Org-roam is a solid piece of software with a large community and has reached a second version, that is the one I will refer to from now on.
# Yes, the given line is written in correct English.

# Essendo il mio primo approccio, sicuramente sto trascurando fattori che emergeranno in seguito, ma mi sembrano buone basi.
# Ho anche letto delle [[https://karl-voit.at/2020/06/14/Zettelkasten-concerns/][critiche]], ad esempio relative al fatto che risulterebbe scomodo mantenere contemporaneamente differenti domini.
**** Installation
The installation is very easy:
- You must have SQLite3 on your system (and you probably already have);
- On Doom Emacs you have to uncomment the =org= module, while adding =roam2= like this: =(org +roam2)=.

**** Basic configuration
Now, the configuration.
# A questo punto, bisogna passare alla configurazione.
# In pratica, grazie a Doom abbiamo già una preconfigurazione, ma dobbiamo comunicare almeno la directory in cui vogliamo tenere i file.

In the following directory, I will keep the plain-text files. I want to be clear about this point: if you have the file, you can always retrieve the full content you wrote.

#+begin_src emacs-lisp :tangle config.el
(setq org-roam-directory "~/Dropbox/roam")
#+end_src

# Ora sorge un altro problema. Come eseguo il backup della mia org roam directory?
# Potrei usare Dropbox, ma odio l'idea che possa darmi problemi per carenza di spazio.
# L'evidente alternativa sarebbe usare git.
I sync everything in my Dropbox by storing the files, not the database.

**** The first note
I use Evil on Doom Emacs, hence the keybinding I use for creating a note is =SPC+n+r+i= (action -> notes -> roam -> insert).
# Non resta che seguire i comandi di Doom Emacs per creare la prima nota: =SPC+n+r+i= per inserire una nota.

The command will leave a link to the note on the underlying buffer. This behaviour can be useful in a lot of situations, for example you can easily chain more notes together.
# Mentre stiamo scrivendo la nota, con la stessa combinazione si può inserire un link ad una nota.
# Questa risulterà connessa alla prima nel buffer.

**** Backlinks
# Explain why backlinks are one of the most relevant strenghts in Org-roam
# Raw output
Backlinks in Org-roam are one of the most relevant strengths because they allow for easy navigation and organization of information. Just by adding a link to another note, all notes that link to it are automatically generated, providing a web of related information. This helps in discovering and exploring relationships between pieces of information, making it easier to create connections and draw meaningful insights. Additionally, backlinks allow for a more flexible and non-linear way of organizing information, as notes can be linked in multiple locations without duplicating them.

**** Web UI
This UI helps exploring the nodes and the backlinks.
# I need a UI to explore the nodes:

#+begin_src emacs-lisp :tangle packages.el
(package! org-roam-ui)
#+end_src

# In questo modo posso vedere i nodi in maniera molto piacevole all'interno del browser.

**** References
# Una delle cose per cui potrei usare lo zettelkasten è memorizzare tweet o toots. Questo sarebbe facilitato dalle API, ma per quanto riguarda Twitter è difficile capire se valga la pena spendere del tempo, visto che hanno già annunciato cambiamenti. I thread sono difficili da immagazzinare tweet per tweet, quindi non se ne parla.

It's better to not mix your own written production with others' written productions. In other words, don't fill your notes with citations.
# Altro punto importante: *non è bene mescolare la propria produzione scritta con le citazioni altrui*.

How to reference others' work, then? I looked at [[https://jethrokuan.github.io/org-roam-guide/][the approach of Jehtro Kuan (org-roam author)]].
# Per organizzare il roam, meglio seguire un approccio simile a [[https://jethrokuan.github.io/org-roam-guide/][quello descritto in questo post da Jehtro Kuan]] (autore di org-roam).

{{{exportedfrom}}}
{{{prismcss}}}
{{{prismjs}}}

*** Emacs Feed Configuration
:PROPERTIES:
:EXPORT_HUGO_SECTION: software/emacs-config-feed
:EXPORT_FILE_NAME: index.en.md
:EXPORT_DATE: [2023-03-13 lun 21:48]
:EXPORT_HUGO_LASTMOD: [2023-03-15]
:END:

People continuously write a viscous, non-local, scattered gargantuan text just by existing on the internet.
Managing how to access this text can be tricky since we need to filter out the noise and focus on the content we need or are curious about. When it comes to text, Emacs is usually well-equipped to improve our life. As we will discover soon in this post, this case makes no exception.

{{{more}}}

To be more accurate, we should distinguish between two parts of the collective text: one we actively compose that is accessible to any of us, and another one, which is generated to track our actions on private platforms and is structured not to be read by humans, but parsed by machines. In this post, we will focus on the first part, the public and human-oriented text, but this (apparently) simple topic has implications that cross over and touch the production of the other text, which the sociologist Shoshana Zuboff usually refers to as /shadow text/.
Indeed, by consciously choosing how to screen our readings, we partially subtract ourselves from the aggressive tracking operated by companies like Google or Meta. To be notified when new content is published online, we can leverage a technology that solved this problem even before the advent of those companies on the scene: RSS feeds. With Elfeed, Emacs is able to read both the RSS and the newer Atom feeds.

#+begin_quote
Elfeed is an extensible web feed reader for Emacs, supporting both Atom and RSS.
#+end_quote

On Doom Emacs, Elfeed is already integrated as a module and can be enabled in the =init.el= file.

By default, Elfeed only needs you to set a simple list to work: as shown below, the list is called =elfeed-feeds= and can easily be typed in the =config.el= file.
# Di default, basta aggiungere gli URL dei feed desiderati in questa lista per avere già Elfeed operativo.

# Not tangling it anymore
# :tangle config.el
#+begin_src emacs-lisp
(setq elfeed-feeds (quote
                    (("https://www.zwitterio.it/rss.xml" stem)
                     ("https://materiaimpersonale.wordpress.com/feed/" lit))))
#+end_src

I don't follow this method anymore, because I find more comfortable to keep my feeds in a specific org file.
# Io non uso più questo metodo perché trovo più comodo tenere i miei feed in un file org-mode separato.

To make elfeed prettier, we can add =elfeed-goodies= to our packages in =packages.el=.
# Per abbellire elfeed, aggiungiamo =elfeed-goodies=.
Particularly, this package adds a cool powerline and changes the layout (panels are split vertically, not horizontally).
# In particolar modo, cambia il layout (apre in un altro pannello verticale, anziché orizzontale) e si guadagna una powerline.

#+begin_src emacs-lisp :tangle packages.el
(package! elfeed-goodies)
#+end_src

This package helps you to customize some aspects if you want to.
For example, here we edit the size of the popup entry pane.

#+begin_src emacs-lisp :tangle config.el
(require 'elfeed-goodies)
(elfeed-goodies/setup)
(setq elfeed-goodies/entry-pane-size 0.5)
#+end_src

Refer to [[https://github.com/jeetelongname/elfeed-goodies][the package README]] for more.

# Ora voglio assicurarmi che elfeed appaia sulla dashboard (vedi sezione dedicata alla dashboard).
You can make a lot of different uses of elfeed: if you just follow some blogs, you probably have no problem with it. Let's say you follow 20, 30, or 50 blogs and you love them all. You want to see every news, but every blog post once a week if it is active. In this case, elfeed is already perfect. It shows you everything in chronological order. But what if you follow sources that publish a lot of content day by day?
For example, let's say you follow the RSS feeds of government agencies or scientific publishers. In that case, you better filter the posts to list the most important things first. A lot of social media platforms do that: they let you see the posts of accounts you interact with the most before any other, then they proceed with others. It doesn't matter that the others are more recent: the point is to maximize the probability you see the stuff you're more interested in, to make you interact and stay on the platform as long as you can. Here we're facing a similar problem: since we all know you're never going to see every single post in your feed, it's fundamental to establish priorities. We will not implement a machine learning model to learn our preference like social media /algorithms/ do, but there's a package that keeps things simple, and let you score the posts by keywords: not surprisingly, it's called =elfeed-score=.

You can see it in action in [[https://emacsconf.org/2021/talks/research/][this interesting Emacs talk, published in 2021]].
Like said by Ahmed Khaled, the author,

#+begin_quote
Elfeed-score enables me to assign a numerical score [...] This numerical score is very simple. It's just based on matching things.
#+end_quote

We're now fully convinced that we need =elfeed-score=, so we proceed to install it:

#+begin_src emacs-lisp :tangle packages.el
(package! elfeed-score)
#+end_src

Arxiv or ChemRxiv feeds are listed in the org file like any other feed.
Now, we have to configure =elfeed-score=. From [[https://www.unwoundstack.com/doc/elfeed-score/curr#The-Score-File][the docs]]:

#+begin_quote
The rules for scoring are written down in the score file, a plain-text file containing a single Lisp form. The location of the score file is defined in =elfeed-score-serde-score-file=.
#+end_quote

By default, the configuration is written in a file named =elfeed.score= in the =.emacs.d= directory:

#+begin_src emacs-lisp :tangle ~/.emacs.d/elfeed.score
;;; Elfeed score file                                     -*- lisp -*-
(("title")
 ("content")
 ("title-or-content"
  (:text "spectroscopy" :title-value 50 :content-value 10 :type s)
  (:text "Alzheimer" :title-value 50 :content-value 10 :type s)
  (:text "small molecule" :title-value 50 :content-value 10 :type s)
  (:text "Peptide" :title-value 50 :content-value 10 :type s)
  (:text "Molecular Dynamics" :title-value 50 :content-value 10 :type s)
  (:text "infrared" :title-value 100 :content-value 10 :type s))
 ("tag")
 ("authors")
 ("feed")
 (mark -600)
 ("adjust-tags"))
#+end_src

Moving towards using regular expressions in the =text= field can minimize matching against unintended targets.
To see regex in action, I suggest looking at [[https://cundy.me/post/elfeed/][this Chris Cundy's blog post]], of which I'm about to give a glimpse below.

#+begin_src emacs-lisp
;; An example of using regexes
;; Source: https://cundy.me/post/elfeed/
;; ...
("title-or-content"
  ("uncertainty" 50 10 s 1597198724.419375)
  (".*[- ]ODE[- s].*" 100 20 R 1596818708.18127))
;; ...
#+end_src

#+begin_quote
So the field (".*[- ]ODE[- s].*" 100 20 R 1596818708.18127) is a case-sensitive (specified by the R) regexp matching against any of " ODEs”, " ODE “, " ODE-", etc. If a match occurs in the title it adds 100 to the score of the entry. If a match occurs in the content field (for us, this is the abstract of the paper) it will add 20 to the score of the entry. The scale is arbitrary, but I’m aiming for a score of 0 for papers I may want to read, 100 for papers I will probably want to read, 200 for papers I will very likely want to read, and 300 for papers I will certainly want to read. I generally put the content matches with a lower score since they may occur multiply times and e.g. I don’t want to miss an interesting paper just because one of the applications was an area I’m not interested in.
#+end_quote

The scoring is not only based on text or content: unsurprisingly, the =authors= field lets you push up specific authors' work; by adding elements to the =tag= field you can prioritize posts with particular tags and through the =feed= field it's possible to put some feed content before others.

Finally, we activate =elfeed-score= by adding these lines in the init file (=config.el=):

#+begin_src emacs-lisp :tangle config.el
(require 'elfeed-score)
(elfeed-score-enable)
(define-key elfeed-search-mode-map "=" elfeed-score-map)
#+end_src

{{{prismcss}}}
{{{prismjs}}}

*** Typescript
# Innanzitutto, bisogna avere aggiunto alcuni moduli: =web= e =javascript=, in particolare.
First of all, you need to have added some modules: =web= and =javascript=, in particular.
This is done by uncommenting them in =.doom.d/init.el= (remove =;;= as shown in the "Doom modules" paragraph above).

# Per farlo, basta togliere =;;= nel file di configurazione =.doom.d/init.el=, come fatto nel paragrafo sopra.
At this point, someone may want to work with files in the =.tsx= format.
Support for this use case may be coming soon, but for the moment we can use a simple line of Lisp in the configuration file.

# A questo punto, è possibile che uno voglia lavorare con file in formato =.tsx=. Il supporto per questo caso d'uso potrebbe arrivare presto, ma per il momento ci viene in soccorso una semplice riga di lisp nel file di configurazione, [[https://github.com/hlissner/doom-emacs/issues/2252#issuecomment-569059839][secondo il suggerimento di hlissner]]:

#+begin_src emacs-lisp :tangle config.el
;; Support for React
(add-to-list 'auto-mode-alist '("\\.tsx\\'" . typescript-mode))
#+end_src

# In caso foste in cerca di una soluzione per Vanilla Emacs o Spacemacs, quest'altra soluzione potrebbe fare al caso vostro:
If you are looking for a solution for Vanilla Emacs or Spacemacs, this other one may be suitable for you:

#+begin_src emacs-lisp
(use-package typescript-mode
  :mode (rx ".ts" string-end)
  :init
  (define-derived-mode typescript-tsx-mode typescript-mode "typescript-tsx")
  (add-to-list 'auto-mode-alist (cons (rx ".tsx" string-end) #'typescript-tsx-mode)))
#+end_src

# Praticamente dichiariamo una modalità derivata dalla =typescript-mode= e le assegniamo anche i file con estensione =.tsx=. Per maggiori dettagli, [[https://github.com/emacs-typescript/typescript.el/issues/4#issuecomment-849355222][fate riferimento a questo issue su Github]].
Basically, we make a new mode derived from =typescript-mode= and we assign it the =.tsx= extension too.
For more details, refer to [[https://github.com/emacs-typescript/typescript.el/issues/4#issuecomment-849355222][this Github issue]].

*** Vala
# Il supporto per Vala è largamente ereditato dalla mode per C#.
The support for Vala is largely inherited from the C# mode.

#+begin_src emacs-lisp :tangle packages.el
(package! vala-mode)
#+end_src

*** Python
**** Virtualenv
# Supporto per virtualenv.
Virtualenv support.

#+begin_src emacs-lisp :tangle packages.el
(package! pyvenv)
#+end_src

*** Rust
**** Semantic analysis
# [[https://robert.kra.hn/posts/rust-emacs-setup/][Come scrive Robert Krahn]],
[[https://robert.kra.hn/posts/rust-emacs-setup/][As Robert Krahn writes]],

#+begin_quote
Racer used to be the best option for getting IDE features (code navigation etc) into Emacs. It is a non-LSP solution which is still faster than RLS and rust-analyzer. However, the number of features especially around code completion are not up to par with rust-analyzer anymore.
#+end_quote

# Il consiglio, quindi, è quello di passare direttamente al paragrafo successivo, ma chi proprio desiderasse Racer (che era piacevole), lascio qui tutte le istruzioni del caso.
The advice, therefore, is to skip directly to the next paragraph, but for those who really want Racer (which was enjoyable), I leave here all the necessary instructions.

***** Racer
# Dopo avere abilitato =rust= in =init.el=, Doom Emacs lamentava l'introvabilità del binario di Racer:
After enabling =rust= in =init.el=, Doom Emacs complained about the inability to find the Racer binary.

#+begin_quote
Please set ‘racer-rust-src-path’ or ‘RUST_SRC_PATH’
#+end_quote

# Il primo problema derivava non tanto dal fatto che fosse scorretta la variabile =racer-rust-src-path=, ma che proprio non esistesse alcuna =src-path= perché bisognava prima che installarla:
The first issue derived not so much from the fact that the variable =racer-rust-src-path= was incorrect, but that there was no =src-path= at all because it had to be installed first.

#+begin_src bash
rustup component add rust-src
#+end_src

# Ma si ottiene un altro errore:
But you get another error:

#+begin_quote
eldoc error: (user-error /.../.cargo/bin/racer exited with 127. ‘M-x racer-debug’ for more info)
#+end_quote

# Questo perché manca racer, che [[https://lib.rs/crates/racer][va installato a parte]].
# Siccome Racer risiede nella nightly toolchain, installiamo prima quella:
This is because Racer is missing, which [[https://lib.rs/crates/racer][must be installed separately]].
Since Racer is included in the nightly toolchain, we install it first:

#+begin_src bash
rustup toolchain install nightly
#+end_src

# Poi aggiungiamo gli strumenti da sviluppatore =rustc-dev=:
Then we add the developer tools =rustc-dev=.

#+begin_src bash
rustup component add rustc-dev --toolchain=nightly
#+end_src

# Assicuriamoci che anche Cargo sia già installato e lanciamo:
Let's make sure that Cargo is also already installed and let's launch it.

#+begin_src bash
cargo +nightly install racer
#+end_src

# [[https://github.com/racer-rust/racer/issues/1181][La compilazione potrebbe fallire]], ma bisogna tenere a mente è che Racer non è al momento mantenuto:
[[https://github.com/racer-rust/racer/issues/1181][The compilation might fail]], but it should be kept in mind that Racer is not currently maintained.

#+begin_quote
Racer is not actively developed now. Please consider using newer software such as rust-analyzer.
#+end_quote

# Per il momento Racer funziona egregiamente, ma successivamente potrei voler dare un occhio anche a [[https://rust-analyzer.github.io/][rust-analyzer]].

# Emacs potrebbe non individuare subito Racer, nonostante l'installazione.
Emacs might not detect Racer right away, even if it is installed.

#+name: racer-path
#+begin_src emacs-lisp
"~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library"
#+end_src

# Quick fix per consentire ad Emacs di trovare i binari di Racer:
Quick fix to allow Emacs to find Racer binaries.

#+begin_src emacs-lisp :tangle config.el :noweb no-export
;; (setq racer-rust-src-path <<racer-path>>)
#+end_src

# Io non uso più Racer, ma eldoc si ostina a farlo, dando sempre questo fastidiosissimo errore:
I no longer use Racer, but eldoc insists on using it, always giving this very annoying error:

#+begin_quote
eldoc error: (user-error /home/cromo/.cargo/bin/racer exited with 127. ‘M-x racer-debug’ for more info)
#+end_quote

[[https://github.com/doomemacs/doomemacs/issues/2271#issuecomment-569775470][As @hlissner said]]:

#+begin_quote
The =:lang rust= module doesn't use =rust-mode=, it uses [[https://github.com/brotzeit/rustic][rustic-mode]], a fork of =rust-mode=.

When =+lsp= is not enabled, the module uses =racer= to provide code completion, type info in the minibuffer (eldoc) and other features, but the racer package depends on =rust-mode=, so it must be installed (but doom still doesn't use it directly).
#+end_quote

# Bisogna perciò evitare che Racer sia avviato tutte le volte che LSP non è attivo. Come ricordato da [[https://www.reddit.com/r/DoomEmacs/comments/slb92w/comment/hvrfkax/?utm_source=share&utm_medium=web2x&context=3][@subderisorious]], per fortuna Doom ci consente di disabilitare un pacchetto della configurazione di default semplicemente richiamando la macro =package!= in =packages.el=.
Therefore, it is necessary to avoid starting Racer every time LSP is not active. As recalled by [[https://www.reddit.com/r/DoomEmacs/comments/slb92w/comment/hvrfkax/?utm_source=share&utm_medium=web2x&context=3][@subderisorious]], fortunately Doom allows us to disable a package from the default configuration simply by calling the macro =package!= in =packages.el=.

(Note: I corrected the formatting of the original text for clarity.)

#+begin_src emacs-lisp :tangle packages.el
(package! racer :disable t)
#+end_src

***** rust-analyzer
# Circa sei mesi dopo, è tempo di dare un'occhiata a rust-analyzer.
It's time to look at =rust-analyzer=.

Quoting the [[https://rust-analyzer.github.io/manual.html#installation][manual]]:

#+begin_quote
At its core, rust-analyzer is a library for semantic analysis of Rust code as it changes over time. This manual focuses on a specific usage of the library — running it as part of a server that implements the Language Server Protocol (LSP). The LSP allows various code editors, like VS Code, Emacs or Vim, to implement semantic features like completion or goto definition by talking to an external language server process.
#+end_quote

# Anche questa volta, possiamo usare =rustup=:
This time too, we can use =rustup=.

#+begin_src bash
rustup component add rust-src
#+end_src

# Io sto su Arch, quindi installo con pacman:
I use Arch (btw), so I will show the command with pacman:

#+begin_src bash
sudo pacman -S rust-analyzer
#+end_src

# È il caso di specificare quale server intendiamo utilizzare, altrimenti Rustic potrebbe fraintendere o optare per Racer:
It is necessary to specify which server we intend to use, otherwise Rustic could misunderstand or opt for Racer.

#+begin_src emacs-lisp :tangle config.el
(setq rustic-lsp-server 'rust-analyzer)
#+end_src

# Questo dovrebbe essere sufficiente, ma per essere proprio sicuri:
This should be sufficient, but to be absolutely sure:

#+begin_src emacs-lisp :tangle config.el
(after! lsp-rust
  (setq lsp-rust-server 'rust-analyzer))
#+end_src

# Lanciamo =lsp= in un buffer con Rust ed assistiamo al compiersi della magia.
We launch =lsp= in a buffer with Rust and witness the magic happen.

*** Dired
Drag and drop to dired:

#+begin_src emacs-lisp :tangle config.el
(add-hook 'dired-mode-hook 'org-download-enable)
#+end_src

*** Kindle
**** Send ebooks to Kindle with Emacs
:PROPERTIES:
:EXPORT_HUGO_SECTION: software/send-ebooks-to-kindle
:EXPORT_FILE_NAME: index.en.md
:EXPORT_DATE: [2023-04-06 gio]
:END:

Since I often stockpile text to read in the form of ebooks, I usually prefer to read them on my Kindle.

{{{more}}}

Essentially, there are two practical ways for loading new ebooks on a Kindle:
- USB
- Mail

# Per inviare qualcosa sul tuo Kindle personale, prima di tutto bisogna abilitare l'indirizzo email da cui gli ebook saranno inviati, altrimenti Amazon rifiuterà il file (per ragioni di sicurezza). Dopo avere abilitato la mail sul portale di Amazon, disporremo non solo di una mail a cui inviare l'epub, ma anche di un username ed una password, in modo non dissimile da quello che solitamente vale per il bearer token nelle API di servizi simili.
In order to send something to your personal Kindle, the first step is to enable the email address from which the eBooks will be sent, otherwise Amazon will reject the file (for security reasons). After having enabled the email on the Amazon portal, we will have not only an email to send the epub to but also a username and password, similar to what usually applies to the bearer token in the APIs of similar services.

# Per agevolare l'invio di email contenenti ebook al Kindle, Calibre ha disposto delle funzioni specifiche. Io, però, sono troppo pigro pure per aprire la GUI di Calibre e, generalmente, se un ebook è in giro per il mio computer, significa che prima o poi vorrò leggerlo. Quindi ho pensato di automatizzare il lavoro, affidandolo ad un singolo comando.
To facilitate the sending of emails containing ebooks to Kindle, Calibre provides specific functions. However, I am too lazy to even open the Calibre GUI and, usually, if an ebook is on my computer, it means that sooner or later I will want to read it. Therefore, I have decided to automate the task by entrusting it to a single function.

***** The strategy
# Questa è la strategia:
My strategy is pretty simple:
- The code iterates over all files that have the =.epub= extension in a specific directory.
- Every =.epub= file can be converted to the =.mobi= format and sent as an email attachment to the Kindle email address using =calibre-smtp= (Calibre must be installed).
- The mail is sent with autentication using a given mail server port and login credentials.
- Once the mail is sent, the =.mobi= files can be moved in another directory or deleted. The same applies to the =.epub= files.

We have the blueprint, it's time to proceed in order, imagining a function.

# TODO diagram

# Translate this text in english, using a technical style and precision:
# Prima di tutto, scegliamo la directory in cui vanno cercati i file che vogliamo inviare sul Kindle.
Firstly, we set the =epub-path=, the directory in which to search for the files we want to send to the Kindle.

#+begin_src emacs-lisp :tangle config.el
(setq tokindle-epub-path "~/Scaricati/epub")
#+end_src

What will we do with the original files after conversion?
We set directories for archiviation:

#+begin_src emacs-lisp :tangle config.el
(setq tokindle-epub-path-sent "~/Scaricati/epub_sent")
#+end_src

# Check if the following line is expressed in a correct english:
If we convert the epub into mobi, we may want to manage the mobi files too in a similar fashion:

#+begin_src emacs-lisp :tangle config.el
(setq tokindle-mobi-path-sent "~/Scaricati/mobi_sent")
#+end_src

Finally, we can write the function, here called =send-to-kindle=.

#+begin_src emacs-lisp
(defun send-to-kindle ()
  (dolist (file (directory-files tokindle-epub-path 'full (rx ".epub" eos) 'nosort))
    (let ((filename (file-name-sans-extension file))
          (ext (file-name-extension file)))

      ;; Manage conversion between formats
      ;; ...

      ;; Send the mobi files with calibre
      ;; ...

      ;; now you can move the ebook files into the proper directories
      ;; ...
      ))
  ;; congratulations *clap clap*, the files were sent to your kindle
  (message "All available ebooks are being sent to your Kindle."))
#+end_src

- We start iterating over every epub file in =tokindle-epub-path=.
- We give =full= and =nosort= optional arguments as non-nils to =directory-files= because we like the absolute path of files and we don't need any sorting; making the function sort the files would be a waste of time.
- Expanding the path is not necessary, because =directory-files= is able to do it by itself.

***** Epub to mobi
It would be convenient having a function to convert any epub file to mobi format.
Calibre has [[https://manual.calibre-ebook.com/generated/en/ebook-convert.html][a CLI command for solving this problem]]:

#+begin_src
ebook-convert input_file output_file [options]
#+end_src

Formatting the command in emacs lisp, we got:

#+begin_src emacs-lisp :tangle config.el
(defun ebook-convert-epub-to-mobi (file)
  (format "ebook-convert \"%s\" \"%s\".mobi" file file))
#+end_src

We could run it as a subprocess with =shell-command= and having good results, but the problem is that Emacs hangs on the process and stays blocked until it's finished. Making the function async would be better. Instead of using =shell-command= directly, we can implement it with Emacs' async libraries or directly using a function provided by =magit=.

# TODO riscrivi dicendo se c'è magit fai una cosa, sennò fai l'altra
Thanks to =magit-shell-command= we can monitor the process in a dedicated buffer.

We can run the async function if Magit is installed, or run the previous one if Magit is missing. This way, Magit is not a hard requirement for this code to run correctly.
# You can use the =if= statement and the =featurep= function to achieve this.

# #+name: convert-in-mobi
#+begin_src emacs-lisp
;; if the mobi counterpart already exists, go on
(if (not (file-exists-p (concat file ".mobi")))
    ;; else convert the epub file in mobi
    (if (featurep 'magit)
        ;; function to run if Magit is installed
        (magit-shell-command (ebook-convert-epub-to-mobi file))
      ;; function to run if Magit is missing
      (shell-command (ebook-convert-epub-to-mobi file))))
#+end_src

Before converting the epub file into mobi, we better check if the conversion wasn't already done.

# How to check if a file already exists in emacs lisp?
We can check if a file already exists in Emacs Lisp using the =file-exists-p= function.
# It takes a file path as its argument and returns =t= if the file exists, or =nil= if it does not. Here's an example:

Since the mobi conversion its done in the same directory of epub files, some files with the =mobi= extension could be left there from a previous failed process. This shouldn' happen and never happened to me, but being safe doesn't costs.

# Per mandare via mail usiamo un altro comando reso disponibile da Calibre. Potremmo anche non usarlo, ma visto che già dipendiamo da Calibre per la funzione precedente (ed è quindi necessariamente installato), perché non usarlo?

***** Sending emails
To send via email, we use [[https://manual.calibre-ebook.com/it/generated/it/calibre-smtp.html][another command made available by Calibre]].
We could also choose another tool, but since we are already dependent on Calibre for the previous function (and it is therefore necessarily installed), why not use it?

#+begin_src
calibre-smtp [options] [from to text]
#+end_src

Again, we realize a function that maps it to a string that we can launch as subprocess.
To build the SMTP command, we need to set up SMTP and credentials; the simpler way to store this informations is as environment variables. So, retrieving them is a matter of few =getenv= commands.

#+begin_src emacs-lisp :tangle config.el
(defun tokindle-calibre-smtp-cmd (filename)
  (concat "calibre-smtp "
          ;; attachment
          (format "-a \"%s.mobi\" " filename)
          ;; subject
          (format "-s \"%s\" " (file-name-nondirectory filename))
          (format "-r \"%s\" " (getenv "TOKINDLE_SMTP"))
          (format "--port \"%s\" " (getenv "TOKINDLE_PORT"))
          (format "-u \"%s\" " (getenv "TOKINDLE_USERNAME"))
          (format "-p \"%s\" " (getenv "TOKINDLE_PASSWORD"))
          (format "\"%s\" " (getenv "TOKINDLE_MY_MAIL"))
          (format "\"%s\" " (getenv "TOKINDLE_KINDLE_MAIL"))
          ;; text
          "\"\""))
#+end_src

We run this command for each mobi file available.
The question is: asynchronously or synchronously?

***** The sync approach
The problem with async is that we have to make sure that the commands in the second block (email) doesn't start before the commands in the first block (conversion). Since the "rate determining step" is the first one (the conversion is the slower block), we have to be particularly careful. At this point, it's clear that we cannot write another block like the previous one; not like the following:

# #+name: send-ebook
#+begin_src emacs-lisp
(if (file-exists-p (concat file ".mobi"))
    (if (featurep 'magit)
        (magit-shell-command (tokindle-calibre-smtp-cmd file))
      (shell-command (tokindle-calibre-smtp-cmd file))))
#+end_src

This is a traditional problem in asynchronous programming: the asynchronous flow and the synchronous one must be considered separately or the code gets messy.
The simple way to do this is just having two different functions.
That's why we will rewrite the blocks before to work synchronously, then we will write the fully asynchronous functions in a second moment.

To convert in mobi synchronously:

#+name: convert-in-mobi-sync
#+begin_src emacs-lisp
(if (not (file-exists-p (concat file ".mobi")))
    (progn
      (message (concat "Converting " file "to mobi..."))
      (shell-command (ebook-convert-epub-to-mobi file))
      (message "Converted.")))
#+end_src

To send ebooks synchronously:

#+name: send-ebook-sync
#+begin_src emacs-lisp
(if (file-exists-p (concat file ".mobi"))
    (progn
      (message (concat "Sending " (concat file ".mobi") "to your Kindle..."))
      (shell-command (tokindle-calibre-smtp-cmd file))
      (message "File sent.")))
#+end_src

# Non ci resta che scrivere una funzione che faccia piazza pulita dei file non più necessari. Poi potremo considerare la funzione conclusa.
We just have to write a function that cleans up unnecessary files. Then we can consider this function finished.

# How can I move files from a directory to another with Emacs lisp?
In emacs lisp, you can move files from one directory to another using =rename-file= function.
# Replace the file paths with your own and run this code in Emacs Lisp.

#+name: clean-up
#+begin_src emacs-lisp
;; archive the epub
(rename-file file (file-name-concat tokindle-epub-path-sent
                                    (file-name-nondirectory file)))
;; archive the mobi
(rename-file (concat file ".mobi")
             (file-name-concat tokindle-mobi-path-sent
                               (file-name-nondirectory (concat file ".mobi"))))
#+end_src

# Prima di passare ad altro, prendiamo un momento per osservare la funzione nella sua interezza.
Before moving on to something else, let's take a moment to observe the function as a whole.

#+begin_src emacs-lisp :tangle config.el :noweb yes
(defun send-to-kindle ()
  (dolist (file (directory-files tokindle-epub-path 'full (rx ".epub" eos) 'nosort))
    (let ((filename (file-name-sans-extension file))
          (ext (file-name-extension file)))

      ;; Manage conversion between formats
      <<convert-in-mobi-sync>>

      ;; Send the mobi files with calibre
      <<send-ebook-sync>>

      ;; now you can move the ebook files into the proper directories
      <<clean-up>>
      ))
  ;; congratulations *clap clap*, the files were sent to your kindle
  (message "All available ebooks are being sent to your Kindle."))

;; try me!
;; (send-to-kindle)
#+end_src

The sync function takes time but works fine.
It could be especially useful to be called from the shell:

#+begin_src sh
emacsclient -e '(send-to-kindle)'
#+end_src

# How can I write two async blocks in emacs lisp, being careful that the first one is being finished before the second block runs?
# You can use the =async-start= function with the =:sync= option set to =t= for the first block. This will cause it to run synchronously and not return until it has finished. Then use =async-start= again for the second block without setting =:sync= to ensure it runs asynchronously.

***** COMMENT Async excursus
Now, let's go back to the asynchronous version.

How can I write asynchronously functions in emacs lisp?

You can write asynchronous functions in Emacs Lisp by using the built-in =async-start= and =async-start-process= functions to execute a function in the background.
You can also use the =deferred= library or the newer =async= library which provides more advanced functionality for writing asynchronous code.

Write and explain a simple example of using deferred library in emacs lisp

Here is a simple example of using the deferred library in Emacs Lisp:

#+begin_src emacs-lisp
(require 'deferred)

(defvar my-deferred-result nil)

(deferred:$
  (deferred:next (lambda () 42))
  (deferred:nextc it (lambda (x) (* x 2)))
  (deferred:nextc it (lambda (x) (concat "The answer is " (number-to-string x))))
  (deferred:nextc it (lambda (result) (setq my-deferred-result result))))

;; Wait for the deferred operation to complete and print the result
(deferred:wait my-deferred-result
  (lambda (result) (message result)))
#+end_src

In this example, we use =deferred:$= to chain a sequence of deferred operations together. We start with a lambda function that returns the value 42. We then use =deferred:nextc= to chain two additional lambda functions that double the result and convert it to a string. Finally, we use =deferred:nextc= again to set the value of the =my-deferred-result= variable to the final result.

To wait for the deferred operation to complete, we use =deferred:await= to specify the deferred result (=my-deferred-result=) and the function to call when the result is available (a lambda function that prints the result using =message=).

#+begin_src emacs-lisp
(require 'deferred)

(deferred:$
  (deferred:process "ls" "-l")
  (deferred:nextc it
    (lambda (process)
      (message "Process output: %s" (buffer-string (process-buffer process))))))

#+end_src

In this example, we use the =deferred:process= function to run a process that lists the contents of the current directory (using the =ls -l= command). This function returns a deferred object that represents the result of the process.

We then use the =deferred:nextc= function to schedule a callback that will be run when the deferred object is resolved. The callback takes the process object as its argument, and logs the output of the process to the minibuffer using the =message= function.

By using =deferred=, we are able to run the process asynchronously, without blocking the Emacs UI, and handle the result of the process in a separate callback function. =deferred= also provides other useful functions for dealing with asynchronous operations, such as =deferred:map= and =deferred:wait=.

Show how can I store a lambda to a variable in emacs lisp

You can store a lambda to a variable in Emacs Lisp using the =defvar= or =setq= functions. Here's an example:

#+begin_src emacs-lisp
(defvar my-lambda (lambda (x) (+ x 1)))
(funcall my-lambda 3)
#+end_src

In this example, we define a variable =my-lambda= and set it equal to a lambda function that takes one argument =x= and returns the value of =x + 1=.

Now, I want to define a list of lambdas.

You can use dolist in Emacs Lisp to iterate over a list and execute a body of code for each element in the list. Here is an example:

#+begin_src emacs-lisp
(dolist (elem list) (print elem))
#+end_src

In this example, =list= is the list you want to iterate over and =elem= is the variable that represents each element in the list.

Going to the serious stuff, let's store a list of lambdas.

#+begin_src emacs-lisp
(defvar my-lambdas '((lambda (x) (+ x 1))
                     (lambda (x) (- x 1))))

(dolist (my-lambda my-lambdas) (message (number-to-string (funcall my-lambda 3))))
#+end_src

My point is those lambda can be procedurally generated from another list, then passed to be runned in parallel.

Riscriviamo popolando una lista. Non si sa mai, meglio testare.

#+begin_src emacs-lisp
(defvar my-lambdas '())

(defvar list-example '((lambda (x) (+ x 1))
                     (lambda (x) (- x 1))))

(dolist (example list-example) (add-to-list 'my-lambdas example))
(add-to-list 'my-lambdas (lambda (x) (- x 3)))

(print my-lambdas)
#+end_src

Ok, si può fare.

#+RESULTS:

***** The async approach
# Translate this italian text in english:
# Non avrei bisogno nemmeno di scrivere questa funzione, visto che ora Amazon ha annunciato che supporterà epub come formato, ma lo faccio giusto perché mi va di vedere come funzionano le chiamate asincrone su Emacs.

# Potrei scriverla così, ma c'è un problema. Nel momento in cui lancio =add-to-list=, quel che viene dopo non viene valutato, solo trascritto. A me questo piace, ma voglio selettivamente valutare la variabile =file=.

I could write it like this, but there's a problem. At the moment I launch 'add-to-list', what comes after is not evaluated, but only transcribed. I like it this way, but I want to selectively evaluate the 'file' variable.

#+begin_src emacs-lisp :results output
(defun send-to-kindle-async ()
  ;; collect the lambdas you want to execute in parallel
  (setq conversion-lambdas '())
  (dolist (file (directory-files tokindle-epub-path 'full (rx ".epub" eos) 'nosort))
    (add-to-list 'conversion-lambdas (lambda ()
                                       (if (not (file-exists-p (concat file ".mobi")))
                                           (progn
                                             (message (concat "Converting " file "to mobi..."))
                                             (shell-command (ebook-convert-epub-to-mobi file))
                                             (message "Converted."))))))

  (print conversion-lambdas))

;; try me!
(send-to-kindle-async)
#+end_src

#+RESULTS:
:
: ((lambda nil (if (not (file-exists-p (concat file ".mobi"))) (progn (message (concat "Converting " `file "to mobi...")) (shell-command (ebook-convert-epub-to-mobi file)) (message "Converted.")))))

Qua subentra il [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Backquote.html][backquoting]].

Ne parlano anche su [[https://emacs.stackexchange.com/questions/7481/how-to-evaluate-the-variables-before-adding-them-to-a-list][Stack Exchange]].
"How to evaluate the variables before adding them to list?"

Il problema credo sia che =add-to-list= a sua volta fa uso di questi metodi, quindi backquoting dentro =add-to-list= non funziona.
Mi conviene usare un metodo più semplice per aggiungere elementi alla lista.

=cons= è il metodo più semplice.
Non controlla niente, non fa verifiche strane.

#+begin_quote
=cons= is often used to add a single element to the front of a list. This is called /consing/ the element onto the list. 5 For example:
#+end_quote

#+begin_src emacs-lisp :results output
(defun send-to-kindle-async ()
  ;; collect the lambdas you want to execute in parallel
  (setq conversion-lambdas '())
  (dolist (file (directory-files tokindle-epub-path 'full (rx ".epub" eos) 'nosort))
    (setq conversion-lambdas (cons `(lambda ()
                                      (if (not (file-exists-p (concat ,file ".mobi")))
                                          (progn
                                            (message (concat "Converting " ,file "to mobi..."))
                                            (shell-command-to-string (ebook-convert-epub-to-mobi ,file))
                                            (message "Converted.")))) conversion-lambdas)))

  (print conversion-lambdas))

;; try me!
(send-to-kindle-async)

;; (deferred:$
;;    (deferred:parallel
;;      ()
;;      ))

(mapc #'funcall conversion-lambdas)

;; espanso
;; perché non arriva mai al secondo?
(mapc #'funcall '((lambda nil (if (not (file-exists-p (concat "/home/cromo/Scaricati/epub/wsw.epub" ".mobi"))) (progn (message (concat "Converting " "/home/cromo/Scaricati/epub/wsw.epub" "to mobi...")) (shell-command (ebook-convert-epub-to-mobi "/home/cromo/Scaricati/epub/wsw.epub")) (message "Converted.")))) (lambda nil (if (not (file-exists-p (concat "/home/cromo/Scaricati/epub/boh.epub" ".mobi"))) (progn (message (concat "Converting " "/home/cromo/Scaricati/epub/boh.epub" "to mobi...")) (shell-command (ebook-convert-epub-to-mobi "/home/cromo/Scaricati/epub/boh.epub")) (message "Converted."))))))

;; non va bene
;; si aspetta stringp
;; trova 0
;; dopo aver fatto la prima generazione, quindi il primo comando
;; prima di scrivere converted
;; ma non è converted
;; è questo il problema
;; viene restituito da ebook-convert-epub-to-mobi
;; 0 (#o0, #x0, ?\C-@)
;; perché?
;; la funzione si aspetta che sia restituito qualcosa
;; una stringa
;; invece non restituisce nulla
;; dobbiamo usare il comando "shell-command-to-string"

;; (funcall (car conversion-lambdas))
#+end_src

***** Conclusions

[...]

{{{prismcss}}}
{{{prismjs}}}

**** Get NOTES from Kindle
# TODO

*** Zola
# Funzioni ausiliarie che ho scritto per facilitarmi il lavoro quando scrivevo in Markdown per Zola.
Auxiliary functions that I wrote to make my work easier when writing in Markdown for Zola.

# Come già spiegato sopra, ora esporto da org-mode, quindi l'utilità di queste funzioni è venuta meno, ma occasionalmente mi capita di impiegarle, quindi le lascio comunque.
As already explained above, now I export from org-mode, so the usefulness of these functions has disappeared, but occasionally I still use them, so I leave them anyway.

# TODO dovrei controllare Yasnippet per questi casi

**** Markdown TOML frontmatter :it:
Immaginate di voler generare un nuovo file Markdown per il vostro sito web.
In base al tipo di generatore, questo potrà avere bisogno di un frontespizio in TOML o in YAML, magari. Si tratta di pochi caratteri, ma scriverli di volta in volta può risultare un po' frustrante, soprattutto se si scrivono molti pezzi.

Allora perché non lasciare che sia Emacs a fare il lavoro per noi? Siccome [[https://shallowsky.com/blog/linux/editors/code-file-templates.html][non sono il primo ad essermi posto questa domanda]], ho semplicemente riformulato una soluzione largamente adottata. La forza del programmatore, d'altronde, è la sua pigrizia.

Iniziamo scrivendo una funzione che generi il blocco di testo di cui abbiamo bisogno.
Io utilizzo Zola per generare il mio blog, quindi potrei scrivere il frontespizio anche in YAML, ma TOML è il formato di riferimento (ed è anche quello che preferisco, senza alcun dubbio).

# Imagine wanting to generate a new Markdown file for your website. Depending on the type of generator, it may need a TOML or YAML header. Writing this each time can be frustrating, so why not let Emacs do the work for you? Here, the author has formulated a solution based on the widely adopted idea that the programmer's laziness is their strength. They begin by writing a function to generate the needed text block. They use Zola to generate their blog and TOML is their preferred format for the header.

Vogliamo quindi ottenere qualcosa del genere:

#+begin_src toml
+++
title=""
date=

[taxonomies]
categories=[""]
tags=[""]

[extra]
+++
#+end_src

Traduciamo in lisp:

#+begin_src emacs-lisp :tangle config.el
;; Generate TOML frontmatter
(defun new-toml-frontmatter ()
  "Insert a TOML frontmatter for Markdown files"
  (interactive)
  (insert "+++\n"
          "title=\"\"\n"
          "date=\n"
          "\n"
          "[taxonomies]\n"
          "categories=[\"\"]\n"
          "tags=[\"\"]\n"
          "\n"
          "[extra]\n"
          "+++"))
#+end_src

Da [[https://www.emacswiki.org/emacs/InteractiveFunction][EmacsWiki]]:
#+begin_quote
A Lisp function becomes a command when its body contains, at top level, a form that calls the special form `(interactive...)’. This special form does nothing when executed, but its presence in the function definition indicates that interactive calling is permitted. Its argument controls the reading of the function arguments in an interactive call.
#+end_quote

Il resto penso sia fin troppo comprensibile perché meriti spiegazione.

Aggiungiamo questa nuova funzione a =.doom.d/config.el= (o =.emacs= in Vanilla Emacs).
Poiché le funzioni nel config vengono rese disponibili al lancio di Emacs, è necessario un =doom/reload= (=SPC-h-r=).

Già invocare questa funzione nel momento della creazionee del file è ben più comodo della situazione di partenza, in cui dovevamo di volta in volta scrivere l'intero frontespizio. MA non è sufficiente: noi vogliamo che il frontespizio sia automaticamente generato su ogni file markdown nuovo di zecca.

Con la funzione =add-hook= possiamo agganciare il lancio della nostra funzione ad una modalità. Nel nostro caso, la =markdown-mode=:

#+begin_src emacs-lisp :tangle config.el
(add-hook 'markdown-mode-hook
          (lambda ()
            (if (= (buffer-size) 0)
            (new-toml-frontmatter))
            (message "markdown hook")))
#+end_src

Da ora in avanti, basterà aprire un file Markdown vuoto perché Emacs inserisca automaticamente il frontespizio.

**** Markdown shortcode
# Con lo stesso approccio, si possono anche ottenere delle funzioni per aggiungere degli shortcode molto usati nel corpo del testo e persino associare delle combinazioni di tasti ad esse!
With the same approach, it is also possible to obtain functions to add frequently used shortcodes in the body of the text and even associate keyboard shortcuts to them!

#+begin_src emacs-lisp :tangle config.el
;; Generate Zola Shortcodes
(defun new-social-shortcode ()
  "Generate new twitter shortcode"
  (interactive)
  (insert "{% social\(\n"
          "social=\"tw\",\n"
          "url=\"\",\n"
          "author=\"\",\n"
          "date=\"\"\n"
          "\) %}"
          "\n"
          "{% end %}"))
#+end_src

# Uniamoci, confratelli, nell'amore per Emacs.

**** Org exporter :it:
L'exporter per Zola è un pacchetto che sto mantenendo io, quindi capita spesso che io debba testare delle modifiche in locale. =package!= gestisce i download, quindi in teoria non dovrebbe essere impiegato per la gestione di file in locale, ma [[https://github.com/doomemacs/doomemacs/issues/3842#issuecomment-681039894][Henrik Lissner consiglia di usare comunque la macro perché è stata adattata anche a questo genere di situazioni]].

Aggiunge:

#+begin_quote
Note: with =:no-byte-compile t=, you don't have to run doom sync every time you make a change to the package.
#+end_quote

Così:

#+begin_src emacs-lisp
(package! ox-hugo :recipe (:local-repo "lisp/ox-zola"))
#+end_src

Peccato che a me dia "runtime error":

#+begin_quote
Details: ((:private . packages) "/home/cromo/.doom.d/packages.el" (wrong-type-argument listp (doom-package-error "ox-hugo" . "Keyword argument :no-byte-compile not one of (:local-repo :files :flavor :build :pre-build :post-build :includes :type :repo :host :branch :protocol :remote :nonrecursive :fork :depth :source :inherit)")))
#+end_quote

Non ho ben capito perché (che sia [[https://github.com/doomemacs/doomemacs/issues/4142#issuecomment-715532212][questo il problema]]? non mi pare...), ma ho risolto più brutalmente. Innanzitutto installo il codice dalla mia repo.

#+begin_src emacs-lisp :tangle packages.el
;; (package! ox-hugo :recipe (:host github :repo "gicrisf/ox-zola"))
(package! ox-hugo)
#+end_src

In secondo luogo, faccio le modifiche in locale e lancio =emacs-lisp-byte-compile-and-load= tutte le volte che modifico qualcosa. Finché non riavvio Emacs, è possibile testare quanto si vuole. Forse un po' più scomodo, ma è un approccio che fa il suo sporco lavoro.

# Frontmatter
Esportare da org a Hugo/Zola Markdown richiede la scrittura di un =:PROPERTIES:= frontmatter.
Ma io sono pigro e non mi va di riscrivere ogni volta lo scaffold del frontmatter, quindi ecco una funzione ausiliaria.

#+begin_src emacs-lisp :tangle config.el
;; Generate ORG/Zola frontmatter
;; TODO Section management
;; Update the directory
;; MAYBE Add hook to org file IF hugo_base_dir or hugo_section is present at top
(defun org-zola-frontmatter (slug)
  "Insert org-mode properties under a paragraph to setup ox-hugo/zola exports"
  (interactive "sEnter slug: ")
  (insert ":PROPERTIES:\n"
          (concat ":EXPORT_HUGO_SECTION: 2022/" slug "\n")
          ":EXPORT_FILE_NAME: index\n"
          ":END:\n"))
#+end_src

Sempre al fine di automatizzare la produzione dei metadati, meglio automatizzare l'inserimento del timestamp con questa funzione org-mode:

#+begin_src emacs-lisp :tangle config.el
;; add "CLOSED" when an item is set with DONE state
(setq org-log-done 'time)
#+end_src

*** Twitter
# Questo piccolo pacchetto (che conto di estendere presto) nasce per assolvere ad una funzione molto semplice: citare i tweet nel mio blog.
A small package (which I plan to extend soon) designed to fulfill a very simple function: to cite tweets on my blog.

#+begin_src emacs-lisp :tangle packages.el
(package! eltweet :recipe (:host github :repo "gicrisf/eltweet"))
#+end_src

If you speak italian, [[https://zwitterio.it/coding/2022/quote-tweets-properly-with-emacs-lisp/][at this link I narrate how it was written, commenting the code line-by-line from a perspective of a lisp beginner]];

*** Mastodon
Firstly, let's install "mastodon.el":
# Prima di tutto, installiamo mastodon.el:

# now *Untangled*
# :tangle packages.el
#+begin_src emacs-lisp
(package! mastodon)
#+end_src

You can find me on "@gicrisf@fosstodon.org", so:
# Io sono su "@gicrisf@fosstodon.org", quindi:

#+begin_src emacs-lisp :tangle config.el
(setq mastodon-instance-url "https://fosstodon.org"
      mastodon-active-user "gicrisf")
#+end_src

I'm amazed by how easy it was to read the TL on Emacs, thanks to this package.
The weak spot is the layout, but fortunately [[https://gist.github.com/rougier/e92d446600dfe350b9ec9d7cabaca211][Nicolas Rougier is working on it]].

# Sono meravigliato da quanto facile sia stato arrivare alla propria TL da Emacs grazie a mastodon.el, ma il layout di default è veramente insostenibile.
# Fortunatamente, Nicolas Rougier ha già [[https://gist.github.com/rougier/e92d446600dfe350b9ec9d7cabaca211][pubblicato un gist in cui rielabora il layout per adeguarlo alla propria configurazione]].
# Io non uso NANO, quindi servirà qualche ritocco sicuramente.

*** Music
# Di questa parte ho già parlato in [[https://www.zwitterio.it/coding/2022/how-do-i-play-my-lofi-music/][un post dedicato]].
The following lines are widely commented in a [[https://www.zwitterio.it/en/software/how-do-i-play-my-lofi-music/][specific post]].

#+begin_src emacs-lisp :tangle config.el
;; Play Lo-Fi
;; Implementation of the knuth shuffle
;; TODO Start amberol or other music player
(defun nshuffle (sequence)
  (cl-loop for i from (length sequence) downto 2
        do (cl-rotatef (elt sequence (random i))
                    (elt sequence (1- i))))
  sequence)

(setq lofi-links '("https://www.youtube.com/watch?v=8nXqcugV2Y4" ;; 3:30 music session
                   "https://www.youtube.com/watch?v=FVue6P2VoTc"
                   "https://www.youtube.com/watch?v=NrJiXKwUjPI" ;; Music to put you in a better mood
                   "https://www.youtube.com/watch?v=kgx4WGK0oNU"
                   "https://www.youtube.com/watch?v=5qap5aO4i9A"))

(setq vaporwave-links '("https://www.youtube.com/watch?v=nVCs83gSYD0"  ;; architecture in tokyo - Summer Paradise
                        ))

(defun play-lofi ()
  "Play random lofi music on your browser"
  (interactive)
  (shell-command (concat "python -mwebbrowser " (car (nshuffle lofi-links)))))

(defun play-vaporwave ()
  "Play random lofi music on your browser"
  (interactive)
  (shell-command (concat "python -mwebbrowser " (car (nshuffle vaporwave-links)))))
#+end_src

*** Pretty print
# Funzioni che tornano utili in varie situazioni.
# Questa è per la uso per il pretty-printing di HTML, di solito, ma va bene per un qualunque chunk XML:
I usually use this one for pretty printing HTML, but it runs fine on any XML chunk.

#+begin_src emacs-lisp :tangle config.el
(defun bf-pretty-print-xml-region (begin end)
  "Pretty format XML markup in region. You need to have nxml-mode
http://www.emacswiki.org/cgi-bin/wiki/NxmlMode installed to do
this.  The function inserts linebreaks to separate tags that have
nothing but whitespace between them.  It then indents the markup
by using nxml's indentation rules."
  (interactive "r")
  (save-excursion
    (nxml-mode)
    (goto-char begin)
    (while (search-forward-regexp "\>[ \\t]*\<" nil t)
      (backward-char) (insert "\n") (setq end (1+ end)))
    (indent-region begin end)
    (normal-mode))
  (message "Ah, much better!"))
#+end_src

*** Which key
#+begin_quote
Let’s make this popup a bit faster
#+end_quote

# [[https://tecosaur.github.io/emacs-config/config.html#which-key][Dalla configurazione di tecosaur]]:
From [[https://tecosaur.github.io/emacs-config/config.html#which-key][From tecosaur's configuration]]:

#+begin_src emacs-lisp :tangle config.el
(setq which-key-idle-delay 0.5) ;; I need the help, I really do
#+end_src

*** Curriculum Vitae :it:
# TODO make a literate CV
Trovandomi costretto, ancora una volta, a scrivere un CV, mi sono detto, ancora una volta, quanto fosse necessario trovare un modo perché fosse l'ultima.
Eppure, non importa quanto tempo si passi ad ideare degli automatismi, il CV è qualcosa di intrinsecamente in via di definzione, quindi sempre soggetto a cambiamenti.
Non si può fare altro che rimaneggiarlo continuamente. Bisogna quindi focalizzarsi sulla via che garantisca l'attrito minore, così da rendere la pratica degli aggiornamenti non troppo detestabile.
Il generato più importante di un CV, ad oggi, è sempre il formato stampabile, cioè un PDF. Ad un buon PDF si può arrivare principalmente per queste vie:
- LaTeX
- LibreOffice, Microsoft Office o altre suite d'ufficio WYSIWYG
- Immagini (SVG e vettoriali in genere)

A me piacerebbe, però, anche avere una pagina web sempre aggiornata, quindi gestire un file esportabile sia in PDF (più o meno direttamente) che in HTML.
LaTeX è scomodo per esportare in formati web ed io vorrei mantenere una matrice utile ad esportare da ambo i lati con anche piccole differenze (senza mantenere due file o due branch paralleli su git).
C'è chi ottiene questo risultato esportando a partire da un JSON, ma figurarsi se mi metto a scrivere un JSON a mano. Si potrebbe mantenere un YAML/TOML da esportare in JSON che poi esporti nei vari formati, ma comunque mi sembra una strategia poco flessibile.

Sulla base di queste premesse,
[[https://github.com/gicrisf/my-org-resume][ho da poco cominciato a mantenere il mio CV in org-mode]]; poiché l'esportazione avviene attraverso LaTeX (via template AltaCV), torna comoda qualche funzione che tenga in ordine la directory di output ad ogni modifica.

#+begin_src emacs-lisp :tangle config.el
(after! org
  ;; Import ox-latex to get org-latex-classes and other funcitonality
  ;; for exporting to LaTeX from org
  (use-package! ox-latex
    :init
    ;; code here will run immediately
    :config
    ;; code here will run after the package is loaded
    (setq org-latex-pdf-process
          '("pdflatex -interaction nonstopmode -output-directory %o %f"
            "bibtex %b"
            "pdflatex -interaction nonstopmode -output-directory %o %f"
            "pdflatex -interaction nonstopmode -output-directory %o %f"))
    (setq org-latex-with-hyperref nil) ;; stop org adding hypersetup{author..} to latex export
    ;; (setq org-latex-prefer-user-labels t)

    ;; deleted unwanted file extensions after latexMK
    ;; (setq org-latex-logfiles-extensions
    ;;      (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl" "xmpi" "run.xml" "bcf" "acn" "acr" "alg" "glg" "gls" "ist")))

    (unless (boundp 'org-latex-classes)
      (setq org-latex-classes nil))))

(after! org
  (use-package! ox-extra
    :config
    (ox-extras-activate '(latex-header-blocks ignore-headlines))))
#+end_src

*** Manual pages
# Le pagine dei manuali su Emacs mancano spesso di colore, cosa che le rende più difficili da leggere delle loro controparti web.
# Il seguente pacchetto corregge questa mancanza:
The manual pages on Emacs often lack color, which makes them harder to read than their web counterparts.
The following package corrects this deficiency:

#+begin_src emacs-lisp :tangle packages.el
(package! info-colors)
#+end_src

[[https://github.com/ubolonton/info-colors][As shown in the README]], to enable it you have to add a hook in =config.el=.
# per abilitarlo bisogna aggiungere un hook in =config.el=.

#+begin_src emacs-lisp :tangle config.el
(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src

**** COMMENT Screenshots
#+begin_quote
non esporto finché non supporto le immagini in ox-zola
#+end_quote

Lo screenshot dal README:

#+DOWNLOADED: screenshot @ 2022-08-10 14:31:12
[[file:Configurare_Emacs_in_Org-mode/2022-08-10_14-31-12_screenshot.png]]


Qui uno screenshot catturato con il tema city-lights.

#+DOWNLOADED: screenshot @ 2022-08-10 13:34:44
[[file:Configurare_Emacs_in_Org-mode/2022-08-10_13-34-44_screenshot.png]]

*** Games
**** Textual adventures
# GPT
# What is a text-based adventure game?
A text-based adventure game is a computer game in which the player interacts with the game world through text commands inputted by the player, rather than through graphical interfaces. The game typically presents the player with a narrative or puzzle to solve, and the player navigates the game world by typing in commands to perform actions or interact with objects.

# GPT
# Why they relied so much on player's imagination? (or something)
Text-based adventure games relied heavily on players' imagination because the game's interactive fiction format was limited to text descriptions of the game's environment and the player's actions. The player had to use their imagination to visualize the game's setting and their character's surroundings as they explored and interacted with the game world. This made text-based adventure games challenging and engaging, as the player's imagination played a crucial role in bringing the game to life.

With [[https://github.com/speedenator/malyon][Malyon]], you can play your favourite text adventure inside Emacs.

#+begin_src emacs-lisp :tangle packages.el
(package! malyon)
#+end_src

# Why Emacs works well with text-based adventure games?
Emacs works well with text-based adventure games because it is designed to be customizable and extensible, making it easy to create and run interactive command-line programs within the editor. Additionally, Emacs has built-in support for navigating and manipulating text, which is critical for playing text-based adventure games.

#+begin_quote
Malyon is a [[http://ifwiki.org/index.php/Interpreter][Z-machine interpreter]] for playing text-based adventure games such as Zork.
#+end_quote

# GPT
# Tell me about Zork, the textual game
Zork is a classic interactive fiction game that was popular in the 1980s. It was developed by MIT students in the late 1970s and was originally called Dungeon. Zork was a text-based adventure game where players typed commands to explore a fantasy world and solve puzzles. The game was known for its sense of humor and imaginative world-building. It has since inspired many other similar text-based adventure games.

Download Zork and other games from:
- [[http://www.ifarchive.org/indexes/if-archiveXgamesXzcode.html][Iteractive Fiction Archive]],
- [[https://ifdb.org/][Interactive Fiction Database]],

or make your own with [[https://www.emacswiki.org/emacs/InformMode][InformMode]].

# Secondo me si potrebbe sviluppare un gioco con org-mode
# Prima di convertire Inform mode per il literate approach sarebbe meglio studiare bene Inform
# Non ho tempo al momento, ma si tratta di un progettino potenzialmente interessante
# Check [[https://github.com/lmintmate/malyon][this fork]] if you encounter some problem.

*** Dashboard
**** Open org configuration (SPC o c)
# Al posto di aprire la cartella =.doom.d= per configurare Emacs, da ora in avanti vogliamo aprire questo file direttamente, quindi la funzione nella dashboard va modificata.
# Per riuscirci, innanzitutto dobbiamo creare una funzione che apra questo file.
Instead of opening the folder =.doom.d= to configure Emacs, from now on we want to open this file directly, so the function in the dashboard needs to be modified. To do this, we first need to create a function that opens this file.

# Ci servono due elementi, che possono variare di caso in caso:
# - Il nome del file
# - La directory in cui cercarlo
We need two elements that may vary in each case:
- The name of the file
- The directory in which to search for it

#+begin_src emacs-lisp :tangle config.el
(setq config-org-file-name "config.org"
      config-org-directory "~/.doom.d")
#+end_src

# Scriviamo una funzione dedicata all'apertura del file preselezionato.
We write a function dedicated to opening the right file.

#+begin_src emacs-lisp :tangle config.el
(defun open-config-org ()
  "Open your private config.org file."
  (interactive)
  (find-file (expand-file-name config-org-file-name config-org-directory)))
#+end_src

# Shortcut
# Assegniamo una scorciatoia da tastiera dedicata, sulle orme di =SPC+f+P= (file > Private).
We assign a dedicated keyboard shortcut, following in the footsteps of =SPC+f+P= (file > Private).
[[https://www.dschapman.com/notes/bde6e938-0984-4d60-974d-77178f1ecd9b][How?]]

#+begin_quote
In your =config.el= file add a map declaration using the =:leader= attribute and whatever prefix key you would like to use. Then after you have added the necessary prefix keys add a =:desc "Description of the command"= ="key" #'elisp-command-to-execute= for each shortcut you wish to add.
#+end_quote

Using =map!=:

# (SPC open/configuration)
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("o" . "open")
       :desc "Open your private config.org file." "c" #'open-config-org))
#+end_src

# Dashboard
# Per intervenire sul menù, prima diamo un'occhiata alle sezioni della dashboard.
To intervene on the menu, let's first take a look at the sections of the dashboard.

#+begin_src emacs-lisp
(cl-subseq +doom-dashboard-menu-sections 0)
#+end_src

# Otteniamo una lista, da cui estrapoliamo la funzione che vogliamo sostituire (questa):
We obtain a list, from which we extract the function we want to replace (this one).

#+begin_src emacs-lisp
("Open private configuration" :icon (all-the-icons-octicon "tools" :face 'doom-dashboard-menu-title) :when (file-directory-p doom-private-dir) :action doom/open-private-config)
#+end_src

# Come intendiamo modificarla? Così:
How do we intend to edit it? Like this:

#+name: open-org-configuration-menu-section
#+begin_src emacs-lisp
("Open org configuration" :icon (all-the-icons-octicon "tools" :face 'doom-dashboard-menu-title) :action open-config-org)
#+end_src

# Intanto teniamo questa funzione da parte col nome di =open-org-configuration-menu-section=.

# Ora sostituiamola al menù [[https://stackoverflow.com/questions/170931/replace-an-item-in-a-list-in-common-lisp][con la funzione =setf=]].
#
Now let's replace it in the menu with the =setf= function (like shown [[https://stackoverflow.com/questions/170931/replace-an-item-in-a-list-in-common-lisp][on StackOverflow]]).

#+begin_src emacs-lisp :tangle config.el :noweb yes
(setf (nth 5 +doom-dashboard-menu-sections) '<<open-org-configuration-menu-section>>)
#+end_src

**** Enter Elfeed (SPC e e)
# Ripercorro i passi fatti prima, ma stavolta senza dilungarmi in chiacchiere.
I retrace the steps taken before, but this time without delving into chatter.

# Shortcut

# Prima assegno una scorciatoia da tastiera:
First, I assign a keyboard shortcut:

# SPC elfeed enter
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("e" . "elfeed")
       :desc "Enter elfeed." "e" #'elfeed))
#+end_src

# Dashboard

# Voglio questo elemento sulla dashboard:
I want this element on the dashboard.

#+name: open-elfeed-menu-section
#+begin_src emacs-lisp
("Open elfeed" :icon (all-the-icons-octicon "rss" :face 'doom-dashboard-menu-title) :action elfeed)
#+end_src

# Stavolta vado a sostituire il terzo elemento, che raramente uso (=Recently opened files=).
This time I am going to replace the third element, which I rarely use (=Recently opened files=).

#+begin_src emacs-lisp :tangle config.el :noweb yes
(setf (nth 2 +doom-dashboard-menu-sections) '<<open-elfeed-menu-section>>)
#+end_src

# Già che ci siamo, aggiungiamo una shortcut per aggiornare elfeed:
Since we're at it, let's add a shortcut to update Elfeed.

#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("e" . "elfeed")
       :desc "Update all the feeds in elfeed." "u" #'elfeed-update))
#+end_src

**** Quit and go Home (SPC q h)
# Una semplice scorciatoia da tastiera per tornare alla dashboard:
A simple keyboard shortcut to return to the dashboard:

# SPC quit (and go) home
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("q" . "quit/session")
       :desc "Switch to the dashboard in the current window, of the current FRAME." "h" #'+doom-dashboard/open))
#+end_src

**** Org Manual (SPC o i)
Move "Open project" section of the dashboard and make space for the documentation.

# Anche stavolta andiamo avanti velocemente.
This time too we move forward quickly.

# Voglio questo elemento sulla dashboard:
I need this element on my dashboard:

#+name: open-docs-menu-section
#+begin_src emacs-lisp
("Open info" :icon (all-the-icons-octicon "info" :face 'doom-dashboard-menu-title) :action info)
#+end_src

# Stavolta vado a sostituire il terzo elemento, che raramente uso (=Recently opened files=).
This time I am going to replace the third element, which I rarely use (=Recently opened files=).

#+begin_src emacs-lisp :tangle config.el :noweb yes
(setf (nth 3 +doom-dashboard-menu-sections) '<<open-docs-menu-section>>)
#+end_src

# Riprendiamo l'elemento rimosso...
We take back the removed element...

#+name: switch-project-menu-section
#+begin_src emacs-lisp
("Open project" :icon (all-the-icons-octicon "briefcase" :face 'doom-dashboard-menu-title) :action projectile-switch-project)
#+end_src

# ... e sistemiamolo in prima posizione:
...and let's put it in first position.

#+begin_src emacs-lisp :tangle config.el :noweb no-export
(setf (nth 0 +doom-dashboard-menu-sections) '<<switch-project-menu-section>>)
#+end_src

Let's add a shortcut for org-mode, since I refer to it frequently.

# SPC elfeed enter
#+begin_src emacs-lisp :tangle config.el
(map! :leader
      (:prefix-map ("o" . "open")
       :desc "Open org manual." "i" #'org-info))
#+end_src

**** Doom documentation (SPC h d h)
Just changing the name.

#+name: open-doom-docs-menu-section
#+begin_src emacs-lisp
("Doom documentation" :icon (all-the-icons-octicon "book" :face 'doom-dashboard-menu-title) :action doom/help)
#+end_src

Let's leave it in sixth position.

#+begin_src emacs-lisp :tangle config.el :noweb no-export
(setf (nth 6 +doom-dashboard-menu-sections) '<<open-doom-docs-menu-section>>)
#+end_src

**** COMMENT Banner
Experimental.
Just trying stuff out, but I stick with the regular banner for the moment.

See [[https://discourse.doomemacs.org/t/how-to-change-your-splash-screen/57][this discourse post]].

A weebish example (not tangled code):
# :tangle config.el
#+begin_src emacs-lisp
(defun my-weebery-is-always-greater ()
  (let* ((banner '("⢸⣿⣿⣿⣿⠃⠄⢀⣴⡾⠃⠄⠄⠄⠄⠄⠈⠺⠟⠛⠛⠛⠛⠻⢿⣿⣿⣿⣿⣶⣤⡀⠄"
                   "⢸⣿⣿⣿⡟⢀⣴⣿⡿⠁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣸⣿⣿⣿⣿⣿⣿⣿⣷"
                   "⢸⣿⣿⠟⣴⣿⡿⡟⡼⢹⣷⢲⡶⣖⣾⣶⢄⠄⠄⠄⠄⠄⢀⣼⣿⢿⣿⣿⣿⣿⣿⣿⣿"
                   "⢸⣿⢫⣾⣿⡟⣾⡸⢠⡿⢳⡿⠍⣼⣿⢏⣿⣷⢄⡀⠄⢠⣾⢻⣿⣸⣿⣿⣿⣿⣿⣿⣿"
                   "⡿⣡⣿⣿⡟⡼⡁⠁⣰⠂⡾⠉⢨⣿⠃⣿⡿⠍⣾⣟⢤⣿⢇⣿⢇⣿⣿⢿⣿⣿⣿⣿⣿"
                   "⣱⣿⣿⡟⡐⣰⣧⡷⣿⣴⣧⣤⣼⣯⢸⡿⠁⣰⠟⢀⣼⠏⣲⠏⢸⣿⡟⣿⣿⣿⣿⣿⣿"
                   "⣿⣿⡟⠁⠄⠟⣁⠄⢡⣿⣿⣿⣿⣿⣿⣦⣼⢟⢀⡼⠃⡹⠃⡀⢸⡿⢸⣿⣿⣿⣿⣿⡟"
                   "⣿⣿⠃⠄⢀⣾⠋⠓⢰⣿⣿⣿⣿⣿⣿⠿⣿⣿⣾⣅⢔⣕⡇⡇⡼⢁⣿⣿⣿⣿⣿⣿⢣"
                   "⣿⡟⠄⠄⣾⣇⠷⣢⣿⣿⣿⣿⣿⣿⣿⣭⣀⡈⠙⢿⣿⣿⡇⡧⢁⣾⣿⣿⣿⣿⣿⢏⣾"
                   "⣿⡇⠄⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢻⠇⠄⠄⢿⣿⡇⢡⣾⣿⣿⣿⣿⣿⣏⣼⣿"
                   "⣿⣷⢰⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⢰⣧⣀⡄⢀⠘⡿⣰⣿⣿⣿⣿⣿⣿⠟⣼⣿⣿"
                   "⢹⣿⢸⣿⣿⠟⠻⢿⣿⣿⣿⣿⣿⣿⣿⣶⣭⣉⣤⣿⢈⣼⣿⣿⣿⣿⣿⣿⠏⣾⣹⣿⣿"
                   "⢸⠇⡜⣿⡟⠄⠄⠄⠈⠙⣿⣿⣿⣿⣿⣿⣿⣿⠟⣱⣻⣿⣿⣿⣿⣿⠟⠁⢳⠃⣿⣿⣿"
                   "⠄⣰⡗⠹⣿⣄⠄⠄⠄⢀⣿⣿⣿⣿⣿⣿⠟⣅⣥⣿⣿⣿⣿⠿⠋⠄⠄⣾⡌⢠⣿⡿⠃"
                   "⠜⠋⢠⣷⢻⣿⣿⣶⣾⣿⣿⣿⣿⠿⣛⣥⣾⣿⠿⠟⠛⠉⠄⠄          "))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat line (make-string (max 0 (- longest-line (length line))) 32)))
               "\n"))
     'face 'doom-dashboard-banner)))

(setq +doom-dashboard-ascii-banner-fn #'my-weebery-is-always-greater)
#+end_src

*** COMMENT Zen mode
# Usiamo un font seriffato:
Using a serif font for Zen mode:

# :tangle config.el
#+begin_src emacs-lisp
(defvar +zen-serif-p t
  "Whether to use a serifed font with `mixed-pitch-mode'.")
#+end_src

Detangled because I don't like this anymore. Maybe I should look for a totally different font with Zen mode.

*** Weather
# [[https://github.com/bcbcarl/emacs-wttrin/][Esiste già un frontend per Emacs]], ma è da almeno cinque anni che non dà segni di manutenzione. Quindi [[https://github.com/gicrisf/emacs-wttrin][lavorerò sul mio fork]] (tanto avevo comunque intenzione di aggiungere funzioni supplementari, avrei probabilmente forkato a prescindere).
[[https://github.com/bcbcarl/emacs-wttrin/][There is already a frontend for Emacs]], but it has not shown any signs of maintenance for at least five years. Therefore, [[https://github.com/gicrisf/emacs-wttrin][I will work on my fork]] (since I intended to add additional functions anyway, I would have probably forked it regardless).

# Innanzitutto aggiungiamo questo pacchetto:
First, let's add this package:

#+begin_src emacs-lisp :tangle packages.el :noweb yes
(package! wttrin :recipe (:host github :repo "gicrisf/emacs-wttrin"))
#+end_src

# Qui lo configuro secondo le mie necessità:
Here, I configure it according to my needs:

#+begin_src emacs-lisp :tangle config.el :noweb yes
(setq wttrin-default-cities '("Caltagirone" "Bologna" "Ferrara" "Catania"))
(setq wttrin-default-accept-language '("Accept-Language" . "it-IT"))
#+end_src

*** COMMENT Protonmail :it:
Quando Protonmail ha rilasciato ProtonBridge mi sono chiesto se non valesse la pena di ritentare un approccio locale alle email.
Le alternative apprezzabili per il momento mi sembrano due:
- Mozilla Thunderbird
- Emacs

Thunderbird ha di recente ricevuto un importante aggiornamento che ha fatto fare all'app un apparente salto di qualità, anche in termini di design, cosa che sicuramente torna utile in un client email del 2022 in competizione con delle web app sempre più piacevoli da vedere.

Emacs, d'altra parte, mi consentirebbe di scrivere le email in org-mode ed all'interno di un sistema integrato con il mio flusso di lavoro abituale; posso persino scrivere in un buffer separato mentre mi occupo di qualcos'altro nel buffer principale ecc. La comodità di avere tutto a portata di shortcut è irresistibile, soprattutto se non c'è troppo da smanettare con strani script arrangiati in casa.
Per una volta, mi trovo dinnanzi un servizio che supporta i client locali, anziché antagonizzarli (sì gmail, guardo proprio te).
Per fortuna, c'è già che chi si è portato avanti su questa strada:
- [[https://shom.dev/posts/20220108_setting-up-protonmail-in-emacs/][shom.dev]]
- [[https://systemcrafters.net/emacs-mail/][system crafters]]
- [[http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-/][Caches to Caches (Gregory J. Stein)]]
- [[https://jherrlin.github.io/posts/emacs-mu4e/][jherrlin.github.io]]

Il primo post, in particolar modo, torna utile per la sua brevità. Cosa bisogna fare?

#+begin_quote
*ATTENZIONE!*

Prima di continuare, tieni a mente che Proton Bridge è un servizio fornito solo ai possessori di un account premium.
Io l'ho scoperto troppo tardi, motivo per cui lascerò tutto nel mio file di configurazione (potrebbe tornare utile in futuro), ma per ora non aggroviglierò nulla.
#+end_quote

**** Installare ProtonBridge
Da AUR:

#+begin_src bash
yay protonmail-bridge
#+end_src

Si tratta di un'applicazione open source che rimane aperta in background e genera tutti i file necessari per autenticarsi in sicurezza mediante un client esterno.
Apprezzo il fatto che non sia un'app di Electron, ma che il frontend sia in Qt. Ciononostante, comunque temo un po' per il consumo sul mio laptop.

**** Installare mbsync
Innanzitutto, è necessario installare e configurare =mbsync=. Sarebbe materia per i miei literate dotfiles, ma al fine di tenere tutto in un posto preferisco gestire da qui anche questo.

#+begin_src bash
sudo pacman -S isync
#+end_src

**** Configurazione di mbsync
La configurazione di mbsync è l'ennesimo dotfile sulla home, =~/.mbsyncrc=:

# User giovanni . crisalfi at...
# :tangle ~/.mbsyncrc
#+begin_src txt
IMAPAccount proton
Host 127.0.0.1
User user@protonmail.com
PassCmd "cat ~/.protonBridgePass"
SSLType NONE
CertificateFile /etc/ssl/certs/ca-certificates.crt

IMAPStore proton-remote
Account proton

MaildirStore proton-local
Subfolders Verbatim
Path ~/mail/proton
Inbox ~/mail/proton/inbox

Channel proton
Far :proton-remote:
Near :proton-local:
Patterns *
Create Both
SyncState *
#+end_src

**** Configurazione di mu4e
Su Doom Emacs, è possibile abilitare il modulo =mu4e= onde avere quasi tutto l'occorrente.

Passiamo alla configurazione di mu4e.
- Ricerca delle mail ogni mezzora;
- Recupero delle mail attraverso =mbsync=;
- Tutte le mail finiscono nella home, sotto la cartella mail.
- Le shortcut per il momento seguono la notazione inglese.

# :tangle config.el
#+begin_src emacs-lisp
(setq mu4e-change-filenames-when-moving t ; avoid sync conflicts
      mu4e-update-interval (* 30 60) ; check mail 30 minutes
      mu4e-compose-format-flowed t ; re-flow mail so it's not hard wrapped
      mu4e-get-mail-command "mbsync -a"
      mu4e-maildir "~/mail/proton")

(setq mu4e-drafts-folder "/proton/Drafts"
      mu4e-sent-folder   "/proton/Sent"
      mu4e-refile-folder "/proton/All Mail"
      mu4e-trash-folder  "/proton/Trash")

(setq mu4e-maildir-shortcuts
      '(("/proton/inbox"     . ?i)
    ("/proton/Sent"      . ?s)
    ("/proton/Trash"     . ?t)
    ("/proton/Drafts"    . ?d)
    ("/proton/All Mail"  . ?a)))
#+end_src

**** Configurazione SMTP
Il supporto SMTP è integrato nativamente in Emacs con =smtpmail=.
Non c'è bisogno di installare nulla qui.
Il server SMTP potrebbe interferire con altri server locali? Esempio quello di Zola?

# :tangle config.el
#+begin_src emacs-lisp
(setq message-send-mail-function 'smtpmail-send-it
      auth-sources '("~/.authinfo") ;need to use gpg version but only local smtp stored for now
      smtpmail-smtp-server "127.0.0.1"
      smtpmail-smtp-service 1025
      smtpmail-stream-type  'ssl)
#+end_src

**** Componi le email con org-mode
Installiamo =org-msg= per scrivere le mail in org mode ed esportarle in HTML.

#+begin_quote
[[https://github.com/jeremy-compostella/org-msg][OrgMsg]] is a GNU Emacs global minor mode mixing up Org mode and your Mail User Agent Mode (Message mode, mu4e mode, or notmuch mode) to compose and reply to emails in a Outlook HTML friendly style.
#+end_quote

Senza questa accortezza, invieremmo delle mail in puro testo, che sarebbe una cosa pure profondamente amabile, ma qualche tempo fa ho constatato che molti client email tendono ad inserire tra lo spam qualunque cosa non sia formattata in HTML. Lo so, questa idea malsana di introdurre la formattazione HTML per le mail ha rovinato le mail stesse, ma ormai è troppo tardi per opporsi.

# :tangle packages.el
#+begin_src emacs-lisp
(package! org-msg)
#+end_src

Concludiamo con la configurazione minima di =org-msg=.

# :tangle config.el
#+begin_src emacs-lisp
(setq mail-user-agent 'mu4e-user-agent)
(require 'org-msg)

(setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
      org-msg-startup "hidestars indent inlineimages"
      org-msg-default-alternatives '((new . (text html))
                                     (reply-to-html . (text html))
                                     (reply-to-text . (text)))
      org-msg-convert-citation t)

(org-msg-mode)
#+end_src

*** mol2chemfig :it:
Poiché non sento d'avere controllo di qualcosa se non è prima stato informatizzato e parametrizzato dalle fondamenta, trovo poco sopportabile scrivere di chimica dovendo vivere di immagini appiccicate da chissà dove o, anche peggio, dovendo generare, editare e manipolare a mano ogni singola immagine contenente una formula di struttura. È tedioso, a dir poco. Ancora più tedioso è descrivere a mano la molecola perché pacchetti LaTeX siano capaci di renderizzare la molecola finita, soprattutto se parliamo di molecole di grand dimensioni, ma questa via ha il vantaggio di essere informatizzata e parametrizzata sino alle ossa, quindi non c'è dubbio che io la preferisca. Per questo motivo, mi sono messo in testa di dovere automatizzare il più possibile il processo di scrittura delle molecole attraverso un meraviglioso pacchetto LaTeX chiamato =chemfig=. Si tratta di un pacchetto che si occupa di disegnare le molecole via 'TikZ' e che può vantare un'ottima sintassi, semplice ma versatile, soprattutto quando si viene agli angoli di legame. Finché si tratta di piccole molecole non è difficile tenere a mente la sequenza dei legami, ma oltre un certo numero di atomi il processo può farsi decisamente più tedioso di quello tradizionale, quindi si rende necessario passare attraverso una GUI.

Anziché generare delle immagini da copiare ed incollare in giro, però, è una soluzione decisamente più pulita quella di esportare delle stringhe di testo che siano riproducibilmente convertite nello stesso diagramma. Chemfig è chiaramente un ottimo ponte di mezzo. Abbiamo bisogno di qualcosa che trasformi i nostri SMILES o =mol= files in stringhe che Chemfig sia in grado di interpretare.
È qui che =mol2chemfig= si rende decisamente utile. Si tratta di un piccolo programma python per convertire stringhe SMILES o =mol= in stringhe =chemfig=.

Qualcuno potrebbe chiedersi: perché non usare direttamente le immagini generate con l'editor o gli SMILES, a questo punto. La risposta è semplice: perché è molto più semplice intervenire al volo su una stringa di Chemfig per manipolare il diagramma, pur lasciando possibilmente intatto il nucleo della molecola. Si possono variare opportunamente gli angoli di legame, i sostituenti, il tutto senza lasciare l'editor. Il problema rimane dover lasciare l'editor per lanciare =mol2chemfig=. Potremmo aprire un emulatore di terminale nel frame a fianco, ma rimane una soluzione scomoda ed inelegante. È qui che subentra il bello di vivere dentro Emacs: possiamo configurarlo perché sia lui a fare il lavoro al posto nostro.

Ci troviamo dinnanzi alle seguenti vie:
- Scrivere un port di =mol2chemfig= in emacs lisp;
- Richiamare =mol2chemfig= come libreria Python all'interno di uno script emacs lisp (per mezzo di =Pymacs=, che si situerebbe all'interfaccia);
- Lanciare =mol2chemfig= nella shell e catturare l'output.

La prima soluzione è la più elegante, ma anche la più energivora. Io non ho il tempo e le risorse necessarie al momento per affrontare un simile cammino, anche se mi piacerebbe.
L'idea di utilizzare Pymacs è allettante, ma non ha i benefici della prima via, né riesce a cavarci dagli impicci in cui ci pone la terza.
Quest'ultima, infatti, richiede che =mol2chemfig= sia installato globalmente, altrimenti il comando inevitabilmente fallirà. Potrebbe anche essere la via più lenta, ma parliamo di frazioni di secondo che non sono sinceramente particolarmente preoccupanti. Si tratta anche del metodo più efficiente dal punto di vista dello sviluppo, tanto da potere essere affrontato qui nella configurazione generale.
Ecco perché ne parlo in questa sede; ecco perché l'ho scelto. Riservo per il futuro l'ambizione di riscrivere il modulo in elisp. Nel frattempo, eccoci qua.

Di cosa abbiamo bisogno? Innanzitutto, come dicevo, dobbiamo assicurarci che =mol2chemfig= sia installato.
Per comodità, io installo una riproposizione in Python3 chiamata [[https://github.com/Augus1999/mol2chemfigPy3][=mol2chemfigPy3=]].

#+begin_src bash
$ pip install -U mol2chemfigPy3
#+end_src

Viene installata anche una dipendenza vitale, cioè Indigo:

#+begin_src
Successfully installed epam.indigo-1.7.4 mol2chemfigPy3-1.5.7
#+end_src

Al momento dell'installazione, queste sono le versioni:
- indigo 1.7.4
- mol2chemfig 1.5.7

Poiché pip potrebbe installare al di fuori dal PATH, per sicurezza meglio lanciare il comando attraverso Python.
Visto che dobbiamo scriptare, non vale la pena di imbattersi in inutili ed evitabili errori. Scriveremo quindi non =mol2chemfig= ma:

#+begin_src bash
python -m mol2chemfigPy3
#+end_src

Per testare la conversione di uno SMILES,

#+begin_src bash :results output latex
python -m mol2chemfigPy3 -zw -i direct "C1=CC=C(C=C1)O"
#+end_src

#+RESULTS:
#+begin_export latex
\chemfig{OH-[:180,,1]=_[:240]-[:180]=_[:120]-[:60]=_(-[:300])}
#+end_export

Non resta che scrivere una semplice funzione elisp per automatizzare il lancio di questo comando a partire da uno SMILES in input.
[[https://emacs.stackexchange.com/a/30273][Come illustrato da Dan, su StackExchange di Emacs]], questo è un modo molto semplice per lanciare un comando attraverso la shell ed inserire l'output nel buffer attuale.

#+begin_src emacs-lisp
(defun insert-shell-command-output (command)
  "Get shell COMMAND output and insert it at point in current
buffer."
  (insert (shell-command-to-string command)))
#+end_src

[[https://stackoverflow.com/a/15528629/13436102][Come fa notare sds su StackOverflow]], =call-process= sarebbe più veloce, perché è una funzione che non aspetta la mediazione della shell, ma si tratta di uno script da richiamare all'occorrenza e per il momento le performance possono anche essere messe da parte. Ci torneremo in un altro momento, nel frattempo è bene lavorare su questo.
Perché una funzione possa essere richiamabile, va introdotta da =(interactive)=, quindi scriviamola tenendone conto:

#+begin_src emacs-lisp :tangle config.el
(defun mol2chemfig (mol)
  "Generate chemfig code from mol or SMILES."
  (interactive "sEnter molecule: ")
  (insert (shell-command-to-string (concat "python -m mol2chemfigPy3 -w -i direct " mol))))
#+end_src

Ora possiamo tornare a scrivere i nostri documenti senza dover più rimbalzare da un software all'altro.
Sia lodato Emacs, il sacro editor.

Così abbiamo coperto il caso base. Non resta che scrivere funzioni che tengano conto delle varie impostazioni di =mol2chemfig=.

*** tochemfig :it:
Finora abbiamo dato per scontato che l'utente introduca direttamente nel minibuffer la stringa da convertire, ma in verità potremmo anche disporre di un file. =mol2chemfig= di default si aspetta, questo, quindi basta lanciare il comando senza =-i direct= per poter lavorare con il percorso di un file. Rinominando la funzione coerentemente, scriveremmo:

#+begin_src emacs-lisp
(defun mol2chemfig-from-file (molpath)
  "Generate chemfig code from molfiles."
  (interactive "sEnter molecule file path: ")
  (insert (shell-command-to-string (concat "python -m mol2chemfigPy3 -zw " molpath))))
#+end_src

Removing whitespaces.

#+begin_src emacs-lisp
(defun mol2chemfig-terse (mol)
  "Generate chemfig code from mol or SMILES without whitespace and comments."
  (interactive "sEnter molecule: ")
  (insert (shell-command-to-string (concat "python -m mol2chemfigPy3 -zw -i direct " mol))))
#+end_src

Potremmo andare avanti ancora per un pezzo, ma questo è un pessimo approccio, perché implica siano scritte tutte le combinazioni possibili. Sarebbe molto meglio partire da un default considerata la funzione preferita dall'utente (quindi configurabile via lisp) e che poi le funzioni supplementari varino il comando di default, lasciando il resto intatto. Potremmo passare gli argomenti, ma il bello di Emacs è proprio avere funzioni verbose, perché così si può lanciare il comando desiderato anche senza ricordare a memoria le flags. Per arrivare al risultato desiderato si può passare per varie vie: una, più vicina al comando reale, prevede l'introduzione di argomenti facoltativi nella funzione principale. Un'altra passa per un dedalo di condizioni if/else che verifichino prima se la funzione specifica sia stata esplicitamente espressa, poi quale sia il default e compongano così il comando finale. Un modulo dedicato potrebbe tenere conto di entrambi gli approcci, così da offrire la massima flessibilità possibile all'utente.

Per un ipotetico pacchetto dedicato chiamato =tochemfig=, i default divergenti dall'impostazione di =mol2chemfig= potrebbero essere indicati nel modo seguente.

#+begin_src emacs-lisp :tangle config.el
(setq tochemfig-default-input "direct")
(setq tochemfig-default-relative-angles t)
(setq tochemfig-default-fancy-bonds t)
(setq tochemfig-default-wrap-chemfig t)
#+end_src

Anziché proseguire con le speculazioni, non mi resta che proseguire il lavoro su =tochemfig.el= e renderlo disponibile attraverso [[https://github.com/gicrisf/tochemfig][questa repo]]. In attesa che =tochemfig= sia concluso, o anche nel caso di un uso occasionale con pochi comandi, un approccio come quello sopra è più che sufficiente.

Installiamo il pacchetto:

#+begin_src emacs-lisp :tangle packages.el :noweb yes
(package! tochemfig :recipe (:host github :repo "gicrisf/tochemfig"))
#+end_src

*** COMMENT orgtochemfig :it:
Since I usually write LaTeX code from org-mode, I find annoying to wrap the code in latex exporter all the time. Let's get rid of the problem writing some lispy code.

Siccome devo modificare il comportamento di una funzione preferibilmente senza inficiare il codice della libreria originale, la cosa più immediata sarebbe quella di agganciare il lavoro delle funzioni di tochemfig, per esempio di =tochemfig-default=, per iniziare con la funzione più facile da approcciare.

#+begin_quote
When you need to modify a function defined in another library [...] or basically any variable or object field which holds a function value, you can use the appropriate setter function, such as fset or defun for named functions, setq for hook variables, or set-process-filter for process filters, but those are often too blunt, completely throwing away the previous value.

*The advice feature lets you add to the existing definition of a function, by advising the function*. This is a cleaner method than redefining the whole function.
#+end_quote

Un esempio che consente di modificare il valore restituito dalla funzione tutte le volte che viene lanciata:

#+begin_src emacs-lisp
(defun my-double (x)
  (* x 2))
(defun my-increase (x)
  (+ x 1))
(advice-add 'my-double :filter-return #'my-increase)

(my-double 2)
#+end_src

#+RESULTS:
: 5

A me interessa che Emacs sappia che quando scrivo in org-mode è necessario l'exporter. Va detto pure che magari io sono già dentro un blocco e allora non voglio aggiungere blocchi dentro blocchi, in a nested fashion. Not at all. I prefer using different function's names: this gives the control to the user.

*** COMMENT Whisper (Speech to Text)
I simply find this interesting, so I want to try it.

# :tangle packages.el
#+begin_src emacs-lisp
(package! whisper)
#+end_src

# :tangle config.el
#+begin_src emacs-lisp
(use-package whisper
  :bind ("C-H-r" . whisper-run)
  :config
  (setq whisper-install-directory "/tmp/"
        whisper-model "base"
        whisper-language "en"
        whisper-translate nil))
#+end_src

*** COMMENT My life in Emacs: EXWM
I'm a Gnome user, but I think it would be nice to have the EXWM option, especially because I'm interested to study the power consumption.

# :tangle packages.el
#+begin_src emacs-lisp
(package! exwm)
#+end_src

Not tangled, because it's experimental.
# :tangle config.el
#+begin_src emacs-lisp
 (use-package exwm
    :init
    ;; (require 'exwm-randr)
    (exwm-enable)
    ;; (tsa/safe-load-file "~/local-config.el")
    (exwm-randr-enable) ; https://github.com/ch11ng/exwm/wiki
    ;; (defvar efs/polybar-process nil
    ;;  "Holds the process of the running Polybar instance, if any")
#+end_src

*** COMMENT Quick browsing
**** Deft
Set directory, extension to search for and explicitly say you want to search recursively in the subfolders.

# :tangle config.el
#+begin_src emacs-lisp
;; Not using deft rn
(setq deft-directory "~/org"
      deft-extensions '("org" "txt"))
(setq deft-recursive t)
#+end_src

The main function is too heavy and I don't really need using all deft features.
I'm detangling this block because I prefer simply using =SPC n s= for the moment (notes/search note).
# La funzione principale per me è troppo lenta, oltre ad essere fin troppo fornita. Per ora disabilito tutto, perché preferisco usare =SPC+n+s= (notes/search note).

**** Rifle
# Per il momento ne faccio a meno per lo stesso motivo per cui ho disabilitato deft (vedi più avanti).
I'm living without right now for similar reasons on why I disabled DEFT (see later); so, I leave the line commented.

#+begin_src emacs-lisp :tangle packages.el
;; (package! helm-org-rifle)
#+end_src

*** COMMENT Backtab
I should find an alternative way, because this one doesn't work, so I'm de-tangling it.

# :tangle config.el
#+begin_src emacs-lisp
;; Source: [[https://stackoverflow.com/questions/23692879/emacs24-backtab-is-undefined-how-to-define-this-shortcut-key]]
(global-set-key (kbd "<backtab>") 'un-indent-by-removing-4-spaces)
(defun un-indent-by-removing-4-spaces ()
  "remove 4 spaces from beginning of of line"
  (interactive)
  (save-excursion
    (save-match-data
      (beginning-of-line)
      ;; get rid of tabs at beginning of line
      (when (looking-s "^\\at-+")
        (untabify (match-beginning 0) (match-end 0)))
      (when (looking-at "^    ")
        (replace-match "")))))
#+end_src

*** ChatGPT
OpenAI's packages:

#+begin_src emacs-lisp :tangle packages.el
(package! openai :recipe (:host github :repo "emacs-openai/openai"))
(package! chatgpt :recipe (:host github :repo "emacs-openai/chatgpt"))
#+end_src

# Recuperiamo l'API key da variabile d'ambiente:
Retrieving the API key from the env var:

#+begin_src emacs-lisp :tangle config.el
(setq openai-key (getenv "OPENAI_KEY"))
#+end_src

# Una dipendenza cosmetica di questi pacchetti è spinner.
# Selezioniamo lo spinner preferito:
A cosmetic dependency of these packages is spinner.
Let's select the preferred spinner.

#+begin_src emacs-lisp :tangle packages.el
;; (setq chatgpt-spinner-type 'rotating-line)
(setq chatgpt-spinner-type 'minibox)
#+end_src

# Questo viene più comodo per selezionare del testo ed elaborarlo direttamente, ma non usa le API:
This is more convenient for selecting text and processing it directly, but it does not use the APIs.

#+begin_src emacs-lisp :tangle packages.el
;; (package! chatgptel :recipe (:host github :repo "joshcho/ChatGPT.el"))
#+end_src

# Diamo il path della repo perché ha bisogno di richiamare un file Python che agisce da server:
We give the path of the repository because it needs to invoke a Python file that acts as a server.

#+begin_src emacs-lisp :tangle config.el
(setq chatgpt-repo-path "~/Projects/ChatGPT.el/")
#+end_src

# La funzione =chatgpt--query= non va a causa dell'impiego di una macro anaforica che coinvolge due =eval=; potrei semplificarla in questo modo:
The =chatgpt--query= function doesn't work because of the use of an anaphoric macro that involves two =eval=; I could simplify it in this way:

#+begin_src emacs-lisp
(defun chatgpt--query (query)
  "Send QUERY to the ChatGPT process."
  (unless chatgpt-process
    (chatgpt-init))
  (let ((saved-id (cl-incf chatgpt-id)))
    (chatgpt--insert-query query saved-id)
    (when chatgpt-enable-loading-ellipsis
      (chatgpt--add-timer saved-id))
    (when chatgpt-display-on-query
      (chatgpt-display))
    (deferred:$
     (deferred:$
      (epc:call-deferred chatgpt-process 'query (list query))
      (deferred:nextc it
               (lambda (response)
                 (chatgpt--stop-wait ,saved-id)
                 (chatgpt--insert-response response ,saved-id)
                 (when chatgpt-display-on-response
                   (chatgpt-display))))))))
#+end_src

# Volendo, potrei usare qualche advice per sovrascriverla temporaneamente.
If I wanted to, I could use some advice to temporarily overwrite it.
# Il problema è che questa libreria nello specifico non usa le API di ChatGPT ed io ne preferirei una che le usa.
# Quindi, per arrivare ad un risultato che mi piaccia, dovrei modificare pure le funzioni nel server, cosa che mi porterebbe a gestire un fork.
The problem is that this specific library does not use the ChatGPT APIs, and I would prefer one that does.
So, to achieve a result that I like, I would also have to modify the functions in the server, which would lead me to manage a fork.

# Non so se ho voglia di mantenere un fork. Vediamo se ci sono alternative.
I don't know if I feel like maintaining a fork.
Let's see if there are alternatives.

[[https://github.com/karthink/gptel][This one, instead, is called gptel]] e usa le API:

#+begin_src emacs-lisp :tangle packages.el
(package! gptel :recipe (:host github :repo "karthink/gptel"))
#+end_src

# Anche qui, recuperiamo la key:
Here too, we recover the key:

#+begin_src emacs-lisp :tangle config.el
(setq gptel-api-key (getenv "OPENAI_KEY"))
#+end_src

# Proviamo il seguente prompt con gptel:
Let's try the following prompt with gptel.

#+begin_quote
Tell me about the geography of Taiwan.
#+end_quote

This is the result:

#+begin_quote
Taiwan is an island located off the southeastern coast of China. It has rugged, mountainous terrain, with more than half of its land area covered in forest. The western side of the island is more densely populated and urbanized, while the eastern side is more rural and less developed. Taiwan also has several small offshore islands.
#+end_quote

Looks fine.

*** Llama
Sfruttando la CLI fornita da [[https://github.com/rustformers/llama-rs][=llama-rs=/=llama-cli=]], è possibile passare un prompt da emacs e restituire i risultati direttamente nel browser.

# :tangle config.el
#+begin_src emacs-lisp
(defun llama-prompt (prompt)
  "Get a PROMTP for Llama and return the response."
  (interactive "sEnter PROMPT: ")
  (setq comd (concat "llama-cli --model-path ~/ggml-alpaca-7b-q4.bin -p \'" prompt "\'"))
  (insert (shell-command-to-string comd))
  (message "The Llama has spoken."))
#+end_src

Voglio evitare che questo processo faccia laggare l'intera piattaforma.
Mi serve un RPC stack per Emacs.

Prima installo =deferred=...

#+begin_src emacs-lisp :tangle packages.el
(package! deferred)
#+end_src

poi =epc=:

#+begin_src emacs-lisp :tangle packages.el
(package! epc :recipe (:host github :repo "kiwanami/emacs-epc"))
#+end_src

Scrivo =llamacs= e ne faccio un pacchetto.
A questo punto, devo configurarlo.

#+begin_src emacs-lisp :tangle config.el
(setq llamacs-model-path "~/ggml-alpaca-7b-q4.bin")
(setq llamacs-repo-path "~/Projects/llamacs/")
#+end_src

* Conclusions
# Questo file è in continua trasformazione.
This file is in constant change: more like a partially molded amorphous substance than like a liquid, but still in constant change.

# Esporto prism.js perché per il momento Zola ha un bug che non mi consente di colorare la sintassi.
{{{prismcss}}}
{{{prismjs}}}
